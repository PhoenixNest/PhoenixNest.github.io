
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>计算机网络原理 • （四）传输层 - PhoenixNest&#39;s Blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate"/>
    
        <meta name="keywords" content="PhoenixNest,PhoenixNest&#39;s Blog,">
    
    
        <meta name="description" content="PhoenixNest&#39;s Blog • 用实力让情怀落地,Introduction
本篇是对计算机网络原理一文中的传输层的详细介绍。
所用教学平台：Cisco Networking Academy


传输层（第4层）传输层的作用
应用层程序生成必须在源主,">
    
    
        <meta name="author" content="PhoenixNest">
    
    
        <link rel="alternative" href="atom.xml" title="PhoenixNest&#39;s Blog" type="application/atom+xml">
    
    
        <link rel="icon" href="/img/favicon.png">
    
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">

    
<link rel="stylesheet" href="/css/obsidian.css">

    
<link rel="stylesheet" href="/css/ball-atom.min.css">

    
<meta name="generator" content="Hexo 4.2.0"></head>


<body class="loading">
<div class="loader">
    <div class="la-ball-atom la-2x">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>
</div>
<span id="config-title" style="display:none">PhoenixNest&#39;s Blog</span>
<div id="loader"></div>
<div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="https://phoenixnest.github.io">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">计算机网络原理 • （四）传输层</h3>
        <div class="social">
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
                animation-delay: 600ms;
                animation-duration: 1.2s;
                background-image:
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url(https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/cisco.jpg) ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                    <a href="/categories/计算机网络"><b>「
                        </b>计算机网络<b> 」</b></a>
                
                一月 11, 2021
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/School-Computer-Network-Technology-4-Transport-Layer/" title="计算机网络原理 • （四）传输层" class="">计算机网络原理 • （四）传输层</a>
            </h3>
            
                <p class="post-count animated fadeInDown">
                    
                        <span>
                    <b class="iconfont icon-text2"></b> <i>文章字数</i>
                    14k
                </span>
                    
                    
                        <span>
                    <b class="iconfont icon-timer__s"></b> <i>阅读约需</i>
                    25 mins.
                </span>
                    
                    
                        <span id="/School-Computer-Network-Technology-4-Transport-Layer/" class="leancloud_visitors"
                              data-flag-title="计算机网络原理 • （四）传输层">
                    <b class="iconfont icon-read"></b> <i>阅读次数</i>
                    <span class="leancloud-visitors-count">0</span>
                </span>
                    
                    
                </p>
            
            
                <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E5%A4%A7%E5%AD%A6/" rel="tag">大学</a></li><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a></li><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/" rel="tag">计算机网络原理</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote>
<p>本篇是对<a href="https://phoenixnest.github.io/Notes-Computer-Network-Technology/">计算机网络原理</a>一文中的<a href="https://phoenixnest.github.io/Notes-Computer-Network-Technology/#%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%88%E7%AC%AC-4-%E5%B1%82%EF%BC%89">传输层</a>的详细介绍。</p>
<p>所用教学平台：<a href=""https://cn.netacad.com/"">Cisco Networking Academy</a></p>
</blockquote>
<hr>
<h2 id="传输层（第4层）"><a href="#传输层（第4层）" class="headerlink" title="传输层（第4层）"></a>传输层（第4层）</h2><h3 id="传输层的作用"><a href="#传输层的作用" class="headerlink" title="传输层的作用"></a>传输层的作用</h3><blockquote>
<p>应用层程序生成必须在源主机和目的主机之间交换的数据。传输层负责在不同主机上运行的应用程序之间进行的逻辑通信。这可能包括在两个主机之间建立临时会话以及应用程序信息的可靠传输等服务。</p>
</blockquote>
<p>传输层将应用层与负责网络传输的下层连接起来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_1.png" alt="传输层"></p>
<p>传输层并不了解目标主机类型、数据必须经过的介质类型、数据使用的路径，链路拥塞情况或网络大小。</p>
<p>传输层包括两个协议：</p>
<ul>
<li><strong>传输控制协议 (TCP)</strong></li>
<li><strong>用户数据报协议 (UDP)</strong></li>
</ul>
<hr>
<h3 id="传输层的职责"><a href="#传输层的职责" class="headerlink" title="传输层的职责"></a>传输层的职责</h3><ul>
<li><strong>跟踪各个会话</strong></li>
</ul>
<blockquote>
<p>在传输层中，源应用和目的应用之间传输的每个数据集称为会话并分别进行跟踪。<code>传输层负责维护并跟踪这些会话</code>。</p>
</blockquote>
<p>如图所示，每台主机上都可以有多个应用同时在网络上通信。</p>
<p><code>大多数网络对单个数据包能承载的数据量都有限制。因此，必须将数据分成可管理的部分</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_2_1.png" alt="跟踪各个会话"></p>
<ul>
<li><strong>数据分段和数据段重组</strong></li>
</ul>
<blockquote>
<p><code>传输层负责将应用程序数据划分为适当大小的块</code>。根据所使用的传输层协议，传输层块称为数据段或数据报。</p>
</blockquote>
<p>该图说明了使用不同块进行每个会话的传输层。</p>
<p>传输层将数据划分为更易于管理和传输的更小的块（即，数据段或数据报）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_2_2.png" alt="数据分段和数据段重组"></p>
<ul>
<li><strong>添加报头信息</strong></li>
</ul>
<blockquote>
<p><code>传输层协议还将包含二进制数据的报头信息添加到每个数据块中，这些数据被组织成几个字段</code>。不同的传输层协议通过这些字段值在管理数据通信过程中执行各自的功能。</p>
</blockquote>
<p>例如，接收主机使用报头信息将数据块重新组装为接收应用程序层程序的完整数据流。</p>
<p><code>传输层可以确保在设备上运行多个应用时，所有应用都能接收正确的数据</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_2_3.png" alt="添加报头信息"></p>
<ul>
<li><strong>标识应用</strong></li>
</ul>
<blockquote>
<p><strong>传输层必须能够划分和管理具有不同传输要求的多个通信</strong>。<code>为了将数据流传递到适当的应用程序，传输层使用称为端口号的标识符来标识目标应用</code>。</p>
</blockquote>
<p>如图所示，在每台主机中，每个需要访问网络的软件进程都将被分配一个唯一的端口号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_2_4.png" alt="标识应用"></p>
<ul>
<li><strong>会话多路复用</strong></li>
</ul>
<blockquote>
<p>将某些类型的数据（即视频流）作为完整的通信流在网络中发送，会使用所有可用带宽。这将阻止其他通信会话同时发生。而且也难以对损坏的数据开展错误恢复和重新传输的工作。</p>
</blockquote>
<p>如图所示，<code>传输层使用数据段和多路复用，使不同的通信会话在同一网络上交错</code>。</p>
<p><code>可对数据段中的数据执行错误检查，以确定数据段在传输过程中是否发生了更改</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_2_5.png" alt="会话多路复用"></p>
<hr>
<h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><p>IP 只涉及数据包的结构、地址分配和路由。IP 不指定数据包的传送或传输方式。</p>
<blockquote>
<p>传输层协议指定如何在主机之间传输消息，并负责管理会话的可靠性要求。<code>传输层包括 TCP 和 UDP 协议</code>。</p>
</blockquote>
<p>不同的应用有不同的传输可靠性要求。因此，TCP/IP 提供了两个传输层协议，如图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_3.png" alt="传输层协议"></p>
<hr>
<h3 id="传输控制协议-TCP"><a href="#传输控制协议-TCP" class="headerlink" title="传输控制协议 (TCP)"></a>传输控制协议 (TCP)</h3><p>IP 只涉及从原始发送方到最终目的地的数据包的结构、编址和路由。IP不负责保证传递或确定发送方和接收方之间是否需要建立连接。</p>
<blockquote>
<p><strong>TCP 被认为是可靠且功能齐全的传输层协议，用于确保所有数据到达目的设备</strong>。<code>TCP包含确保应用数据传递的字段。这些字段需要发送和接收的主机进行额外处理</code>。</p>
</blockquote>
<p>注意：<strong>TCP将数据分为若干个数据段</strong>。</p>
<blockquote>
<p>TCP 传输类似于从源到目的地跟踪发送的数据包。如果快递订单分多个数据包，客户可以在线查看发货顺序。</p>
</blockquote>
<p>TCP 使用以下基本操作提供可靠性和流量控制：</p>
<ul>
<li><strong>编号并跟踪从特定应用程序发送到特定主机的数据段。</strong></li>
<li><strong>确认收到数据</strong></li>
<li><strong>在一定时间段后重新传输未确认的数据</strong></li>
<li><strong>有顺序的数据可能以错误的顺序到达 以接收方可以接受的有效速率 发送数据</strong></li>
</ul>
<p>为了维护会话的状态并跟踪信息，TCP必须首先在发送方和接收方之间建立连接。这就是为什么TCP被称为是一种面向连接的协议。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_4.gif" alt="TCP 数据段和确认信息从发送方传输到接收方的过程"></p>
<p>有关 TCP 的更多信息，请在互联网上搜索 RFC 793。</p>
<hr>
<h3 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 (UDP)"></a>用户数据报协议 (UDP)</h3><blockquote>
<p><code>UDP是一种比TCP更简单的传输层协议</code>。它<strong>不提供可靠性和流量控制</strong>，这意味着它需要更少的报头字段。由于发送方和接收方UDP进程不需要管理可靠性和流量控制，这意味着 UDP 数据报的处理速度比 TCP 数据段快。UDP 仅提供在相应应用之间传输数据报的基本功能，需要很少的开销和数据检查。</p>
</blockquote>
<p>注意：<strong>UDP 将数据划分为数据报，也称为数据段</strong>。</p>
<blockquote>
<p>UDP是一种无连接协议。<code>由于 UDP 不提供可靠性或流量控制，因此不需要建立连接</code>。<code>由于 UDP 不跟踪客户端和服务器之间发送或接收的信息，因此UDP 也称为无状态协议</code>。</p>
</blockquote>
<p><code>UDP 也称为最大努力交付协议</code>，因为在目的地接收到数据后没有确认消息。<strong>UDP 中没有通知发送方是否成功传输的传输层流程</strong>。</p>
<p>UDP 类似于邮寄未挂号的常规信件。发件人不知道收件人是否能够接收信件。邮局也不负责跟踪信件或在信件未到达最终目的地时通知发件人。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_5.gif" alt="UDP 数据报从发送方传输到接收方"></p>
<hr>
<h3 id="正确的应用程序使用正确的传输层协议"><a href="#正确的应用程序使用正确的传输层协议" class="headerlink" title="正确的应用程序使用正确的传输层协议"></a>正确的应用程序使用正确的传输层协议</h3><blockquote>
<p><strong>一些应用可以容忍在网络传输过程中丢失部分数据，但是不接受传输中出现延迟</strong>。<code>由于需要的网络开销较少，对于这些应用，UDP 是更好的选择。UDP 是 IP 语音 (VoIP) 之类应用的首选</code>。<strong>确认和重新发送会拖慢传输速度，并使语音会话不可接受</strong>。</p>
</blockquote>
<p>UDP 也被“请求-回复”应用程序使用，其中数据最少，并且可以快速完成重新传输。例如，域名服务 (DNS) 为此类事务使用 UDP。客户端从DNS服务器请求已知域名的IPv4和IPv6地址。如果客户端在预定的时间内没有收到响应，它将再次发送请求。</p>
<p>例如，如果视频数据流中的一段或者两段数据未到达目的地，就会造成数据流的短暂中断。这可能表现为图像失真或声音失真，用户也许不会察觉。如果目的设备必须负责处理丢失的数据，则流可能在等待重新发送的过程中被推迟，从而导致图像或声音的质量大大降低。在这种情况下，最好利用接收到的分段呈现最佳媒体，并放弃可靠性。</p>
<hr>
<blockquote>
<p><strong>对于其他应用程序，重要的是所有数据都应到达并且可以按适当的顺序对其进行处理</strong>。<code>对于这些类型的应用程序，使用TCP 作为传输协议</code>。</p>
</blockquote>
<p>例如，数据库、Web 浏览器和邮件客户端等应用，要求发送的所有数据都必须以原始形式到达目的地。任何数据的丢失都可能导致通信失败，要么不能完成通信，要么通信的信息不可读。例如，通过网页访问银行信息时，确保所有信息都正确发送和接收是非常重要的。</p>
<hr>
<blockquote>
<p>应用开发人员必须根据应用的需求，选择适合的传输层协议类型。视频可以通过 TCP 或 UDP 发送。存储音频和视频流的应用使用 TCP。应用程序使用 TCP 执行缓冲、带宽探测和拥塞控制，以便更好地控制用户体验。</p>
<blockquote>
<p>实时视频和语音通常使用UDP，但也可能使用TCP，或同时使用UDP和TCP。视频会议应用程序默认情况下可能使用UDP，但由于许多防火墙阻止UDP，应用程序也可以通过TCP发送。</p>
</blockquote>
<blockquote>
<p>存储音频和视频流的应用使用 TCP。例如，如果您的网络突然不能支持观看一个点播电影所需的带宽，则应用使播放暂停。在暂停期间，您可能会看到一个“缓冲……”消息，这时，TCP 正在重建流。当所有的片段都井然有序且恢复最低限度的带宽时，您的 TCP 会话重新开始，电影恢复播放。</p>
</blockquote>
</blockquote>
<p>该图总结了UDP和TCP之间的差异。</p>
<p>列出了<strong>UDP（快速，低开销，没有确认，没有重新发送）</strong>和<strong>TCP（可靠，确认数据，重新发送丢失的数据，并传递有序列号的数据）</strong>之间的差异</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_6.png" alt="UDP和TCP之间的差异"></p>
<hr>
<h2 id="TCP-概述"><a href="#TCP-概述" class="headerlink" title="TCP 概述"></a>TCP 概述</h2><h3 id="TCP-功能"><a href="#TCP-功能" class="headerlink" title="TCP 功能"></a>TCP 功能</h3><p>除了支持数据分段和重组的基本功能之外，TCP 还提供以下服务：</p>
<ul>
<li><strong>建立会话</strong> - <code>TCP是一种面向连接的协议</code>，在转发任何流量之前，在源设备和目的设备之间协商并建立永久连接（或会话）。通过建立会话，设备可以协商特定时间能够转发的流量，而且两个设备之间的通信数据可得到严格管理。</li>
<li><strong>确保可靠的传递</strong> - 由于多种原因，数据段在网络传输过程中可能会损坏或者完全丢失。<code>TCP确保从源设备发送的每个数据段都能够到达目的地</code>。</li>
<li><strong>提供相同顺序的传递</strong> - 由于网络可能提供了多条路由，每条路由又有不同的传输速率，所以可能导致数据抵达的顺序错乱。通过对数据段编号和排序，<code>TCP 确保按正确的顺序重组这些数据段</code>。</li>
<li><strong>支持流量控制</strong> - 网络主机的资源有限（即，内存或处理能力）。当 TCP 发现这些资源超负荷运转时，它可以请求源应用程序降低数据流速。为此，TCP 会调整源设备传输的数据量。流量控制可避免当接收主机的资源不堪重负时，数据的重新传输。</li>
</ul>
<hr>
<h3 id="TCP-报头"><a href="#TCP-报头" class="headerlink" title="TCP 报头"></a>TCP 报头</h3><blockquote>
<p><strong>TCP是有状态的协议，意味着它跟踪通信会话的状态</strong>。为了跟踪会话的状态，TCP 记录已发送的信息和已确认的信息。<strong>状态会话开始于会话建立时，结束于会话终止时</strong>。</p>
</blockquote>
<p>在封装应用层数据时，TCP 数据段会增加 20 个字节（即 160 位）的开销。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_6.png" alt="TCP 报头中的字段"></p>
<hr>
<h3 id="TCP-报头字段"><a href="#TCP-报头字段" class="headerlink" title="TCP 报头字段"></a>TCP 报头字段</h3><table>
<thead>
<tr>
<th align="center">TCP 报头字段</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>源端口</strong></td>
<td align="center"><strong>一个16位字段</strong>，用于通过端口号标识源应用程序。</td>
</tr>
<tr>
<td align="center"><strong>目的端口</strong></td>
<td align="center"><strong>一个16位字段</strong>，用于通过端口号标识目的应用程序。</td>
</tr>
<tr>
<td align="center"><strong>序列号</strong></td>
<td align="center"><strong>一个32位字段</strong>，用于数据重组。</td>
</tr>
<tr>
<td align="center"><strong>确认号</strong></td>
<td align="center"><strong>一个32位字段</strong>，用于指示已接收到数据,并且期望从源 接收下一个字节。</td>
</tr>
<tr>
<td align="center"><strong>报头长度</strong></td>
<td align="center"><strong>一个4位字段</strong>，称为“数据偏移”, 表示 TCP 数据段报头的长度。</td>
</tr>
<tr>
<td align="center"><strong>保留</strong></td>
<td align="center"><strong>一个6位字段</strong>，保留供将来使用。</td>
</tr>
<tr>
<td align="center"><strong>控制位</strong></td>
<td align="center"><strong>一个6位字段</strong>，包括位代码或标志, 指示 TCP 段的目的和功能。</td>
</tr>
<tr>
<td align="center"><strong>窗口大小</strong></td>
<td align="center"><strong>一个16位字段</strong>，用于指示一次可以接受的字节数。</td>
</tr>
<tr>
<td align="center"><strong>校验和</strong></td>
<td align="center"><strong>一个16位字段</strong>，用于数据段报头和数据的错误检查。</td>
</tr>
<tr>
<td align="center"><strong>紧急</strong></td>
<td align="center"><strong>一个16位字段</strong>，用于指示包含的数据是否紧急。</td>
</tr>
</tbody></table>
<hr>
<h3 id="使用-TCP-的应用程序"><a href="#使用-TCP-的应用程序" class="headerlink" title="使用 TCP 的应用程序"></a>使用 TCP 的应用程序</h3><p>TCP 很好地说明了 TCP/IP 协议簇的不同层如何拥有特定角色。TCP 处理与将数据流划分为数据段、提供可靠性、控制数据流量和数据段重新排序相关的所有任务。TCP 使应用程序不用再管理这些任务。</p>
<p>如图所示的应用程序只需要将数据流发送到传输层和使用 TCP 提供的服务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_9.png" alt="指向两个方向的箭头，从HTTP、FTP、SMTP和SSH指向TCP，然后从TCP指向IP"></p>
<hr>
<h2 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h2><h3 id="UDP-功能"><a href="#UDP-功能" class="headerlink" title="UDP 功能"></a>UDP 功能</h3><blockquote>
<p><strong>UDP 是一种尽最大努力传输协议</strong>。<code>UDP 是一种轻型传输协议</code>，<strong>提供与 TCP 相同的数据分段和重组功能，但是没有 TCP 所提供的可靠性和流量控制</strong>。</p>
</blockquote>
<p>UDP 协议非常简单，它通常被描述为与 TCP 比较所不提供的功能。</p>
<p>UDP的特点包括以下几种：</p>
<ul>
<li><strong>数据按照接收顺序重构。</strong></li>
<li><strong>丢失的任何数据段都不会重新发送。</strong></li>
<li><strong>不会建立会话。</strong></li>
<li><strong>不会告知发送者资源可用性。</strong></li>
</ul>
<p>有关 UDP 的更多信息，请在互联网上搜索 RFC。</p>
<hr>
<h3 id="UDP-报头"><a href="#UDP-报头" class="headerlink" title="UDP 报头"></a>UDP 报头</h3><blockquote>
<p><strong>UDP 是无状态协议，这意味着客户端和服务器都不会跟踪通信会话的状态</strong>。如果使用 UDP 作为传输协议时要求可靠性，<code>必须由应用来处理可靠性</code>。</p>
</blockquote>
<p>通过网络传输实时视频和语音的一个最重要的要求是数据持续高速传输。实时视频和语音应用能够容忍具有极小或没有明显影响的一些数据丢失，非常适合于 UDP。</p>
<blockquote>
<p><code>UDP 中的通信块称为数据报或数据段</code>。这些数据报<strong>通过传输层协议尽力传送</strong>。</p>
<blockquote>
<p><code>UDP报头比TCP报头简单得多，因为它只有四个字段，需要8个字节(即64位)</code>。</p>
</blockquote>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_10.png" alt="UDP 报头中的字段"></p>
<hr>
<h3 id="UDP-报头字段"><a href="#UDP-报头字段" class="headerlink" title="UDP 报头字段"></a>UDP 报头字段</h3><table>
<thead>
<tr>
<th align="center">UDP 报头字段</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>源端口</strong></td>
<td align="center"><strong>一个16位字段</strong>，用于通过端口号标识源应用程序。</td>
</tr>
<tr>
<td align="center"><strong>目的端口</strong></td>
<td align="center"><strong>一个16位字段</strong>，用于通过端口号标识目的应用程序。</td>
</tr>
<tr>
<td align="center"><strong>长度</strong></td>
<td align="center"><strong>一个16位字段</strong>，指示UDP数据报报头的长度。</td>
</tr>
<tr>
<td align="center"><strong>校验和</strong></td>
<td align="center"><strong>一个16位字段</strong>，用于数据报报头和数据的错误检查。</td>
</tr>
</tbody></table>
<hr>
<h3 id="使用-UDP-的应用程序"><a href="#使用-UDP-的应用程序" class="headerlink" title="使用 UDP 的应用程序"></a>使用 UDP 的应用程序</h3><p>最适合采用 UDP 协议的三种应用程序包括：</p>
<ul>
<li><strong>实时视频和多媒体应用程序</strong> - 这些应用可以容忍部分数据丢失但要求延迟极小或没有延迟的应用程序。示例包括 VoIP 和实时流传输视频。</li>
<li><strong>简单请求和应答应用程序</strong> - 处理简单事务的应用程序，其中主机发送请求，但不一定收到应答。示例包括 DNS 和 DHCP。</li>
<li><strong>处理可靠性的应用程序</strong> - 不要求进行流量控制、错误检测、确认和错误恢复，或这些功能由应用程序来执行的单向通信。示例包括 SNMP 和 TFTP。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_12.png" alt="需要 UDP 的应用程序。显示了指向两个方向的箭头，从DHCP、DNS、SNMP、TFTP、VoIP和IPTV指向UDP，然后从UDP指向IP"></p>
<blockquote>
<p><strong>虽然 DNS 和 SNMP 默认使用 UDP，但它们都可以使用 TCP</strong>。<code>如果 DNS 请求或 DNS 响应大于 512 字节，DNS 会使用 TCP</code>，例如 DNS 响应包含许多域名解析时。同样，<code>在某些情况下，网络管理员可以配置 SNMP 使用 TCP</code>。</p>
</blockquote>
<hr>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><h3 id="多个单独的通信"><a href="#多个单独的通信" class="headerlink" title="多个单独的通信"></a>多个单独的通信</h3><p><strong>在某些情况下 TCP 是适合多个单独的通信的协议</strong>，在其他情况下则应使用 UDP。<code>无论传输何种类型的数据，TCP 和 UDP 都使用端口号</code>。</p>
<p>TCP 和 UDP 传输层协议使用端口号来管理多个同时的对话。如图所示，TCP和UDP报头字段标识源和目的应用程序端口号。</p>
<img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_13.png">

<p><code>源端口号与本地主机上的原始应用程序相关联，而目的端口号与远程主机上的目的应用程序相关联</code>。</p>
<p>例如，假设一台主机正在向 Web 服务器发起网页请求。当主机发起网页请求时，主机会动态生成源端口号，以惟一地标识会话。由主机生成的每个请求将使用不同的动态创建的源端口号。这就使多个会话能够同时发生。</p>
<blockquote>
<p>在请求中，目的端口号是标识目的Web服务器正在被请求的服务类型的端口号。例如，当客户端在目的端口中指定端口 80 时，接收该消息的服务器就知道请求的是 Web 服务。</p>
</blockquote>
<blockquote>
<p>服务器可同时提供多个服务，例如在端口 80 上提供 Web 服务，并同时在端口 21 上提供建立文件传输协议 (FTP) 连接的服务。</p>
</blockquote>
<hr>
<h3 id="套接字对"><a href="#套接字对" class="headerlink" title="套接字对"></a>套接字对</h3><p>源端口和目的端口都被置入<code>分段</code>内，然后分段<code>封装</code>于 IP 数据包内。<code>IP 数据包中含有源 IP 地址和目的 IP 地址</code>。源 IP 地址和源端口号的组合或者目的 IP 地址和目的端口号的组合，称为套接字。</p>
<p>在图中的示例中，PC 同时从目标服务器请求 FTP 和 Web 服务。</p>
<img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_14.png">

<p>在该示例中，PC生成的FTP请求包括第2层MAC地址和第3层IP地址。请求还标识了源端口号 1305（即，由主机动态生成）和标识了FTP服务的目的端口21。主机还使用相同的第 2 层和第 3 层地址从服务器请求了一个网页。但是，它使用的是源端口号 1099（即，由主机动态生成）和标识了Web服务的目的端口80。</p>
<blockquote>
<p>套接字用于标识客户端所请求的服务器和服务。客户端套接字可能如下所示，其中 1099 代表源端口号：192.168.1.5:1099，Web 服务器上的套接字则可能是192.168.1.7:80，这两个套接字组合在一起形成一个套接字对：192.168.1.5:1099，192.168.1.7:80</p>
<blockquote>
<p>有了套接字，一台客户端上运行的多个进程便可彼此区分，它们与同一服务器进程建立的多个连接也可以彼此区分。</p>
</blockquote>
<blockquote>
<p>对于请求数据的应用而言，该源端口号就像是一个返回地址。传输层将跟踪此端口和发出该请求的应用，当返回响应时，传输层可以将其转发到正确的应用。</p>
</blockquote>
</blockquote>
<hr>
<h3 id="端口号组"><a href="#端口号组" class="headerlink" title="端口号组"></a>端口号组</h3><p>互联网编号指派机构 (IANA) 是负责分配各种编址标准（包括端口号）的标准组织。<code>用于标识源端口号和目的端口号的16位二进制提供了从0到65535的端口范围</code>。</p>
<p>IANA 已将号码范围划分为以下三个端口组。</p>
<img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_15.png">

<p>注意: 一些客户端操作系统在分配源端口时可能使用注册端口号而不是动态端口号。</p>
<p>该表显示了一些常用的公认端口号及其相关应用程序。</p>
<table>
<thead>
<tr>
<th align="center">端口号</th>
<th align="center">协议</th>
<th align="center">应用层</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>20</strong></td>
<td align="center"><strong>TCP</strong></td>
<td align="center">文件传输协议 (FTP) - <strong>数据</strong></td>
</tr>
<tr>
<td align="center"><strong>21</strong></td>
<td align="center"><strong>TCP</strong></td>
<td align="center">文件传输协议 (FTP) - <strong>控制</strong></td>
</tr>
<tr>
<td align="center"><strong>22</strong></td>
<td align="center"><strong>TCP</strong></td>
<td align="center">安全 Shell (SSH)</td>
</tr>
<tr>
<td align="center"><strong>23</strong></td>
<td align="center"><strong>TCP</strong></td>
<td align="center">Telnet</td>
</tr>
<tr>
<td align="center"><strong>25</strong></td>
<td align="center"><strong>TCP</strong></td>
<td align="center">简单邮件传输协议 (SMTP)</td>
</tr>
<tr>
<td align="center"><strong>53</strong></td>
<td align="center"><strong>UDP、TCP</strong></td>
<td align="center">域名服务 (DNS)</td>
</tr>
<tr>
<td align="center"><strong>67</strong></td>
<td align="center"><strong>TCP</strong></td>
<td align="center">动态主机配置协议 (DHCP) - 服务器</td>
</tr>
<tr>
<td align="center"><strong>68</strong></td>
<td align="center"><strong>TCP</strong></td>
<td align="center">简单文件传输协议 (TFTP)</td>
</tr>
<tr>
<td align="center"><strong>80</strong></td>
<td align="center"><strong>TCP</strong></td>
<td align="center">超文本传输协议 (HTTP)</td>
</tr>
<tr>
<td align="center"><strong>110</strong></td>
<td align="center"><strong>TCP</strong></td>
<td align="center">邮局协议第 3 版 (POP3)</td>
</tr>
<tr>
<td align="center"><strong>143</strong></td>
<td align="center"><strong>TCP</strong></td>
<td align="center">互联网消息访问协议 (IMAP)</td>
</tr>
<tr>
<td align="center"><strong>161</strong></td>
<td align="center"><strong>TCP</strong></td>
<td align="center">简单网络管理协议 (SNMP)</td>
</tr>
<tr>
<td align="center"><strong>443</strong></td>
<td align="center"><strong>TCP</strong></td>
<td align="center">安全超文本传输协议 (HTTPS)</td>
</tr>
</tbody></table>
<p><code>一些应用程序可能既使用 TCP，又使用 UDP</code>。例如，当客户端向 DNS 服务器发送请求时，DNS 使用 UDP。但是，两台 DNS 服务器之间的通信始终使用 TCP。</p>
<p>在IANA网站上搜索端口注册表，来查看端口号及相关应用的完整列表。</p>
<hr>
<h3 id="netstat-命令"><a href="#netstat-命令" class="headerlink" title="netstat 命令"></a>netstat 命令</h3><blockquote>
<p>不明的 TCP 连接可能造成重大的安全威胁。因为此类连接表示某程序或某人正连接到本地主机。有些时候，需要了解联网主机中启用并运行了哪些活动 TCP 连接。<code>Netstat 是一种重要的网络实用程序，可用来检验此类连接</code>。</p>
</blockquote>
<p>如下所示，输入命令 netstat可列出正在使用的协议、本地地址和端口号、外部地址和端口号以及连接的状态。</p>
<pre><code class="bash">C:\&gt; netstat

Active Connections

  Proto  Local Address          Foreign Address        State
  TCP    192.168.1.124:3126     192.168.0.2:netbios-ssn    ESTABLISHED
  TCP    192.168.1.124:3158     207.138.126.152:http   ESTABLISHED
  TCP    192.168.1.124:3159     207.138.126.169:http   ESTABLISHED
  TCP    192.168.1.124:3160     207.138.126.169:http   ESTABLISHED
  TCP    192.168.1.124:3161     sc.msn.com:http        ESTABLISHED
  TCP    192.168.1.124:3166     www.cisco.com:http     ESTABLISHED
(output omitted)
C:\&gt;</code></pre>
<blockquote>
<p>默认情况下，<code>netstat命令会试图将 IP 地址解析为域名</code>，<code>将端口号解析为公认应用程序</code>。使用 <code>-n</code> 选项<strong>能够以数字形式显示 IP 地址和端口号</strong>。</p>
</blockquote>
<hr>
<h2 id="TCP-通信过程"><a href="#TCP-通信过程" class="headerlink" title="TCP 通信过程"></a>TCP 通信过程</h2><h3 id="TCP-服务器进程"><a href="#TCP-服务器进程" class="headerlink" title="TCP 服务器进程"></a>TCP 服务器进程</h3><blockquote>
<p>在服务器上运行的每个应用程序进程都配置为使用一个端口号。端口号由系统管理员自动分配或手动配置。</p>
<blockquote>
<p>在同一传输层服务中，单个服务器上不能同时存在具有相同端口号的两个不同服务。例如，主机同时运行 Web 服务器应用程序和文件传输应用程序时，不能为两个应用程序配置相同的端口（如 TCP 端口 80）。</p>
</blockquote>
<blockquote>
<p>分配有特定端口的活动服务器应用程序被认为是开放的，也就是说，传输层将接受并处理分配到该端口的数据段。所有发送到正确套接字地址的传入客户端请求都将被接受，数据将被传送到服务器应用。在同一服务器上可以同时开启很多端口，每个端口对应一个动态服务器应用。</p>
</blockquote>
</blockquote>
<p>TCP 服务器进程的详细信息：</p>
<ul>
<li>发送 TCP 请求的客户端</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_17_1.png" alt="客户端 1 正在请求 Web 服务，客户端 2 正在使用公认端口（即 Web 服务 = 端口 80，电子邮件服务 = 端口 25）请求电子邮件服务。"></p>
<ul>
<li>请求的目的端口</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_17_2.png" alt="请求动态生成源端口号。在这种情况下，客户端 1 使用源端口 49152，客户端 2 使用源端口 51152。"></p>
<ul>
<li>请求的源端口</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_17_3.png" alt="当服务器响应客户端请求时，它会反转发起请求的目的端口和源端口。"></p>
<ul>
<li>响应的目的端口</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_17_4.png" alt="注意，服务器对web请求的响应现在具有目的端口49152，而电子邮件的响应现在具有目的端口51152。"></p>
<ul>
<li>响应的源端口</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_17_5.png" alt="服务器响应中的源端口是发起请求中的原始目的端口。"></p>
<hr>
<h3 id="TCP-连接的建立"><a href="#TCP-连接的建立" class="headerlink" title="TCP 连接的建立"></a>TCP 连接的建立</h3><blockquote>
<p>双方都把握手的行为理解为友好问候的信号。网络中的连接是类似的。<code>在 TCP 连接中，主机客户端使用三次握手过程与服务器建立连接</code>。</p>
</blockquote>
<ul>
<li>SYN</li>
</ul>
<p><strong>源客户端请求与服务器进行客户端 - 服务器通信会话。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_18_1.png" alt="SYN"></p>
<ul>
<li>ACK 和 SYN</li>
</ul>
<p><strong>服务器确认客户端-服务器通信会话，并请求服务器 - 客户端通信会话。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_18_2.png" alt="ACK 和 SYN"></p>
<ul>
<li>ACK</li>
</ul>
<p><strong>源客户端确认服务器 - 客户端通信会话。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_18_3.png" alt="ACK"></p>
<blockquote>
<p>三次握手验证目标主机是否可用来通信。</p>
</blockquote>
<hr>
<h3 id="会话终止"><a href="#会话终止" class="headerlink" title="会话终止"></a>会话终止</h3><blockquote>
<p>若要关闭连接，分段报头必须设置完成 (FIN) 控制标志。为终止每个单向 TCP 会话，需采用包含 FIN 分段和确认 (ACK) 分段的二次握手。因此，若要终止 TCP 支持的整个会话过程，需要实施四次交换，以终止两个双向会话。客户端或服务器都可以发起终止。</p>
</blockquote>
<ul>
<li>FIN</li>
</ul>
<p><strong>当客户端的数据流中没有其他要发送的数据时，它将发送带 FIN 标志设置的分段。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_19_1.png" alt="FIN"></p>
<ul>
<li>ACK</li>
</ul>
<p><strong>服务器发送 ACK 信息，确认收到从客户端发出的请求终止会话的 FIN 信息。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_19_2.png" alt="ACK"></p>
<ul>
<li>FIN</li>
</ul>
<p><strong>服务器向客户端发送 FIN 信息，终止从服务器到客户端的会话。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_19_3.png" alt="FIN"></p>
<ul>
<li>ACK</li>
</ul>
<p><strong>客户端发送 ACK 响应信息，确认收到从服务器发出的 FIN 信息。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_19_4.png" alt="ACK"></p>
<p><code>当所有数据段得到确认后，会话关闭。</code></p>
<hr>
<h3 id="TCP-三次握手分析"><a href="#TCP-三次握手分析" class="headerlink" title="TCP 三次握手分析"></a>TCP 三次握手分析</h3><p>主机维护状态，跟踪会话过程中的每个分段，并使用 TCP 报头信息交换已接收数据的相关信息。TCP 是全双工协议，每个连接都代表两个单向通信会话。若要建立连接，主机应执行三次握手。如图所示，TCP 报头中的控制位指出了连接的进度和状态。</p>
<p>这些是三次握手的功能：</p>
<ul>
<li><strong>确认目的设备存在于网络上。</strong></li>
<li><strong>确认目的设备有活动的服务，并且正在源客户端要使用的目的端口号上接受请求。</strong></li>
<li><strong>通知目的设备源客户端想要在该端口号上建立通信会话。</strong></li>
</ul>
<p>通信完成后，将关闭会话并终止连接。连接和会话机制保障了 TCP 的可靠性功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_20.png" alt="控制位字段"></p>
<p>TCP 分段报头的控制位字段中的六位被称为标志。标志是设置为开启或关闭的位。</p>
<p><code>六个控制位</code>标志如下：</p>
<ul>
<li><strong>URG</strong> - 紧急指针字段（重要）</li>
<li><strong>ACK</strong> - 用于建立连接和会话终止的确认标志</li>
<li><strong>PSH</strong> - 推送功能</li>
<li><strong>RST</strong> - 在出现错误或超时时重置连接</li>
<li><strong>SYN</strong> - 同步建立连接中使用的序列号</li>
<li><strong>FIN</strong> - 没有更多来自发送方的数据，并用于会话终止</li>
</ul>
<p>搜索互联网以了解 PSH 和 URG 标志的详细信息。</p>
<hr>
<h2 id="可靠性和流控制"><a href="#可靠性和流控制" class="headerlink" title="可靠性和流控制"></a>可靠性和流控制</h2><h3 id="TCP-可靠性-保证及按序传递"><a href="#TCP-可靠性-保证及按序传递" class="headerlink" title="TCP 可靠性 - 保证及按序传递"></a>TCP 可靠性 - 保证及按序传递</h3><blockquote>
<p>对某些应用程序来说，TCP更好，原因是，与 <strong>UDP 不同，TCP 重新发送丢弃的数据包以及对数据包进行编号，以便在传递前指示其正确的顺序</strong>。<strong>TCP 还可以帮助维护数据包的流量，以避免设备过载</strong>。</p>
</blockquote>
<blockquote>
<p><strong>有时可能TCP数据段没有到达目的地</strong>。<strong>有时TCP段可能会无序到达</strong>。</p>
<blockquote>
<p>因此，为了让接收方理解原始消息，必须接收所有数据，并重组这些数据段，使其恢复原有顺序。每个数据包中的数据段报头中都含有序列号，便于进行数据重组。序列号代表 TCP 分段的第一个数据字节在完整数据中的位置。</p>
</blockquote>
</blockquote>
<blockquote>
<p>在会话建立过程中，将设置初始序列号 (ISN)。此 ISN 表示传输到接收应用的字节起始值。在会话过程中，每传送一定字节的数据，序列号就随之增加。通过这样的数据字节跟踪，可以唯一标识并确认每个分段，还可以标识丢失的分段。</p>
</blockquote>
<p><code>ISN 并不是从 1 开始，而是随机的数字</code>。这样做的<code>目的是防止某些类型的恶意攻击</code>。为简单起见，本章的示例中我们将使用 1 作为 ISN。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_21.png" alt="在目的设备上对 TCP 数据段进行重新排序"></p>
<blockquote>
<p><code>接收方的 TCP 进程将数据段中的数据存入缓存区，然后数据段按照正确的序列顺序进行排列，重组后发送到应用层</code>。<strong>对于序列号混乱的分段，将被保留以备后期处理。等缺失的分段到达后，再来按顺序处理这些分段</strong>。</p>
</blockquote>
<hr>
<h3 id="TCP-可靠性-数据丢失和重传"><a href="#TCP-可靠性-数据丢失和重传" class="headerlink" title="TCP 可靠性 - 数据丢失和重传"></a>TCP 可靠性 - 数据丢失和重传</h3><p>无论网络设计得有多好，数据丢失还是时有发生。<code>TCP 提供了管理数据段丢失的方法。其中一个方法就是重新传输未确认的数据</code>。</p>
<p><code>序列 (SEQ) 号和确认 (ACK) 号一起使用，以确认接收传输段中包含的数据字节</code>。<strong>SEQ 编号标识正在传输的数据段中的第一个字节</strong>。<strong>TCP 使用发送回源代码的 ACK 编号来指示接收方希望接收的下一个字节。这称为期望确认</strong>。</p>
<p><code>在进行后续增强之前，TCP只能确认预期的下一个字节</code>。</p>
<p>例如，在图中，为简单起见，主机A使用数据段号向主机B发送段1到10。如果除段3和段4之外的所有数据段都已到达，主机B将应答并确认指定下一个预期的数据段是段3。主机A不知道其他数据段是否到达。因此，主机A将重新发送段3到段10。如果所有重新发送的数据段都成功到达，则段 5 到 段10 将是重复的。这会导致延迟、拥塞和效率低下。</p>
<img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_22_1.png">

<blockquote>
<p>今天的主机操作系统通常采用一种称为选择性确认 (SAK) 的可选 TCP 功能，在三次握手期间协商。<strong>如果两个主机都支持SACK，则接收方可以明确地确认接收了哪些数据段(字节)，包括任何不连续的段</strong>。因此，发送主机只需要重新传输丢失的数据。</p>
</blockquote>
<p>例如，在下图中，还是为简单起见，主机A使用数据段号向主机B发送段1到10。如果除段3和段4之外的所有数据段都已到达，主机B可以确认它已经接收了段1和段2 (ACK 3)，并有选择地确认段5到10 (SACK 5-10)。主机A只需要重新发送段3和段4。</p>
<img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_22_2.png">

<p>注意：TCP通常会为每个其他数据包发送ACK，但是超出本主题范围的其他因素可能会改变这种行为。</p>
<blockquote>
<p>TCP使用计时器来知道在重新发送一个数据段之前需要等待多长时间。</p>
</blockquote>
<hr>
<h3 id="TCP-流量控制-窗口大小和确认"><a href="#TCP-流量控制-窗口大小和确认" class="headerlink" title="TCP 流量控制 - 窗口大小和确认"></a>TCP 流量控制 - 窗口大小和确认</h3><blockquote>
<p>TCP 还提供了流量控制机制。流量控制即目的主机能够可靠地接收并处理的数据量。<strong>流量控制可以调整给定会话中源和目的地之间的数据流速，有助于保持 TCP 传输的可靠性</strong>。为此，<code>TCP 报头包括一个称为“窗口大小”的 16 位字段</code>。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_23.png" alt="TCP 窗口大小和确认的示例"></p>
<p><code>窗口大小用于确定在获得确认前可以发送的字节数。确认号是指下一个预期字节的编号</code>。</p>
<blockquote>
<p>窗口大小是 TCP 会话的目的设备一次可以接受和处理的字节数。</p>
</blockquote>
<p>在本例中，PC B 用于 TCP 会话的初始窗口大小为 10000 字节。从第 1 个字节开始，字节数为 1，PC A 在不收到确认的前提下可以发送的最后一个字节为 10,000。这被称为PC A的发送窗口。每个 TCP 分段均包含窗口大小，那样目的设备可以根据缓冲区的可用性随时修改窗口大小。</p>
<blockquote>
<p>初始窗口大小在三次握手期间建立 TCP 会话时确定。源设备必须根据目的设备的窗口大小限制发送到目的设备的字节数。只有源设备收到字节数已接收的确认之后，才能继续发送更多会话数据。通常情况下，目的设备不会等待其窗口大小的所有字节接收后才以确认应答。接收和处理字节时，目的设备就会发送确认，以告知源设备它可以继续发送更多字节。</p>
</blockquote>
<p>例如，通常情况下，PC B 不会等待所有 10,000 字节都接收后才发送确认。这就意味着 PC A 可以在收到 PC B 的确认时调整其发送窗口。如图所示，当 PC A 收到确认号为 2,921 的确认消息时，它即是下一个预期的字节的编号。PC A 发送窗口将增加 2920 字节。这会将发送窗口从 10000 字节更改为 12920。现在只要 PC A 发送不超出其新的发送窗口 12920 的字节数，它就能够向 PC B 另外发送 10000 字节。</p>
<blockquote>
<p>目的设备在处理接收的字节时发送确认并不断调整源设备的发送窗口大小被称为滑动窗口。</p>
</blockquote>
<p>在上一个示例中，PC A 的发送窗口会增加或滑动了 2921 个字节，从 10000 增到 12920。</p>
<blockquote>
<p>如果目的设备缓冲区空间的可用性减小，它可以缩减窗口大小，通知源设备减少发送的字节数，而不需要接收确认。</p>
</blockquote>
<blockquote>
<p>注意：设备如今使用滑动窗口协议。接收方通常在每收到两个数据段之后发送确认。在确认之前收到的数据段的数量可能有所不同。滑动窗口的优势在于，只要接收方确认之前的数据段，就可以让发送方持续传输数据段。滑动窗口的详细信息不在本课程的讨论范围之内。</p>
</blockquote>
<hr>
<h3 id="TCP-流量控制-最大段大小-MSS"><a href="#TCP-流量控制-最大段大小-MSS" class="headerlink" title="TCP 流量控制-最大段大小 (MSS)"></a>TCP 流量控制-最大段大小 (MSS)</h3><p>如图所示，在每个TCP数据段内，源主机正在传输 1460 字节的数据。这通常是目的设备可接收的最大段大小 (MSS)。MSS 是 TCP 报头中选项字段的一部分，用于指定设备可以在单个 TCP数据段中接收的最大数据量（以字节为单位）。MSS 大小不包括 TCP 报头。MSS 通常包括在三次握手过程中。</p>
<img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_24_1.png">

<p>使用 IPv4 时，常见的 MSS 为 1460 字节。主机会从以太网最大传输单位 (MTU) 中减去 IP 和 TCP 报头，从而确定其 MSS 字段的值。在以太网接口上，默认 MTU 为 1500 个字节。减去 20 个字节的 IPv4 报头和 20 个字节的 TCP 报头，默认 MSS 大小为 1460 个字节，如图所示。</p>
<img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_24_2.png">

<hr>
<h3 id="TCP-流量控制-避免拥塞"><a href="#TCP-流量控制-避免拥塞" class="headerlink" title="TCP 流量控制 - 避免拥塞"></a>TCP 流量控制 - 避免拥塞</h3><p>网络中出现拥塞会使过载的路由器丢弃数据包。当包含 TCP 数据段的数据包未到达其目的地时，它们就成为未确认的数据包。通过确定 TCP 数据段发送但未确认的速率，源设备可以假设一定程度的网络拥塞。</p>
<p>出现网络拥塞时，从源设备丢失的 TCP 数据段就会重传。如果不适当控制重传，TCP 数据段的额外重传会使拥塞的情况更糟。网络中不仅有 TCP 数据段的新数据包，而且还有重传丢失的 TCP 数据段的反馈效果，这都增加了拥塞。为避免和控制拥塞，TCP 使用了多个拥塞处理机制、计时器和算法。</p>
<p>如果源设备确定 TCP 数据段没有被确认或没有被及时确认，它会在收到确认之前减少发送的字节数。如图所示，PC A 感知到存在拥塞，因此，在收到PC B的确认之前减少了它发送的字节数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_25.png" alt="TCP 拥塞控制"></p>
<p>注意是源设备在减少其发送的未确认的字节数，而不是由目的设备来确定窗口大小。</p>
<p>注意：实际拥塞处理机制、计时器和算法的解释不属于本课程的范围。</p>
<hr>
<h2 id="UDP-通信"><a href="#UDP-通信" class="headerlink" title="UDP 通信"></a>UDP 通信</h2><h3 id="UDP-低开销与可靠性"><a href="#UDP-低开销与可靠性" class="headerlink" title="UDP 低开销与可靠性"></a>UDP 低开销与可靠性</h3><p>如前所述，UDP非常适合需要快速通信的场合，比如VoIP。本主题详细解释为什么 UDP 非常适合某些类型的传输。如图所示，UDP 不建立连接。因为 UDP 的数据报头较小而且没有网络管理流量，因此可以提供低开销数据传输。</p>
<img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_26.png">

<hr>
<h3 id="UDP-数据报重组"><a href="#UDP-数据报重组" class="headerlink" title="UDP 数据报重组"></a>UDP 数据报重组</h3><p>与 TCP分段类似，当将多个 UDP 数据报发送到目的主机时，它们通常采用不同的路径，到达顺序也可能跟发送时的顺序不同。与 TCP 不同，UDP 不跟踪序列号。如图所示，UDP 不会按传输顺序重新排列数据报。</p>
<p>因此，UDP 仅仅是将接收到的数据按照先来后到的顺序转发到应用程序。如果数据顺序对应用程序很重要，应用程序必须确定正确的顺序并决定如何处理数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_27.png" alt="UDP：无连接和不可靠"></p>
<hr>
<h3 id="UDP-服务器进程与请求"><a href="#UDP-服务器进程与请求" class="headerlink" title="UDP 服务器进程与请求"></a>UDP 服务器进程与请求</h3><p>如图所示，与基于 TCP 的应用程序相同的是，基于 UDP 的服务器应用程序也被分配了公认端口号或注册端口号。当上述应用或进程在服务器上运行时，它们就会接受与所分配端口号相匹配的数据。当 UDP 收到用于某个端口的数据报时，它就会按照应用的端口号将数据发送到相应的应用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_28.png" alt="UDP 服务器侦听请求"></p>
<p>注意: 图中所示的远程认证拨号用户服务 (RADIUS) 服务器通过提供认证、授权和审计服务，来管理用户访问。RADIUS 的操作不属于本课程的范围。</p>
<hr>
<h3 id="UDP-客户端进程"><a href="#UDP-客户端进程" class="headerlink" title="UDP 客户端进程"></a>UDP 客户端进程</h3><p>与 TCP 一样，客户端应用向服务器进程请求数据，便会发起客户端-服务器通信。UDP 客户端进程则是从可用端口号中动态挑选一个端口号，用来作为会话的源端口。而目的端口通常都是分配到服务器进程的公认端口号或注册端口号。</p>
<p>客户端选定了源端口和目的端口后，通信事务中的所有数据报头都采用相同的端口对。对于从服务器到达客户端的数据来说，数据报头所含的源端口号和目的端口号作了互换。</p>
<ul>
<li><strong>发送 UDP 请求的客户端</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_29_1.png" alt="客户端1使用公认端口53发送DNS请求，而客户端2使用注册端口1812请求RADIUS身份验证服务"></p>
<ul>
<li><strong>请求目的端口</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_29_2.png" alt="客户端的请求会动态生成源端口号。在这种情况下，客户端 1 使用源端口 49152，客户端 2 使用源端口 51152"></p>
<ul>
<li><strong>UDP 请求源端口</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_29_3.png" alt="当服务器响应客户端请求时，它会反转发起请求的目的端口和源端口"></p>
<ul>
<li><strong>UDP 响应目的端口</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_29_4.png" alt="在服务器中，对DNS请求的响应目的端口现在是49152，而RADIUS身份验证的响应目的端口现在是51152"></p>
<ul>
<li><strong>UDP 响应源端口</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_29_5.png" alt="服务器响应中的源端口是发起请求中的原始目的端口"></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>数据传输</strong></li>
</ul>
<blockquote>
<p>传输层是应用层与负责网络传输的下层之间的纽带。传输层负责在不同主机上运行的应用程序之间进行逻辑通信。传输层包括 TCP 和 UDP 。传输层协议指定如何在主机之间传输消息，并负责管理会话的可靠性要求。传输层负责跟踪对话（会话）、分段数据和数据段重组、添加报头信息、识别应用程序和会话复用。TCP有状态的、可靠的、确认数据、重新发送丢失的数据，并按顺序传递数据。将 TCP 用于电子邮件和Web。UDP是无状态的、快速、开销低、不需要确认、不重新发送丢失的数据，并按照到达的顺序传递数据。将 UDP 用于 VoIP 和 DNS。</p>
</blockquote>
<ul>
<li><strong>TCP概述</strong></li>
</ul>
<blockquote>
<p>TCP 建立会话、确保可靠性、提供同序传递并支持流量控制。在封装应用层数据时，TCP数据段增加了20字节的开销作为报头信息。TCP报头字段包括源和目的端口、序列号、确认号、报头长度、保留、控制位、窗口大小、校验和和紧急。使用TCP的应用程序有HTTP、FTP、SMTP和Telnet。</p>
</blockquote>
<ul>
<li><strong>UDP概述</strong></li>
</ul>
<blockquote>
<p>UDP按照接收数据的顺序重构数据，不重新发送丢失的数据段，不建立会话，以及UDP不会通知发送方资源可用性。UDP报头字段是源和目的端口、长度和校验和。使用UDP的应用程序有DHCP、DNS、SNMP、TFTP、VoIP和视频会议。</p>
</blockquote>
<ul>
<li><strong>端口号</strong></li>
</ul>
<blockquote>
<p>TCP 和 UDP 传输层协议使用端口号来管理多个同时对话。这就是为什么TCP和UDP报头字段标识源和目的应用程序端口号。源端口和目的端口都被置入分段内，然后分段封装于 IP 数据包内。IP 数据包中含有源 IP 地址和目的 IP 地址。源 IP 地址和源端口号的组合或者目的 IP 地址和目的端口号的组合，称为套接字。套接字用于标识客户端所请求的服务器和服务。端口号的范围是从0到65535。此范围分为几组：公认端口、注册端口、专用端口和/或动态端口。有一些公认端口号保留给常见的应用程序，如 FTP、SSH、DNS、HTTP 和其他应用程序。有些时候，需要了解联网主机中启用并运行了哪些活动 TCP 连接。Netstat 是一种重要的网络实用程序，可用来检验此类连接。</p>
</blockquote>
<ul>
<li><strong>TCP通信过程</strong></li>
</ul>
<blockquote>
<p>在服务器上运行的每个应用程序进程都配置为使用一个端口号。端口号由系统管理员自动分配或手动配置。TCP服务器进程如下:客户端发送TCP请求，请求目的端口，请求源端口，响应目的端口和源端口请求。若要终止 TCP 支持的整个会话过程，需要实施四次交换，以终止两个双向会话。客户端或服务器都可以发起终止。三次握手确定目的设备是否存在于网络上，验证目的设备是否有活动服务，接受发起客户端打算使用的目的端口号上的请求，并通知目的设备源客户端打算在该端口号上建立一个通信会话。六个控制位标志是：URG、ACK、PSH、RST、SYN 和 FIN。</p>
</blockquote>
<ul>
<li><strong>可靠性与流量控制</strong></li>
</ul>
<blockquote>
<p>因此，为了让接收方理解原始消息，必须接收所有数据，并重组这些数据段，使其恢复原有顺序。每个数据包中的数据段报头中都含有序列号。无论网络设计得有多好，数据丢失还是时有发生。TCP 提供了管理数据段丢失的方法。对于未确认的数据，有一种重传数据段的机制。今天的主机操作系统通常采用一种称为选择性确认 (SAK) 的可选 TCP 功能，在三次握手期间协商。如果两个主机都支持SACK，则接收方可以明确地确认接收了哪些数据段(字节)，包括任何不连续的段。因此，发送主机只需要重新传输丢失的数据。流量控制可以调整源和目的地之间的数据流速，有助于保持 TCP 传输的可靠性。为此，TCP 报头包括一个称为“窗口大小”的 16 位字段。目的设备在处理接收的字节并不断调整源设备的发送窗口大小时发送确认的过程被称为滑动窗口。在每个TCP数据段内，源主机可能正在传输 1460 字节的数据。这是目的设备可以接收的典型 MSS。为避免和控制拥塞，TCP 使用了多个拥塞处理机制。源设备在减少其发送的未确认的字节数量，而不是由目的设备来确定窗口大小。</p>
</blockquote>
<ul>
<li><strong>UDP通信</strong></li>
</ul>
<blockquote>
<p>UDP 是一种简单协议，提供基本的传输层功能。当将多个 UDP 数据报发送到目的主机时，它们通常采用不同的路径，到达顺序也可能跟发送时的顺序不同。与 TCP 不同，UDP 不跟踪序列号。UDP 不会对数据报重组，因此也不会将数据恢复到传输时的顺序。UDP 仅仅是将接收到的数据按照先来后到的顺序转发到应用程序。如果数据顺序对应用很重要，应用必须确定正确的顺序并决定如何处理数据。为基于 UDP 的服务器应用程序分配公认或已注册的端口号。当 UDP 收到用于某个端口的数据报时，它就会按照应用的端口号将数据发送到相应的应用。UDP 客户端进程则是从可用端口号中动态挑选一个端口号，用来作为会话的源端口。而目的端口通常都是分配到服务器进程的公认端口号或注册端口号。客户端选定了源端口和目的端口后，通信事务中的所有数据报头都使用相同的端口对。对于从服务器到达客户端的数据来说，数据报头所含的源端口号和目的端口号作了互换。</p>
</blockquote>
<hr>
<h2 id="Donate-☕️"><a href="#Donate-☕️" class="headerlink" title="Donate ☕️"></a>Donate ☕️</h2><p>如果你喜欢我的博文，可以通过下面的方式支持我，你的支持是我最大的动力 😘</p>
<p>转载时请注明出处 ©️PhoenixNest</p>
<table>
<thead>
<tr>
<th align="center">Donate 😇</th>
<th align="center">Qr code</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Wechat</td>
<td align="center"><img src="/img/wechat.png" alt="Wechat"></td>
</tr>
<tr>
<td align="center">Ali Pay</td>
<td align="center"><img src="/img/alipay.png" alt="Ali Pay"></td>
</tr>
</tbody></table>

            <!--[if lt IE 9]>
            <script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                   data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Music/StarCraft Terran Band - Blood and Glory.mp3'></li>
                        
                    
                </ul>
            
            
            
            
                <div id="vcomments"></div>
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="/img/favicon.png" height=300 width=300></img>
                    <p>PhoenixNest</p>
                    <span>用实力让情怀落地</span>
                    
                </div>
                <ul>
                    <li><a href="/">25 <p>文章</p></a></li>
                    <li><a href="/categories">13 <p>分类</p></a></li>
                    <li><a href="/tags">23 <p>标签</p></a></li>
                </ul>
            </div>
            
                
                
                    <div class="box sticky animated fadeInRight faster">
                        <div id="toc" class="subbox">
                            <h4>目录</h4>
                            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#传输层（第4层）"><span class="toc-number">2.</span> <span class="toc-text">传输层（第4层）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#传输层的作用"><span class="toc-number">2.1.</span> <span class="toc-text">传输层的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#传输层的职责"><span class="toc-number">2.2.</span> <span class="toc-text">传输层的职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#传输层协议"><span class="toc-number">2.3.</span> <span class="toc-text">传输层协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#传输控制协议-TCP"><span class="toc-number">2.4.</span> <span class="toc-text">传输控制协议 (TCP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户数据报协议-UDP"><span class="toc-number">2.5.</span> <span class="toc-text">用户数据报协议 (UDP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正确的应用程序使用正确的传输层协议"><span class="toc-number">2.6.</span> <span class="toc-text">正确的应用程序使用正确的传输层协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-概述"><span class="toc-number">3.</span> <span class="toc-text">TCP 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-功能"><span class="toc-number">3.1.</span> <span class="toc-text">TCP 功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-报头"><span class="toc-number">3.2.</span> <span class="toc-text">TCP 报头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-报头字段"><span class="toc-number">3.3.</span> <span class="toc-text">TCP 报头字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-TCP-的应用程序"><span class="toc-number">3.4.</span> <span class="toc-text">使用 TCP 的应用程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP-概述"><span class="toc-number">4.</span> <span class="toc-text">UDP 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-功能"><span class="toc-number">4.1.</span> <span class="toc-text">UDP 功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-报头"><span class="toc-number">4.2.</span> <span class="toc-text">UDP 报头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-报头字段"><span class="toc-number">4.3.</span> <span class="toc-text">UDP 报头字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-UDP-的应用程序"><span class="toc-number">4.4.</span> <span class="toc-text">使用 UDP 的应用程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#端口号"><span class="toc-number">5.</span> <span class="toc-text">端口号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多个单独的通信"><span class="toc-number">5.1.</span> <span class="toc-text">多个单独的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#套接字对"><span class="toc-number">5.2.</span> <span class="toc-text">套接字对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#端口号组"><span class="toc-number">5.3.</span> <span class="toc-text">端口号组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netstat-命令"><span class="toc-number">5.4.</span> <span class="toc-text">netstat 命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-通信过程"><span class="toc-number">6.</span> <span class="toc-text">TCP 通信过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-服务器进程"><span class="toc-number">6.1.</span> <span class="toc-text">TCP 服务器进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-连接的建立"><span class="toc-number">6.2.</span> <span class="toc-text">TCP 连接的建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#会话终止"><span class="toc-number">6.3.</span> <span class="toc-text">会话终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-三次握手分析"><span class="toc-number">6.4.</span> <span class="toc-text">TCP 三次握手分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可靠性和流控制"><span class="toc-number">7.</span> <span class="toc-text">可靠性和流控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-可靠性-保证及按序传递"><span class="toc-number">7.1.</span> <span class="toc-text">TCP 可靠性 - 保证及按序传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-可靠性-数据丢失和重传"><span class="toc-number">7.2.</span> <span class="toc-text">TCP 可靠性 - 数据丢失和重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-流量控制-窗口大小和确认"><span class="toc-number">7.3.</span> <span class="toc-text">TCP 流量控制 - 窗口大小和确认</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-流量控制-最大段大小-MSS"><span class="toc-number">7.4.</span> <span class="toc-text">TCP 流量控制-最大段大小 (MSS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-流量控制-避免拥塞"><span class="toc-number">7.5.</span> <span class="toc-text">TCP 流量控制 - 避免拥塞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP-通信"><span class="toc-number">8.</span> <span class="toc-text">UDP 通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-低开销与可靠性"><span class="toc-number">8.1.</span> <span class="toc-text">UDP 低开销与可靠性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-数据报重组"><span class="toc-number">8.2.</span> <span class="toc-text">UDP 数据报重组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-服务器进程与请求"><span class="toc-number">8.3.</span> <span class="toc-text">UDP 服务器进程与请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-客户端进程"><span class="toc-number">8.4.</span> <span class="toc-text">UDP 客户端进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Donate-☕️"><span class="toc-number">10.</span> <span class="toc-text">Donate ☕️</span></a></li></ol>
                        </div>
                    </div>
                
            
        </div>
    </div>
</div>

    </div>
</div>
<div id="back-to-top" class="animated fadeIn faster">
    <div class="flow"></div>
    <span class="percentage animated fadeIn faster">0%</span>
    <span class="iconfont icon-top02 animated fadeIn faster"></span>
</div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2021
        <span class="gradient-text">
            PhoenixNest
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
    </p>
</footer>

    <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script>
        MathJax.Hub.Config({
            "HTML-CSS": {
                preferredFont: "TeX",
                availableFonts: ["STIX", "TeX"],
                linebreaks: {
                    automatic: true
                },
                EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
            },
            tex2jax: {
                inlineMath: [
                    ["$", "$"],
                    ["\\(", "\\)"]
                ],
                processEscapes: true,
                ignoreClass: "tex2jax_ignore|dno",
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            },
            TeX: {
                noUndefined: {
                    attributes: {
                        mathcolor: "red",
                        mathbackground: "#FFEEEE",
                        mathsize: "90%"
                    }
                },
                Macros: {
                    href: "{}"
                }
            },
            messageStyle: "none"
        });
    </script>
    <script>
        function initialMathJax() {
            MathJax.Hub.Queue(function () {
                var all = MathJax.Hub.getAllJax(),
                    i;
                // console.log(all);
                for (i = 0; i < all.length; i += 1) {
                    console.log(all[i].SourceElement().parentNode)
                    all[i].SourceElement().parentNode.className += ' has-jax';
                }
            });
        }

        function reprocessMathJax() {
            if (typeof MathJax !== 'undefined') {
                MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
            }
        }
    </script>




<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>


<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>


<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>


<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>

  
<script src="/js/busuanzi.min.js"></script>

<script>
    $(document).ready(function () {
        if ($('span[id^="busuanzi_"]').length) {
            initialBusuanzi();
        }
    });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
  

<script>
    function initialTyped() {
        var typedTextEl = $('.typed-text');
        if (typedTextEl && typedTextEl.length > 0) {
            var typed = new Typed('.typed-text', {
                strings: ['Let the feelings with the strength landing.', '用实力让情怀落地'],
                typeSpeed: 90,
                loop: true,
                loopCount: Infinity,
                backSpeed: 20,
            });
        }
    }

    if ($('.article-header') && $('.article-header').length) {
        $(document).ready(function () {
            initialTyped();
        });
    }
</script>

 
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
    var valine = new Valine();

    function initValine(path) {
        if (!path) path = window.location.pathname;
        let language = 'zh-CN';
        if (!language) {
            language = 'en';
        } else {
            language = language.toLowerCase();
        }
        valine.init({
            el: '#vcomments',
            appId: 'HDzkYOSz3NGcQuXbWMLin1mS-gzGzoHsz',
            appKey: 'pJ9JxbsY5D5aEmhxtCSNBlCT',
            notify: '',
            verify: '',
            avatar: '',
            placeholder: '温酒会知音.',
            visitor: 'true',
            path: path,
            lang: language,
        });
    }

    $(document).ready(function () {
        initValine();
    });
</script>



 <!-- 例：百度统计 --> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?your_code"; var s = document.getElementsByTagName("script")[0];  s.parentNode.insertBefore(hm, s); })(); </script> 

</html>
