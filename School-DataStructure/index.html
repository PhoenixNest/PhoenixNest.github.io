
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>数据结构与算法 - PhoenixNest&#39;s Blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate"/>
    
        <meta name="keywords" content="PhoenixNest,PhoenixNest&#39;s Blog,">
    
    
        <meta name="description" content="PhoenixNest&#39;s Blog • 用实力让情怀落地,引言
对实际问题进行缜密解析，并辅以优雅的代码进行编写。本篇整理了我学习数据结构与算法时的一些笔记，相关源码已上传Github托管。


Program = Data Structure + Alg,">
    
    
        <meta name="author" content="PhoenixNest">
    
    
        <link rel="alternative" href="atom.xml" title="PhoenixNest&#39;s Blog" type="application/atom+xml">
    
    
        <link rel="icon" href="/img/favicon.png">
    
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">

    
<link rel="stylesheet" href="/css/obsidian.css">

    
<link rel="stylesheet" href="/css/ball-atom.min.css">

    
<meta name="generator" content="Hexo 4.2.0"></head>


<body class="loading">
<div class="loader">
    <div class="la-ball-atom la-2x">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>
</div>
<span id="config-title" style="display:none">PhoenixNest&#39;s Blog</span>
<div id="loader"></div>
<div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="https://phoenixnest.github.io">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">数据结构与算法</h3>
        <div class="social">
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
                animation-delay: 600ms;
                animation-duration: 1.2s;
                background-image:
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url(https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/keyboard.jpg) ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                    <a href="/categories/数据结构"><b>「
                        </b>数据结构<b> 」</b></a>
                
                一月 09, 2021
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/School-DataStructure/" title="数据结构与算法" class="">数据结构与算法</a>
            </h3>
            
                <p class="post-count animated fadeInDown">
                    
                        <span>
                    <b class="iconfont icon-text2"></b> <i>文章字数</i>
                    8k
                </span>
                    
                    
                        <span>
                    <b class="iconfont icon-timer__s"></b> <i>阅读约需</i>
                    15 mins.
                </span>
                    
                    
                        <span id="/School-DataStructure/" class="leancloud_visitors"
                              data-flag-title="数据结构与算法">
                    <b class="iconfont icon-read"></b> <i>阅读次数</i>
                    <span class="leancloud-visitors-count">0</span>
                </span>
                    
                    
                </p>
            
            
                <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E5%A4%A7%E5%AD%A6/" rel="tag">大学</a></li><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s">Program = Data Structure + Algorithm</span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>对实际问题进行<code>缜密解析</code>，并辅以<code>优雅的代码</code>进行编写。<br>本篇整理了我学习数据结构与算法时的一些笔记，相关源码已上传<a href="https://github.com/PhoenixNest/StudyCPlusPlus" target="_blank" rel="noopener">Github</a>托管。</p>
</blockquote>
<hr>
<h2 id="Program-Data-Structure-Algorithm"><a href="#Program-Data-Structure-Algorithm" class="headerlink" title="Program = Data Structure + Algorithm"></a>Program = Data Structure + Algorithm</h2><blockquote>
<p>“程序 = 数据结构 + 算法”，这句出自Nicklaus Wirth教授的经典名言，使其一举夺得计算机界的诺贝尔奖 - 图灵奖，该公式对于计算机科学的影响几乎等同于Albert Einstein最为著名的质能等价理论：”E = mc²”，通过这短短的一个公式，便展露出程序的本质。</p>
</blockquote>
<hr>
<h2 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h2><blockquote>
<p>“数据结构(Data Structure)”是计算机程序设计的<code>重要理论基础</code>，是计算机专业最为<code>核心</code>的一门专业课程，同是也是一门<code>考研课程</code>。本篇将介绍我在进行数据结构学习时，所学习的第一个章节：数据结构的基本概念和术语。</p>
</blockquote>
<hr>
<h2 id="基本概念-Basic-Concept"><a href="#基本概念-Basic-Concept" class="headerlink" title="基本概念 Basic Concept"></a>基本概念 Basic Concept</h2><h3 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据 (Data)"></a>数据 (Data)</h3><p>数据是<code>信息的载体</code>，是<code>描述客观事物</code>的数字、字符，以及<code>所有能输入计算机中</code>的、<code>被计算机程序识别和处理的符号</code>的集合。包括<code>数值型数据</code>：整数、实数等，与<code>非数值型数据</code>：文字、图像、图形、声音等。</p>
<h3 id="数据元素-Data-Element"><a href="#数据元素-Data-Element" class="headerlink" title="数据元素 (Data Element)"></a>数据元素 (Data Element)</h3><p>数据元素是<code>数据中的一个&quot;个体&quot;</code>，是数据的<code>基本单位</code>。在有些情况下，数据元素也被称为<code>元素</code>、<code>结点</code>、<code>顶点</code>、<code>记录</code>等。数据元素<code>用于完整地描述一个对象</code>。如：一个学生记录、一张图片、图的一个顶点等。</p>
<h3 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h3><p>数据项是<code>组成数据元素</code>的有特定意义的<code>不可分割的最小单位</code>。如构成一个数据元素的<code>字段</code>、<code>域</code>、<code>属性</code>等都可称之为数据项。数据元素<code>是数据项的集合</code>。</p>
<p>简而言之，如上述举例中若要<code>组成一个学生记录</code>，那么<code>一个学生</code>可能包含有<code>学号</code>、<code>姓名</code>、<code>性别</code>、<code>班级</code>等属性，这些学号、姓名就是<code>构成一个学生记录的数据项</code>。</p>
<h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p>数据对象是具有<code>相同性质</code>的数据元素的<code>集合</code>，是<code>数据的一个子集</code>。</p>
<p>如：计算机专业的全体学生(其中<code>全体学生</code>为一个<code>集合</code>，<code>计算机专业</code>为每个学生个体的<code>相同性质</code>)。</p>
<hr>
<h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p>数据的<code>逻辑结构</code>讨论的是<code>元素之间的逻辑关系</code>，<code>与存储结构无关</code>，是<code>独立于计算机</code>的。常见的逻辑结构有：</p>
<ul>
<li><code>集合结构</code></li>
<li><code>线性结构</code> – (1 : 1)</li>
<li><code>树结构(层次结构)</code> – (1 : n)</li>
<li><code>图结构</code> – (n : m)</li>
</ul>
<h3 id="数据的存储结构-物理结构"><a href="#数据的存储结构-物理结构" class="headerlink" title="数据的存储结构(物理结构)"></a>数据的存储结构(物理结构)</h3><p>数据的存储结构(物理结构)研究的是数据及其逻辑关系<code>如何在计算机中存储与实现</code>。常见的存储结构有：</p>
<ul>
<li>顺序存储结构 (Sequential storage structure)</li>
</ul>
<p>借助元素在存储器中的<code>相对位置</code>表示数据元素之间的关系，通常用<code>数组</code>来实现。</p>
<table>
<thead>
<tr>
<th align="center">数组下标</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数组元素</td>
<td align="center">A</td>
<td align="center">B</td>
<td align="center">C</td>
<td align="center">D</td>
</tr>
</tbody></table>
<ul>
<li>链式存储结构</li>
</ul>
<p>借助<code>表示数据元素存储地址的指针</code>显式地指出数据元素之间的逻辑关系。</p>
<ul>
<li>散列(哈希)存储方式 (Hash (hash) storage method)</li>
</ul>
<p>是<code>专用于集合</code>的数据存储方式。<code>用一个哈希函数</code>将数据元素<code>按关键字</code>和<code>一个唯一的存储位置</code>关联起来。</p>
<ul>
<li>索引存储方式</li>
</ul>
<p>数据元素被<code>排成一个序列</code>：d1,d2,d3,…,dn，每个结点di在序列里都有<code>相应的位序i</code>(1 &lt;= i &lt;= n&gt;)，<code>位序</code>可以作为<code>结点的索引</code>存储在索引表中。检索时<code>利用结点的顺序号i来确定结点</code>的存储地址。(类似图书的<code>目录</code>。)</p>
<hr>
<h2 id="算法与算法分析"><a href="#算法与算法分析" class="headerlink" title="算法与算法分析"></a>算法与算法分析</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法是<code>指令的有限序列</code>，是对特定问题<code>求解步骤的描述</code>。算法具有下列五种<code>特性</code>：</p>
<ul>
<li>(1) 有穷性</li>
</ul>
<p>步骤<code>有限</code>，执行时间<code>有限</code>。</p>
<ul>
<li>(2) 确定性</li>
</ul>
<p>有<code>确切</code>的含义，<code>无二义性</code>，算法只有<code>唯一</code>的一条执行路径。</p>
<ul>
<li>(3) 可行性</li>
</ul>
<p>可以通过<code>已经实现</code>的基本运算<code>执行有限次</code>来实现。</p>
<ul>
<li>(4) 输入</li>
</ul>
<p>算法具有<code>0个</code>或<code>多个</code>输入。</p>
<ul>
<li>(5) 输出</li>
</ul>
<p>算法具有<code>1个</code>或<code>多个</code>输出。(一个算法不能没有输出。)</p>
<pre><code class="C++">int sum(int num)
{
    int result = 0;
    for (int i = 1; i &lt;= num; i++)
        result += i;

    return result;
}</code></pre>
<p><code>算法与程序</code>十分类似，但也有<code>区别</code>：</p>
<ul>
<li>在<code>执行时间上</code>：</li>
</ul>
<p><code>算法</code>所描述的步骤是<code>一定有限</code>的，但<code>程序</code>可以<code>无限执行</code>下去。如：一个操作系统是在一个无限循环中执行的，而不是一个算法。</p>
<ul>
<li>在<code>语言描述上</code>：</li>
</ul>
<p><code>程序</code>必须采用<code>规定的程序设计语言</code>来实现，而<code>算法没</code>有这种<code>限制</code>。</p>
<h3 id="算法的设计要求"><a href="#算法的设计要求" class="headerlink" title="算法的设计要求"></a>算法的<code>设计要求</code></h3><ul>
<li>正确性</li>
</ul>
<p>算法应该能<code>正确</code>地<code>实现预定功能</code>；</p>
<ul>
<li>易读性</li>
</ul>
<p>算法应<code>易于阅读</code>和<code>理解</code>，以<code>便与调试</code>、<code>修改</code>和<code>扩充</code>；</p>
<ul>
<li>健壮性</li>
</ul>
<p>当<code>环境发生变化</code>(如非法输入)时，能<code>正确作出反应</code>或<code>进行处理</code>，<code>不产生</code>不正确的运算结果；</p>
<ul>
<li>高效性</li>
</ul>
<p>算法应<code>有效地使用存储空间</code>并且<code>有较高的时间效率</code>。</p>
<h3 id="算法效率的衡量方法"><a href="#算法效率的衡量方法" class="headerlink" title="算法效率的衡量方法"></a>算法效率的衡量方法</h3><ul>
<li>事前分析法</li>
</ul>
<p>在<code>忽略计算机硬件、软件的因素后</code>，一个特定算法”工作量”的大小，只<code>依赖于问题的规模</code>。</p>
<ul>
<li>事后统计法(后期估算)</li>
</ul>
<p>通过<code>编写实际操作代码</code>，并将其<code>在计算机上进行运行</code>，通过<code>计算机的时钟</code>进行算法执行时间的统计。但由于时间统计<code>依赖于硬件与软件环境</code>，容易掩盖算法本身的优劣。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)是指该<code>算法的时间耗费</code>，是其所求解问题规模N的函数。当问题规模N趋于无穷大时，不考虑具体的运行时间函数，<code>只考虑运行时间函数的数量级(阶)</code>，这称为算法的渐进时间复杂度。</p>
<p>即：<code>忽略</code>低阶部分，只<code>保留</code>高阶部分，并<code>忽略</code>系数。</p>
<ul>
<li>常量阶</li>
</ul>
<pre><code class="C++">{
   ++x; s = 0; // 选取++x为基本操作，语句频度1，则时间复杂度O(n) = 1，即常量阶。
}</code></pre>
<pre><code class="C++">for (j = 1; j &lt;= 10000; ++j)
    {
        ++x; // 选取++x为基本操作，语句频度为10000(即：1 * 10000)，但需要忽略系数，则时间复杂度为O(n) = 1，即常量阶。
        s += x;
    }</code></pre>
<ul>
<li>对数阶</li>
</ul>
<pre><code class="C++">s = 0;
for (int j = 1; j &lt;= n; j *= 2)
    ++x;// 选取++x为基本操作，语句频度为log2n(以2为底的对数阶)，则时间复杂度为O(log2n)，即对数阶。
</code></pre>
<ul>
<li>线性阶</li>
</ul>
<pre><code class="C++">for (int i = 1; i &lt;= 2 * n; ++i)
    {
        ++x;// 选取++x为基本操作，则语句频度为2 * n，但需要忽略系数，则时间复杂度为O(n)，即线性阶。
        s += x;
    }</code></pre>
<ul>
<li>平方阶</li>
</ul>
<pre><code class="C++">for (j = 1; j &lt;= n; ++j)
    {// n + 1
        for (k = 1; k &lt;= n / 4; ++k)
        {
            // n * (n/4 + 1)
            ++x;// 选取++x为基本操作，则语句频度为n * n/4，忽略系数1/4，则时间复杂度为O(n^2)，即平方阶。
            s += x;
        }
    }</code></pre>
<ul>
<li>线性对数阶</li>
</ul>
<pre><code class="C++">for (int j = 1; j &lt;= n; j *= 2)
    {// 执行log2n次
        for (int k = 1; k &lt;= n; ++k)
        {
            ++x;// 选取++x为基本操作，则时间复杂度为O(nlog2n)，即线性对数阶。
            s += x;
        }
    }
</code></pre>
<ul>
<li>立方阶</li>
</ul>
<pre><code class="C++">for (int i = 1; i &lt;= n; i++)
    {// 执行n次
        for (int j = 1; j &lt;= n; j++)
        {// 执行n^2次
            c[i][j] = 0;
            for (int k = 1; k &lt;= n; k++)
            {// 执行n^3次，语句频度为n * n^2 * n^ 3，但只取最高阶，即时间复杂度为O(n^3)，即立方阶。
                c[i][j] = c[i][j] + a[i][k] * b[k][j];
            }
        }
    }</code></pre>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>如果<code>所需额外空间</code>相对于<code>输入数据量</code>来说只是一个<code>常数</code>，则称此算法为<code>&quot;原地工作&quot;</code>，此时的空间复杂度为O(1)。</p>
<p>例：问题<code>规模</code>为n，</p>
<p>(1)若使用<code>大小为n</code>的辅助一唯数组，则空间复杂度为：O(n)</p>
<p>(2)若使用<code>大小为n * n</code>的辅助一唯数组，则空间复杂度为：O(n^2)</p>
<p>(3)若使用了<code>100个</code>辅助变量，则空间复杂度为：O(1),即”原地工作”</p>
<hr>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>抽象数据类型和高级语言中的数据类型实质上<code>是一个概念</code>，抽象数据类型包含一般数据类型的概念，但<code>含义比一般数据类型更广、更抽象</code>。</p>
<p>抽象类型的<code>伪代码</code>定义格式如：</p>
<pre><code class="ADT">ADT 抽象数据类型名 {
    数据对象 D: &lt;数据对象的定义&gt;
    数据对象 R: &lt;数据对象的定义&gt;
    数据对象 P: &lt;数据对象的定义&gt;
} ADT 抽象数据类型名</code></pre>
<hr>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表(List)，作为<code>最简单</code>、<code>最基本</code>，也是<code>最常用</code>的一种<code>线性结构</code>。线性表是<code>n个</code>数据<code>元素的有限序列</code>。元素可以是<code>各种各样</code>的，但<code>必须有相同性质</code>，属于<code>同一种</code>数据对象。</p>
<p>例，XX学校设有n个学院，可用<code>线性表表示</code>如下：</p>
<p>{ “数学学院” , “外国语学院” , “声乐学院” , “计算机学院” , … }</p>
<p>表中的元素<code>都是</code>文本类型的<code>字符型值</code>，<code>不允许</code>出现<code>非文本类型</code>的数据。</p>
<p>当需要使用线性表<code>存储较为复杂的数据</code>时，一个<code>元素</code>也<code>可有多个数据项构成</code>，这种元素在线性表中<code>通常被称为&quot;记录 (record)&quot;</code></p>
<p>例，XX学校计算机学院的<code>学生成绩表</code>可表示为：</p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">Name</th>
<th align="center">Data Structure</th>
<th align="center">Software Engineering</th>
<th align="center">Discrete Mathematics</th>
<th align="center">Computer Network</th>
<th align="center">…</th>
</tr>
</thead>
<tbody><tr>
<td align="center">001</td>
<td align="center">Mike</td>
<td align="center">95</td>
<td align="center">90</td>
<td align="center">85</td>
<td align="center">80</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">002</td>
<td align="center">Jack</td>
<td align="center">90</td>
<td align="center">85</td>
<td align="center">80</td>
<td align="center">75</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">003</td>
<td align="center">Alice</td>
<td align="center">85</td>
<td align="center">80</td>
<td align="center">75</td>
<td align="center">70</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>该线性表中的<code>每一个元素</code>都是<code>一个学生</code>的成绩，也可看成<code>一个记录</code>，由<code>n个</code>科目成绩的<code>数据项构成</code>。从表中可以看出，每个<code>元素</code>都<code>有相同的数据项</code>，而各个<code>数据项</code>都<code>有自己的数据类型</code>。</p>
<hr>
<h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><h3 id="线性表的抽象数据类型-1"><a href="#线性表的抽象数据类型-1" class="headerlink" title="线性表的抽象数据类型"></a>线性表的<code>抽象数据类型</code></h3><pre><code class="C++">template &lt;class T&gt;
class List
{
public:
    virtual void clear() = 0;                          //* 清空顺序表
    virtual bool empty() const = 0;                    //* 判空，空为true，非空false
    virtual int size() const = 0;                      //* 表长
    virtual void insert(int position, const T &amp;value); //* 在position位置插入值为value的元素
    virtual void remove(int position) = 0;             //* 删除第position的位置的元素
    virtual int search(const T &amp;value);                //* 查找传入值value在顺序表中的位置
    virtual T visit(int position) const = 0;           //* 查找position位置的元素的值
    virtual void traverse() const = 0;                 //* 遍历当前顺序表
    virtual void inverse() = 0;                        //* 逆置当前顺序表
    virtual ~List(){};
};
</code></pre>
<h3 id="自定义的异常处理类-Customized-Exception-handling-class"><a href="#自定义的异常处理类-Customized-Exception-handling-class" class="headerlink" title="自定义的异常处理类 (Customized Exception handling class)"></a>自定义的<code>异常处理类</code> (Customized Exception handling class)</h3><pre><code class="C++">class outOfRange : public exception
{
public:
    //* 检查范围有效性
    const char *checkRange() const throw()
    {
        return &quot;OUT of RANGE&quot;;
    }
};

class errorSize : public exception
{
public:
    //* 检查长度有效性
    const char *checkSize() const throw()
    {
        return &quot;ERROR size&quot;;
    }
};</code></pre>
<hr>
<h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h2><h3 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h3><p>线性表在计算机内部有多种表示方法，最简单最<code>常用</code>的<code>方法</code>即用<code>顺序表示</code>。即在内存中用<code>地址连续</code>的一块<code>有限</code>的<code>表空间</code>，<code>存储</code>线性表的<code>各种元素</code>，这种形式存储的线性表称为<code>顺序表</code>。</p>
<p>顺序表用<code>物理</code>上的<code>相邻</code>(即内存中的<code>地址</code>是<code>连续</code>的，如：同一批产品的生产序号)<code>实现</code>元素之间的<code>逻辑相邻</code>关系。</p>
<p>假定顺序表中的<code>每个元素占k个存储单元</code>(如：一个元素占8个存储单元)，若知道<code>第一个元素</code>的地址(如：1000，即基地址)为<code>Loc(a0)</code>，则<code>位序为i的元素的地址</code>为：</p>
<p><code>Loc(ai) = Loc(a0) + i * k (0 &lt;= i &lt;= n-1)</code></p>
<p>此时<code>查找位序为i的元素</code>的<code>时间复杂度为O(1)</code>，可得顺序表具有<code>按元素位序</code>，进行<code>随机存取</code>的特点。</p>
<pre><code class="C++">template &lt;class T&gt;
class seqList : public List&lt;T&gt;
{
private:
    T *data;       //* 动态数组
    int length;    //* 当前顺序表表长
    int maxSize;   //* 顺序表最大长度
    void resize(); //* 表满时扩大表空间

public:
    seqList(int initSize = 10);   //* 构造函数
    seqList(seqList &amp;list);       //* 拷贝构造
    ~seqList() { delete[] data; } //* 析构函数

    void clear() { length = 0; }               //* 置空
    bool empty() const { return length == 0; } //* 判空
    int size() const { return length; }        //* 返回表长
    void traverse() const;                     //* 遍历当前表
    void inverse();                            //* 逆置当前表

    void insert(int position, const T &amp;value); //* 在position位置插入值为value的元素
    void remove(int position);                 //* 删除位于position的元素，length - 1
    int search(const T &amp;value) const;          //* 查找值为value的元素在表中的值
    T visit(int position) const;               //* 访问position位置元素的值

    bool Union(seqList&lt;T&gt; &amp;list);
};</code></pre>
<hr>
<h3 id="线性表的运算"><a href="#线性表的运算" class="headerlink" title="线性表的运算"></a>线性表的运算</h3><ul>
<li>构造函数 (Constructor)</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
seqList&lt;T&gt;::seqList(int initSize)
{
    if (initSize &lt;= 0)
        throw errorSize();

    maxSize = initSize;
    data = new T[maxSize];
    length = 0;
}</code></pre>
<ul>
<li>拷贝构造函数(动态分配存储空间)</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
seqList&lt;T&gt;::seqList(seqList &amp;seqList)
{
    maxSize = seqList.maxSize;
    length = seqList.length;
    data = new T[maxSize];
    for (int i = 0; i &lt; length; ++i)
        data[i] = seqList.data[i];
}</code></pre>
<ul>
<li><code>遍历</code>顺序表</li>
</ul>
<p>依次输出顺序表的所有元素。</p>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<pre><code class="C++">template &lt;class T&gt;
void seqList&lt;T&gt;::traverse() const
{
    if (empty())
    {
        cout &lt;&lt; &quot;Empty List&quot; &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; &quot;current Element: &quot; &lt;&lt; endl;
        for (int i = 0; i &lt; maxSize; i++)
            cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;

        cout &lt;&lt; endl;
    }
}</code></pre>
<ul>
<li><code>查找</code>运算</li>
</ul>
<p>在顺序表中查找值为value的元素的下标。</p>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<p>平均<code>期望值</code>：<code>(n+1)/2</code>，其中n为顺序表的元素个数。</p>
<pre><code class="C++">template &lt;class T&gt;
int seqList&lt;T&gt;::search(const T &amp;value) const
{
    for (int i = 0; i &lt; length; i++)
        if (value == data[i])
            return i;

    return -1;
}</code></pre>
<ul>
<li><code>插入</code>运算</li>
</ul>
<p>在顺序表下标为position的位置插入值为value的元素。</p>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<p>平均移动元素次数<code>(期望值)</code>：<code>n/2</code>，其中n为顺序表的元素个数。</p>
<pre><code class="C++">template &lt;class T&gt;
void seqList&lt;T&gt;::insert(int position, const T &amp;value)
{
    if (position &lt; 0 || position &gt; length)
        //* 判断是否越界
        throw outOfRange();

    if (length == maxSize)
        //* 当表满时，扩大表容量
        resize();

    for (int j = length; j &gt; position; j--)
        //* 向后移动在插入位置position之后的所有元素
        //* 注意此处移动的第一个元素下标为表尾元素下标
        data[j] = data[j - 1];

    //* 在空出位置插入值为value的元素
    data[position] = value;

    //* 表长 +1
    ++length;
}</code></pre>
<ul>
<li><code>删除</code>运算</li>
</ul>
<p>删除在顺序表下标为position的元素。</p>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<p>平均移动元素次数<code>(期望值)</code>：<code>(n-1)/2</code>，其中n为顺序表的元素个数。</p>
<pre><code class="C++">template &lt;class T&gt;
void seqList&lt;T&gt;::remove(int position)
{
    if (position &lt; 0 || position &gt; length - 1)
        //* 判断是否越界
        throw outOfRange();

    for (int j = position; j &lt; length - 1; j++)
        //* 前移在删除位置position之后的所有元素
        //* 注意此处移动的第一个元素下标为待删除元素的下标
        data[j] = data[j + 1];

    //* 表长 -1
    --length;
};</code></pre>
<ul>
<li><code>逆置</code>顺序表</li>
</ul>
<p>调整线性表的顺序，可用于倒序输出顺序表元素。</p>
<p>如：原顺序表为5，4，3，2，1，逆置后顺序表为1，2，3，4，5</p>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<p>平均移动元素次数<code>(期望值)</code>：<code>n/2</code>，其中n为顺序表的元素个数。</p>
<pre><code class="C++">template &lt;class T&gt;
void seqList&lt;T&gt;::inverse()
{
    T temp;
    for (int i = 0; i &lt; length / 2; i++) //* 控制交换次数
    {
        temp = data[i];
        data[i] = data[length - i - 1];
        data[length - i - 1] = temp;
    }
}</code></pre>
<ul>
<li><code>扩大</code>表空间</li>
</ul>
<p>算法思想：</p>
<p>由于数组空间在内存中<code>必须</code>是<code>连续</code>的，因此，<code>扩大</code>数组<code>空间</code>的操作需要：<code>(1)</code>重新申请一个更大规模的新数组，<code>(2)</code>将原有数组的内容复制到新数组中，<code>(3)</code>释放原有数组空间，<code>(4)</code>将新数组作为线性表的存储区。</p>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<pre><code class="C++">template &lt;class T&gt;
void seqList&lt;T&gt;::resize()
{
    T *p = data;           //* 指针p指向原顺序表空间
    maxSize *= 2;          //* 扩大2倍表空间
    data = new T[maxSize]; //* 将旧的数据指向新的表空间

    for (int i = 0; i &lt; length; ++i) //* 复制元素至扩大后的新表
        data[i] = p[i];

    delete[] p;
}</code></pre>
<hr>
<h3 id="顺序表的特点"><a href="#顺序表的特点" class="headerlink" title="顺序表的特点"></a>顺序表的<code>特点</code></h3><p>顺序表示的线性表(即<code>顺序表</code>)，有以下特点：</p>
<ul>
<li>存储密度大</li>
</ul>
<p>可在计算机<code>存储容量范围内存储大量元素</code>。</p>
<ul>
<li>随机存储</li>
</ul>
<p>由于<code>逻辑顺序</code>与<code>物理顺序</code>的<code>一致性</code>，顺序表能按元素符号<code>(下标)</code>直接存取，具有<code>随机存储</code>的优点。</p>
<ul>
<li>插入删除操作开销大</li>
</ul>
<p>由于要<code>保持</code>逻辑顺序和物理顺序的<code>一致性</code>，顺序表在进行插入、删除操作时，需要<code>移动大量的元素</code>(在<code>插入</code>元素<code>时</code>需<code>移动</code>整个顺序表近乎 <code>n/2 个元素</code>，在<code>删除</code>元素<code>时</code>需移动整个线性表近乎 <code>(n-1)/2 个元素</code>)</p>
<ul>
<li>易造成空间浪费与溢出</li>
</ul>
<p>顺序表需要<code>提前分配</code>存储空间，但因预留空间的困难性，分配过程中极<code>易造成</code>存储<code>空间</code>的<code>浪费</code>，而当<code>分配空间过小</code>时，则有出现<code>溢出</code>的风险。</p>
<ul>
<li>扩容难</li>
</ul>
<p><code>改变</code>顺序表的<code>大小时</code>(如扩大表空间为原来的2倍)，需<code>要创建</code>一个<code>新</code>的<code>顺序表</code>，把<code>原表</code>中的数据<code>复制到新表</code>中，然后<code>释放旧表</code>空间。</p>
<ul>
<li>静态存储与操作</li>
</ul>
<p>顺序表适合<code>静态</code>(不经常进行插入删除操作)、经常<code>定位访问</code>的线性表。</p>
<hr>
<h2 id="Donate-☕️"><a href="#Donate-☕️" class="headerlink" title="Donate ☕️"></a>Donate ☕️</h2><p>如果你喜欢我的博文，可以通过下面的方式支持我，你的支持是我最大的动力 😘</p>
<p>转载时请注明出处 ©️PhoenixNest</p>
<table>
<thead>
<tr>
<th align="center">Donate 😇</th>
<th align="center">Qr code</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Wechat</td>
<td align="center"><img src="/img/wechat.png" alt="Wechat"></td>
</tr>
<tr>
<td align="center">Ali Pay</td>
<td align="center"><img src="/img/alipay.png" alt="Ali Pay"></td>
</tr>
</tbody></table>

            <!--[if lt IE 9]>
            <script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                   data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Music/StarCraft Terran Band - Blood and Glory.mp3'></li>
                        
                    
                </ul>
            
            
            
            
                <div id="vcomments"></div>
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="/img/favicon.png" height=300 width=300></img>
                    <p>PhoenixNest</p>
                    <span>用实力让情怀落地</span>
                    
                </div>
                <ul>
                    <li><a href="/">26 <p>文章</p></a></li>
                    <li><a href="/categories">14 <p>分类</p></a></li>
                    <li><a href="/tags">24 <p>标签</p></a></li>
                </ul>
            </div>
            
                
                
                    <div class="box sticky animated fadeInRight faster">
                        <div id="toc" class="subbox">
                            <h4>目录</h4>
                            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Program-Data-Structure-Algorithm"><span class="toc-number">2.</span> <span class="toc-text">Program &#x3D; Data Structure + Algorithm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-Structure"><span class="toc-number">3.</span> <span class="toc-text">Data Structure</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念-Basic-Concept"><span class="toc-number">4.</span> <span class="toc-text">基本概念 Basic Concept</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据-Data"><span class="toc-number">4.1.</span> <span class="toc-text">数据 (Data)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据元素-Data-Element"><span class="toc-number">4.2.</span> <span class="toc-text">数据元素 (Data Element)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据项"><span class="toc-number">4.3.</span> <span class="toc-text">数据项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据对象"><span class="toc-number">4.4.</span> <span class="toc-text">数据对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据的逻辑结构"><span class="toc-number">4.5.</span> <span class="toc-text">数据的逻辑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据的存储结构-物理结构"><span class="toc-number">4.6.</span> <span class="toc-text">数据的存储结构(物理结构)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法与算法分析"><span class="toc-number">5.</span> <span class="toc-text">算法与算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法"><span class="toc-number">5.1.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法的设计要求"><span class="toc-number">5.2.</span> <span class="toc-text">算法的设计要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法效率的衡量方法"><span class="toc-number">5.3.</span> <span class="toc-text">算法效率的衡量方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度"><span class="toc-number">5.4.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空间复杂度"><span class="toc-number">5.5.</span> <span class="toc-text">空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象数据类型"><span class="toc-number">6.</span> <span class="toc-text">抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线性表"><span class="toc-number">7.</span> <span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线性表的抽象数据类型"><span class="toc-number">8.</span> <span class="toc-text">线性表的抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线性表的抽象数据类型-1"><span class="toc-number">8.1.</span> <span class="toc-text">线性表的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义的异常处理类-Customized-Exception-handling-class"><span class="toc-number">8.2.</span> <span class="toc-text">自定义的异常处理类 (Customized Exception handling class)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线性表的顺序表示和实现"><span class="toc-number">9.</span> <span class="toc-text">线性表的顺序表示和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线性表的顺序表示"><span class="toc-number">9.1.</span> <span class="toc-text">线性表的顺序表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线性表的运算"><span class="toc-number">9.2.</span> <span class="toc-text">线性表的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序表的特点"><span class="toc-number">9.3.</span> <span class="toc-text">顺序表的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Donate-☕️"><span class="toc-number">10.</span> <span class="toc-text">Donate ☕️</span></a></li></ol>
                        </div>
                    </div>
                
            
        </div>
    </div>
</div>

    </div>
</div>
<div id="back-to-top" class="animated fadeIn faster">
    <div class="flow"></div>
    <span class="percentage animated fadeIn faster">0%</span>
    <span class="iconfont icon-top02 animated fadeIn faster"></span>
</div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2021
        <span class="gradient-text">
            PhoenixNest
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
    </p>
</footer>

    <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script>
        MathJax.Hub.Config({
            "HTML-CSS": {
                preferredFont: "TeX",
                availableFonts: ["STIX", "TeX"],
                linebreaks: {
                    automatic: true
                },
                EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
            },
            tex2jax: {
                inlineMath: [
                    ["$", "$"],
                    ["\\(", "\\)"]
                ],
                processEscapes: true,
                ignoreClass: "tex2jax_ignore|dno",
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            },
            TeX: {
                noUndefined: {
                    attributes: {
                        mathcolor: "red",
                        mathbackground: "#FFEEEE",
                        mathsize: "90%"
                    }
                },
                Macros: {
                    href: "{}"
                }
            },
            messageStyle: "none"
        });
    </script>
    <script>
        function initialMathJax() {
            MathJax.Hub.Queue(function () {
                var all = MathJax.Hub.getAllJax(),
                    i;
                // console.log(all);
                for (i = 0; i < all.length; i += 1) {
                    console.log(all[i].SourceElement().parentNode)
                    all[i].SourceElement().parentNode.className += ' has-jax';
                }
            });
        }

        function reprocessMathJax() {
            if (typeof MathJax !== 'undefined') {
                MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
            }
        }
    </script>




<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>


<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>


<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>


<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>

  
<script src="/js/busuanzi.min.js"></script>

<script>
    $(document).ready(function () {
        if ($('span[id^="busuanzi_"]').length) {
            initialBusuanzi();
        }
    });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
  

<script>
    function initialTyped() {
        var typedTextEl = $('.typed-text');
        if (typedTextEl && typedTextEl.length > 0) {
            var typed = new Typed('.typed-text', {
                strings: ['Let the feelings with the strength landing.', '用实力让情怀落地'],
                typeSpeed: 90,
                loop: true,
                loopCount: Infinity,
                backSpeed: 20,
            });
        }
    }

    if ($('.article-header') && $('.article-header').length) {
        $(document).ready(function () {
            initialTyped();
        });
    }
</script>

 
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
    var valine = new Valine();

    function initValine(path) {
        if (!path) path = window.location.pathname;
        let language = 'zh-CN';
        if (!language) {
            language = 'en';
        } else {
            language = language.toLowerCase();
        }
        valine.init({
            el: '#vcomments',
            appId: 'HDzkYOSz3NGcQuXbWMLin1mS-gzGzoHsz',
            appKey: 'pJ9JxbsY5D5aEmhxtCSNBlCT',
            notify: '',
            verify: '',
            avatar: '',
            placeholder: '温酒会知音.',
            visitor: 'true',
            path: path,
            lang: language,
        });
    }

    $(document).ready(function () {
        initValine();
    });
</script>



 <!-- 例：百度统计 --> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?your_code"; var s = document.getElementsByTagName("script")[0];  s.parentNode.insertBefore(hm, s); })(); </script> 

</html>
