
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>数据结构与算法 - PhoenixNest&#39;s Blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate"/>
    
        <meta name="keywords" content="PhoenixNest,PhoenixNest&#39;s Blog,">
    
    
        <meta name="description" content="PhoenixNest&#39;s Blog • 用实力让情怀落地,引言
对实际问题进行缜密解析，并辅以优雅的代码进行编写。本篇整理了我学习数据结构与算法时的一些笔记，相关源码已上传Github托管。


C • Github

C++ • Github




P,">
    
    
        <meta name="author" content="PhoenixNest">
    
    
        <link rel="alternative" href="atom.xml" title="PhoenixNest&#39;s Blog" type="application/atom+xml">
    
    
        <link rel="icon" href="/img/favicon.png">
    
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">

    
<link rel="stylesheet" href="/css/obsidian.css">

    
<link rel="stylesheet" href="/css/ball-atom.min.css">

    
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="loading">
<div class="loader">
    <div class="la-ball-atom la-2x">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>
</div>
<span id="config-title" style="display:none">PhoenixNest&#39;s Blog</span>
<div id="loader"></div>
<div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="https://phoenixnest.github.io">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">数据结构与算法</h3>
        <div class="social">
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
                animation-delay: 600ms;
                animation-duration: 1.2s;
                background-image:
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url(https://cdn.jsdelivr.net/gh/PhoenixNest/Blog-Repository@master/keyboard.jpg) ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                    <a href="/categories/数据结构"><b>「
                        </b>数据结构<b> 」</b></a>
                
                一月 09, 2021
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/School-DataStructure/" title="数据结构与算法" class="">数据结构与算法</a>
            </h3>
            
                <p class="post-count animated fadeInDown">
                    
                        <span>
                    <b class="iconfont icon-text2"></b> <i>文章字数</i>
                    21k
                </span>
                    
                    
                        <span>
                    <b class="iconfont icon-timer__s"></b> <i>阅读约需</i>
                    39 mins.
                </span>
                    
                    
                        <span id="/School-DataStructure/" class="leancloud_visitors"
                              data-flag-title="数据结构与算法">
                    <b class="iconfont icon-read"></b> <i>阅读次数</i>
                    <span class="leancloud-visitors-count">0</span>
                </span>
                    
                    
                </p>
            
            
                <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E5%A4%A7%E5%AD%A6/" rel="tag">大学</a></li><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s">Program = Data Structure + Algorithm</span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>对实际问题进行<code>缜密解析</code>，并辅以<code>优雅的代码</code>进行编写。<br>本篇整理了我学习数据结构与算法时的一些笔记，相关源码已上传<code>Github</code>托管。</p>
</blockquote>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/PhoenixNest/Hello-C">C • Github</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/PhoenixNest/Hello-C-Plus-Plus">C++ • Github</a></p>
</li>
</ul>
<blockquote>
<ul>
<li><p>Program = Data Structure + Algorithm<br>“程序 = 数据结构 + 算法”，这句出自Nicklaus Wirth教授的经典名言，使其一举夺得计算机的诺贝尔奖 - 图灵奖，该公式对于计算机科学的影响几乎等同于Albert Einstein最为著名的质能等价理论：”E = mc²”，通过这短短的一个公式，便展露出程序的本质。</p>
</li>
<li><p>Data Structure<br>“数据结构(Data Structure)”是计算机程序设计的<code>重要理论基础</code>，是计算机专业最为<code>核心</code>的一门专业课程，同是也是一门<code>考研课程</code>。</p>
</li>
</ul>
</blockquote>
<hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><blockquote>
<p>数据是<code>信息的载体</code>，是<code>描述客观事物</code>的数字、字符，以及<code>所有能输入计算机中</code>的、<code>被计算机程序识别和处理的符号</code>的集合。包括<code>数值型数据</code>：整数、实数等，与<code>非数值型数据</code><br>：文字、图像、图形、声音等。</p>
</blockquote>
<h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><blockquote>
<p>数据元素是<code>数据中的一个&quot;个体&quot;</code>，是数据的<code>基本单位</code>。在有些情况下，数据元素也被称为<code>元素</code>、<code>结点</code>、<code>顶点</code>、<code>记录</code>等。数据元素<code>用于完整地描述一个对象</code>。如：一个学生记录、一张图片、图的一个顶点等。</p>
</blockquote>
<h3 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h3><blockquote>
<p>数据项是<code>组成数据元素</code>的有特定意义的<code>不可分割的最小单位</code>。如构成一个数据元素的<code>字段</code>、<code>域</code>、<code>属性</code>等都可称之为数据项。数据元素<code>是数据项的集合</code>。</p>
<p>简而言之，如上述举例中若要<code>组成一个学生记录</code>，那么<code>一个学生</code>可能包含有<code>学号</code>、<code>姓名</code>、<code>性别</code>、<code>班级</code>等属性，这些学号、姓名就是<code>构成一个学生记录的数据项</code>。</p>
</blockquote>
<h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><blockquote>
<p>数据对象是具有<code>相同性质</code>的数据元素的<code>集合</code>，是<code>数据的一个子集</code>。</p>
<p>如：计算机专业的全体学生(其中<code>全体学生</code>为一个<code>集合</code>，<code>计算机专业</code>为每个学生个体的<code>相同性质</code>)。</p>
</blockquote>
<hr>
<h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><blockquote>
<p>数据的<code>逻辑结构</code>讨论的是<code>元素之间的逻辑关系</code>，<code>与存储结构无关</code>，是<code>独立于计算机</code>的。常见的逻辑结构有：</p>
</blockquote>
<ul>
<li><p><code>集合结构</code></p>
</li>
<li><p><code>线性结构</code> – (1 : 1)</p>
</li>
<li><p><code>树结构(层次结构)</code> – (1 : n)</p>
</li>
<li><p><code>图结构</code> – (n : m)</p>
</li>
</ul>
<hr>
<h3 id="数据的存储结构-物理结构"><a href="#数据的存储结构-物理结构" class="headerlink" title="数据的存储结构(物理结构)"></a>数据的存储结构(物理结构)</h3><blockquote>
<p>数据的存储结构(物理结构)研究的是数据及其逻辑关系<code>如何在计算机中存储与实现</code>。常见的存储结构有：</p>
</blockquote>
<ul>
<li>顺序存储结构 (Sequential storage structure)</li>
</ul>
<blockquote>
<p>借助元素在存储器中的<code>相对位置</code>表示数据元素之间的关系，通常用<code>数组</code>来实现。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">数组下标</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数组元素</td>
<td align="center">A</td>
<td align="center">B</td>
<td align="center">C</td>
<td align="center">D</td>
</tr>
</tbody></table>
<ul>
<li>链式存储结构</li>
</ul>
<blockquote>
<p>借助<code>表示数据元素存储地址的指针</code>显式地指出数据元素之间的逻辑关系。</p>
</blockquote>
<ul>
<li>散列(哈希)存储方式 (Hash (hash) storage method)</li>
</ul>
<blockquote>
<p>是<code>专用于集合</code>的数据存储方式。<code>用一个哈希函数</code>将数据元素<code>按关键字</code>和<code>一个唯一的存储位置</code>关联起来。</p>
</blockquote>
<ul>
<li>索引存储方式</li>
</ul>
<blockquote>
<p>数据元素被<code>排成一个序列</code>：d1,d2,d3,…,dn，每个结点di在序列里都有<code>相应的位序i</code>(1 &lt;= i &lt;= n&gt;)，<code>位序</code>可以作为<code>结点的索引</code><br>存储在索引表中。检索时<code>利用结点的顺序号i来确定结点</code>的存储地址。(类似图书的<code>目录</code>。)</p>
</blockquote>
<hr>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><blockquote>
<p>算法是<code>指令的有限序列</code>，是对特定问题<code>求解步骤的描述</code>。算法具有下列五种<code>特性</code>：</p>
</blockquote>
<ul>
<li>(1) 有穷性</li>
</ul>
<blockquote>
<p>步骤<code>有限</code>，执行时间<code>有限</code>。</p>
</blockquote>
<ul>
<li>(2) 确定性</li>
</ul>
<blockquote>
<p>有<code>确切</code>的含义，<code>无二义性</code>，算法只有<code>唯一</code>的一条执行路径。</p>
</blockquote>
<ul>
<li>(3) 可行性</li>
</ul>
<blockquote>
<p>可以通过<code>已经实现</code>的基本运算<code>执行有限次</code>来实现。</p>
</blockquote>
<ul>
<li>(4) 输入</li>
</ul>
<blockquote>
<p>算法具有<code>0个</code>或<code>多个</code>输入。</p>
</blockquote>
<ul>
<li>(5) 输出</li>
</ul>
<blockquote>
<p>算法具有<code>1个</code>或<code>多个</code>输出。(一个算法不能没有输出。)</p>
</blockquote>
<pre><code class="C++">int sum(int num)
&#123;
    int result = 0;
    for (int i = 1; i &lt;= num; i++)
        result += i;

    return result;
&#125;
</code></pre>
<p><code>算法与程序</code>十分类似，但也有<code>区别</code>：</p>
<ul>
<li>在<code>执行时间上</code>：</li>
</ul>
<blockquote>
<p><code>算法</code>所描述的步骤是<code>一定有限</code>的，但<code>程序</code>可以<code>无限执行</code>下去。如：一个操作系统是在一个无限循环中执行的，而不是一个算法。</p>
</blockquote>
<ul>
<li>在<code>语言描述上</code>：</li>
</ul>
<blockquote>
<p><code>程序</code>必须采用<code>规定的程序设计语言</code>来实现，而<code>算法没</code>有这种<code>限制</code>。</p>
</blockquote>
<hr>
<h3 id="算法的设计要求"><a href="#算法的设计要求" class="headerlink" title="算法的设计要求"></a>算法的<code>设计要求</code></h3><ul>
<li>正确性</li>
</ul>
<blockquote>
<p>算法应该能<code>正确</code>地<code>实现预定功能</code>；</p>
</blockquote>
<ul>
<li>易读性</li>
</ul>
<blockquote>
<p>算法应<code>易于阅读</code>和<code>理解</code>，以<code>便与调试</code>、<code>修改</code>和<code>扩充</code>；</p>
</blockquote>
<ul>
<li>健壮性</li>
</ul>
<blockquote>
<p>当<code>环境发生变化</code>(如非法输入)时，能<code>正确作出反应</code>或<code>进行处理</code>，<code>不产生</code>不正确的运算结果；</p>
</blockquote>
<ul>
<li>高效性</li>
</ul>
<blockquote>
<p>算法应<code>有效地使用存储空间</code>并且<code>有较高的时间效率</code>。</p>
</blockquote>
<hr>
<h3 id="算法效率的衡量方法"><a href="#算法效率的衡量方法" class="headerlink" title="算法效率的衡量方法"></a>算法效率的衡量方法</h3><ul>
<li>事前分析法</li>
</ul>
<blockquote>
<p>在<code>忽略计算机硬件、软件的因素后</code>，一个特定算法”工作量”的大小，只<code>依赖于问题的规模</code>。</p>
</blockquote>
<ul>
<li>事后统计法(后期估算)</li>
</ul>
<blockquote>
<p>通过<code>编写实际操作代码</code>，并将其<code>在计算机上进行运行</code>，通过<code>计算机的时钟</code>进行算法执行时间的统计。但由于时间统计<code>依赖于硬件与软件环境</code>，容易掩盖算法本身的优劣。</p>
</blockquote>
<hr>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote>
<p>O(N)是指该<code>算法的时间耗费</code>，是其所求解问题规模N的函数。当问题规模N趋于无穷大时，不考虑具体的运行时间函数，<code>只考虑运行时间函数的数量级(阶)</code>，这称为算法的渐进时间复杂度。</p>
</blockquote>
<p>即：<code>忽略</code>低阶部分，只<code>保留</code>高阶部分，并<code>忽略</code>系数。</p>
<ul>
<li>常量阶</li>
</ul>
<pre><code class="C++">&#123;
   ++x; s = 0; // 选取++x为基本操作，语句频度1，则时间复杂度O(n) = 1，即常量阶。
&#125;
</code></pre>
<pre><code class="C++">for (j = 1; j &lt;= 10000; ++j)
    &#123;
        ++x; // 选取++x为基本操作，语句频度为10000(即：1 * 10000)，但需要忽略系数，则时间复杂度为O(n) = 1，即常量阶。
        s += x;
    &#125;
</code></pre>
<hr>
<ul>
<li>对数阶</li>
</ul>
<pre><code class="C++">s = 0;
for (int j = 1; j &lt;= n; j *= 2)
    ++x;// 选取++x为基本操作，语句频度为log2n(以2为底的对数阶)，则时间复杂度为O(log2n)，即对数阶。
</code></pre>
<hr>
<ul>
<li>线性阶</li>
</ul>
<pre><code class="C++">for (int i = 1; i &lt;= 2 * n; ++i)
    &#123;
        ++x;// 选取++x为基本操作，则语句频度为2 * n，但需要忽略系数，则时间复杂度为O(n)，即线性阶。
        s += x;
    &#125;
</code></pre>
<hr>
<ul>
<li>平方阶</li>
</ul>
<pre><code class="C++">for (j = 1; j &lt;= n; ++j)
    &#123;// n + 1
        for (k = 1; k &lt;= n / 4; ++k)
        &#123;
            // n * (n/4 + 1)
            ++x;// 选取++x为基本操作，则语句频度为n * n/4，忽略系数1/4，则时间复杂度为O(n^2)，即平方阶。
            s += x;
        &#125;
    &#125;
</code></pre>
<hr>
<ul>
<li>线性对数阶</li>
</ul>
<pre><code class="C++">for (int j = 1; j &lt;= n; j *= 2)
    &#123;// 执行log2n次
        for (int k = 1; k &lt;= n; ++k)
        &#123;
            ++x;// 选取++x为基本操作，则时间复杂度为O(nlog2n)，即线性对数阶。
            s += x;
        &#125;
    &#125;
</code></pre>
<hr>
<ul>
<li>立方阶</li>
</ul>
<pre><code class="C++">for (int i = 1; i &lt;= n; i++)
    &#123;// 执行n次
        for (int j = 1; j &lt;= n; j++)
        &#123;// 执行n^2次
            c[i][j] = 0;
            for (int k = 1; k &lt;= n; k++)
            &#123;// 执行n^3次，语句频度为n * n^2 * n^ 3，但只取最高阶，即时间复杂度为O(n^3)，即立方阶。
                c[i][j] = c[i][j] + a[i][k] * b[k][j];
            &#125;
        &#125;
    &#125;
</code></pre>
<hr>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><blockquote>
<p>如果<code>所需额外空间</code>相对于<code>输入数据量</code>来说只是一个<code>常数</code>，则称此算法为<code>&quot;原地工作&quot;</code>，此时的空间复杂度为O(1)。</p>
</blockquote>
<p>例：问题<code>规模</code>为n，</p>
<p>(1)若使用<code>大小为n</code>的辅助一唯数组，则空间复杂度为：O(n)</p>
<p>(2)若使用<code>大小为n * n</code>的辅助一唯数组，则空间复杂度为：O(n^2)</p>
<p>(3)若使用了<code>100个</code>辅助变量，则空间复杂度为：O(1),即”原地工作”</p>
<hr>
<h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><blockquote>
<p>抽象数据类型和高级语言中的数据类型实质上<code>是一个概念</code>，抽象数据类型包含一般数据类型的概念，但<code>含义比一般数据类型更广、更抽象</code>。</p>
</blockquote>
<p>抽象类型的<code>伪代码</code>定义格式如：</p>
<pre><code class="ADT">ADT 抽象数据类型名 &#123;
    数据对象 D: &lt;数据对象的定义&gt;
    数据对象 R: &lt;数据对象的定义&gt;
    数据对象 P: &lt;数据对象的定义&gt;
&#125; ADT 抽象数据类型名
</code></pre>
<hr>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><blockquote>
<p>线性表(List)，作为<code>最简单</code>、<code>最基本</code>，也是<code>最常用</code>的一种<code>线性结构</code>。线性表是<code>n个</code>数据<code>元素的有限序列</code>。元素可以是<code>各种各样</code>的，但<code>必须有相同性质</code>，属于<code>同一种</code>数据对象。</p>
</blockquote>
<p>例，XX学校设有n个学院，可用<code>线性表表示</code>如下：</p>
<p>{ “数学学院” , “外国语学院” , “声乐学院” , “计算机学院” , … }</p>
<p>表中的元素<code>都是</code>文本类型的<code>字符型值</code>，<code>不允许</code>出现<code>非文本类型</code>的数据。</p>
<p>当需要使用线性表<code>存储较为复杂的数据</code>时，一个<code>元素</code>也<code>可有多个数据项构成</code>，这种元素在线性表中<code>通常被称为&quot;记录 (record)&quot;</code></p>
<p>例，XX学校计算机学院的<code>学生成绩表</code>可表示为：</p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">Name</th>
<th align="center">Data Structure</th>
<th align="center">Software Engineering</th>
<th align="center">Discrete Mathematics</th>
<th align="center">Computer Network</th>
<th align="center">…</th>
</tr>
</thead>
<tbody><tr>
<td align="center">001</td>
<td align="center">Mike</td>
<td align="center">95</td>
<td align="center">90</td>
<td align="center">85</td>
<td align="center">80</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">002</td>
<td align="center">Jack</td>
<td align="center">90</td>
<td align="center">85</td>
<td align="center">80</td>
<td align="center">75</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">003</td>
<td align="center">Alice</td>
<td align="center">85</td>
<td align="center">80</td>
<td align="center">75</td>
<td align="center">70</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>该线性表中的<code>每一个元素</code>都是<code>一个学生</code>的成绩，也可看成<code>一个记录</code>，由<code>n个</code>科目成绩的<code>数据项构成</code>。从表中可以看出，每个<code>元素</code>都<code>有相同的数据项</code>，而各个<code>数据项</code>都<code>有自己的数据类型</code>。</p>
<hr>
<h3 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的<code>抽象数据类型</code></h3><pre><code class="C++">template &lt;class T&gt;
class List
&#123;
public:
    virtual void clear() = 0;                          //* 清空顺序表
    virtual bool empty() const = 0;                    //* 判空，空为true，非空false
    virtual int size() const = 0;                      //* 表长
    virtual void insert(int position, const T &amp;value); //* 在position位置插入值为value的元素
    virtual void remove(int position) = 0;             //* 删除第position的位置的元素
    virtual int search(const T &amp;value);                //* 查找传入值value在顺序表中的位置
    virtual T visit(int position) const = 0;           //* 查找position位置的元素的值
    virtual void traverse() const = 0;                 //* 遍历当前顺序表
    virtual void inverse() = 0;                        //* 逆置当前顺序表
    virtual ~List()&#123;&#125;;
&#125;;
</code></pre>
<h3 id="自定义的异常处理类"><a href="#自定义的异常处理类" class="headerlink" title="自定义的异常处理类"></a>自定义的<code>异常处理类</code></h3><pre><code class="C++">class outOfRange : public exception
&#123;
public:
    //* 检查范围有效性
    const char *checkRange() const throw()
    &#123;
        return &quot;OUT of RANGE&quot;;
    &#125;
&#125;;

class errorSize : public exception
&#123;
public:
    //* 检查长度有效性
    const char *checkSize() const throw()
    &#123;
        return &quot;ERROR size&quot;;
    &#125;
&#125;;
</code></pre>
<hr>
<h3 id="线性表的【顺序】表示"><a href="#线性表的【顺序】表示" class="headerlink" title="线性表的【顺序】表示"></a>线性表的【顺序】表示</h3><blockquote>
<p>线性表 (List) 在计算机内部有多种表示方法，最简单最<code>常用</code>的<code>方法</code>即用<code>顺序表示</code>。即在内存中用<code>地址连续</code>的一块<code>有限</code>的<code>表空间</code>，<code>存储</code>线性表的<code>各种元素</code><br>，这种形式存储的线性表称为<code>顺序表</code>。</p>
<p>顺序表用<code>物理</code>上的<code>相邻</code>(即内存中的<code>地址</code>是<code>连续</code>的，如：同一批产品的生产序号)<code>实现</code>元素之间的<code>逻辑相邻</code>关系。</p>
</blockquote>
<p>假定顺序表中的<code>每个元素占k个存储单元</code>(如：一个元素占8个存储单元)，若知道<code>第一个元素</code>的地址(如：1000，即基地址)为<code>Loc(a0)</code>，则<code>位序为i的元素的地址</code>为：</p>
<p><code>Loc(ai) = Loc(a0) + i * k (0 &lt;= i &lt;= n-1)</code></p>
<p>此时<code>查找位序为i的元素</code>的<code>时间复杂度为O(1)</code>，可得顺序表具有<code>按元素位序</code>，进行<code>随机存取</code>的特点。</p>
<pre><code class="C++">template &lt;class T&gt;
class seqList : public List&lt;T&gt;
&#123;
private:
    T *data;       //* 动态数组
    int length;    //* 当前顺序表表长
    int maxSize;   //* 顺序表最大长度
    void resize(); //* 表满时扩大表空间

public:
    seqList(int initSize = 10);   //* 构造函数
    seqList(seqList &amp;list);       //* 拷贝构造
    ~seqList() &#123; delete[] data; &#125; //* 析构函数

    void clear() &#123; length = 0; &#125;               //* 置空
    bool empty() const &#123; return length == 0; &#125; //* 判空
    int size() const &#123; return length; &#125;        //* 返回表长
    void traverse() const;                     //* 遍历当前表
    void inverse();                            //* 逆置当前表

    void insert(int position, const T &amp;value); //* 在position位置插入值为value的元素
    void remove(int position);                 //* 删除位于position的元素，length - 1
    int search(const T &amp;value) const;          //* 查找值为value的元素在表中的值
    T visit(int position) const;               //* 访问position位置元素的值

    bool Union(seqList&lt;T&gt; &amp;list);
&#125;;
</code></pre>
<hr>
<h3 id="顺序表的运算"><a href="#顺序表的运算" class="headerlink" title="顺序表的运算"></a>顺序表的运算</h3><ul>
<li>构造函数</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
seqList&lt;T&gt;::seqList(int initSize)
&#123;
    if (initSize &lt;= 0)
        throw errorSize();

    maxSize = initSize;
    data = new T[maxSize];
    length = 0;
&#125;
</code></pre>
<hr>
<ul>
<li>拷贝构造函数(动态分配存储空间)</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
seqList&lt;T&gt;::seqList(seqList &amp;seqList)
&#123;
    maxSize = seqList.maxSize;
    length = seqList.length;
    data = new T[maxSize];
    for (int i = 0; i &lt; length; ++i)
        data[i] = seqList.data[i];
&#125;
</code></pre>
<hr>
<ul>
<li><code>遍历</code>顺序表</li>
</ul>
<blockquote>
<p>依次输出顺序表的所有元素。</p>
</blockquote>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<pre><code class="C++">template &lt;class T&gt;
void seqList&lt;T&gt;::traverse() const
&#123;
    if (empty())
    &#123;
        cout &lt;&lt; &quot;Empty List&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;current Element: &quot; &lt;&lt; endl;
        for (int i = 0; i &lt; maxSize; i++)
            cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;

        cout &lt;&lt; endl;
    &#125;
&#125;
</code></pre>
<hr>
<ul>
<li><code>查找</code>运算</li>
</ul>
<blockquote>
<p>在顺序表中查找值为value的元素的下标。</p>
</blockquote>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<p>平均<code>期望值</code>：<code>(n+1)/2</code>，其中n为顺序表的元素个数。</p>
<pre><code class="C++">template &lt;class T&gt;
int seqList&lt;T&gt;::search(const T &amp;value) const
&#123;
    for (int i = 0; i &lt; length; i++)
        if (value == data[i])
            return i;

    return -1;
&#125;
</code></pre>
<hr>
<ul>
<li><code>插入</code>运算</li>
</ul>
<blockquote>
<p>在顺序表下标为position的位置插入值为value的元素。</p>
</blockquote>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<p>平均移动元素次数<code>(期望值)</code>：<code>n/2</code>，其中n为顺序表的元素个数。</p>
<pre><code class="C++">template &lt;class T&gt;
void seqList&lt;T&gt;::insert(int position, const T &amp;value)
&#123;
    if (position &lt; 0 || position &gt; length)
        //* 判断是否越界
        throw outOfRange();

    if (length == maxSize)
        //* 当表满时，扩大表容量
        resize();

    for (int j = length; j &gt; position; j--)
        //* 向后移动在插入位置position之后的所有元素
        //* 注意此处移动的第一个元素下标为表尾元素下标
        data[j] = data[j - 1];

    //* 在空出位置插入值为value的元素
    data[position] = value;

    //* 表长 +1
    ++length;
&#125;
</code></pre>
<hr>
<ul>
<li><code>删除</code>运算</li>
</ul>
<blockquote>
<p>删除在顺序表下标为position的元素。</p>
</blockquote>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<p>平均移动元素次数<code>(期望值)</code>：<code>(n-1)/2</code>，其中n为顺序表的元素个数。</p>
<pre><code class="C++">template &lt;class T&gt;
void seqList&lt;T&gt;::remove(int position)
&#123;
    if (position &lt; 0 || position &gt; length - 1)
        //* 判断是否越界
        throw outOfRange();

    for (int j = position; j &lt; length - 1; j++)
        //* 前移在删除位置position之后的所有元素
        //* 注意此处移动的第一个元素下标为待删除元素的下标
        data[j] = data[j + 1];

    //* 表长 -1
    --length;
&#125;;
</code></pre>
<hr>
<ul>
<li><code>逆置</code>顺序表</li>
</ul>
<blockquote>
<p>调整线性表的顺序，可用于倒序输出顺序表元素。</p>
</blockquote>
<p>如：原顺序表为5，4，3，2，1，逆置后顺序表为1，2，3，4，5</p>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<p>平均移动元素次数<code>(期望值)</code>：<code>n/2</code>，其中n为顺序表的元素个数。</p>
<pre><code class="C++">template &lt;class T&gt;
void seqList&lt;T&gt;::inverse()
&#123;
    T temp;
    for (int i = 0; i &lt; length / 2; i++) //* 控制交换次数
    &#123;
        temp = data[i];
        data[i] = data[length - i - 1];
        data[length - i - 1] = temp;
    &#125;
&#125;
</code></pre>
<hr>
<ul>
<li><code>扩大</code>表空间</li>
</ul>
<blockquote>
<p>算法思想：<br>由于数组空间在内存中<code>必须</code>是<code>连续</code>的，因此，<code>扩大</code>数组<code>空间</code>的操作需要：<code>(1)</code>重新申请一个更大规模的新数组，<code>(2)</code>将原有数组的内容复制到新数组中，<code>(3)</code><br>释放原有数组空间，<code>(4)</code>将新数组作为线性表的存储区。</p>
</blockquote>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<pre><code class="C++">template &lt;class T&gt;
void seqList&lt;T&gt;::resize()
&#123;
    T *p = data;           //* 指针p指向原顺序表空间
    maxSize *= 2;          //* 扩大2倍表空间
    data = new T[maxSize]; //* 将旧的数据指向新的表空间

    for (int i = 0; i &lt; length; ++i) //* 复制元素至扩大后的新表
        data[i] = p[i];

    delete[] p;
&#125;
</code></pre>
<hr>
<h3 id="线性表的【链式】表示"><a href="#线性表的【链式】表示" class="headerlink" title="线性表的【链式】表示"></a>线性表的【链式】表示</h3><blockquote>
<p><code>链式存储线性表</code>时，不需要使用地址连续的存储单元，即<code>不需要逻辑上相邻的元素在物理位置上也相邻</code>，它通过“链”建立起数据元素之间的逻辑关系，因此<code>插入和删除操作不需要移动元素</code><br>，则<code>只需要修改指针</code>，但<code>会失去</code>顺序表<code>随机存储</code>的特点。</p>
</blockquote>
<pre><code class="C++">template &lt;class T&gt;
class linkList : public List&lt;T&gt;
&#123;
private:
    struct Node
    &#123;
        T data;     //* 结点数据域
        Node *next; //* 结点指针域
        Node(const T value, Node *p = NULL)
        &#123;
            data = value;
            next = p;
        &#125;

        Node(Node *p = NULL)
        &#123;
            next = p;
        &#125;
    &#125;;

    Node *head; //* 单链表头指针
    Node *tail; //* 单链表尾指针
    int length; //* 单链表表长

    Node *getPosition(int position) const; //* 返回指向position元素的指针

    void traverseRecursive(Node *p);
    void traverseNonRecursive1();
    void traverseNonRecursive2();
    void traverseNonRecursive3();

public:
    linkList();  //* 构造函数
    ~linkList(); //* 析构函数

    void clear();                                     //* 清空单链表，使其成为空表
    bool empty() const &#123; return head-&gt;next == NULL; &#125; //* 判空
    int size() const &#123; return length; &#125;               //* 返回单链表的当前实际长度
    void insert(int position, const T &amp;value);        //* 在位置position上插入一个新元素，表长+1
    void remove(int position);                        //* 删除位于position的元素
    int search(const T &amp;value) const;                 //* 查找值为value的元素在单链表中第一次出现的位置
    T visit(int position) const;                      //* 访问在position位置上的单链表的值

    void traverse() const;           //* 遍历单链表
    void inverse();                  //* 逆置单链表
    void headCreate();               //* 头插法创建单链表
    void tailCreate();               //* 尾插法创建单链表
    int prior(const T &amp;value) const; //* 查找值为value的元素的前驱结点
    linkList *Union(linkList&lt;T&gt; *list);

    void outPut();
&#125;;
</code></pre>
<hr>
<h3 id="单链表的运算"><a href="#单链表的运算" class="headerlink" title="单链表的运算"></a><code>单链表</code>的运算</h3><ul>
<li>构造函数</li>
</ul>
<pre><code class="C++">//** 时间复杂度：O(1)
template &lt;class T&gt;
linkList&lt;T&gt;::linkList()
&#123;
    head = tail = new Node();
    length = 0;
&#125;
</code></pre>
<hr>
<ul>
<li>析构函数</li>
</ul>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<pre><code class="C++">
template &lt;class T&gt;
linkList&lt;T&gt;::~linkList()
&#123;
    clear();
    delete head;
&#125;
</code></pre>
<hr>
<ul>
<li><code>清空</code>单链表</li>
</ul>
<blockquote>
<p>清空链表中所有元素。</p>
</blockquote>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<pre><code class="C++">template &lt;class T&gt;
void linkList&lt;T&gt;::clear()
&#123;
    Node *p, *temp;   //* p为工作指针，指向首元结点
    p = head-&gt;next;   //* 防止意外修改头指针
    while (p != NULL) //* 等效于：while(p)&#123;&#125;
    &#123;
        temp = p;
        p = p-&gt;next; //* 指针后移
        delete temp;
    &#125;

    head-&gt;next = NULL; //* 头结点指针域置空
    tail = head;       //* 头尾指针均指向头结点
    length = 0;
&#125;
</code></pre>
<hr>
<ul>
<li>求表长</li>
</ul>
<blockquote>
<p>算法思想：<br>与<code>遍历单链表</code>类似，均需要从第一个元素开始遍历并记录临时存储的长度，直到最后一个元素结束。</p>
</blockquote>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<pre><code class="C++">
template &lt;class T&gt;
int linkList&lt;T&gt;::size() const
&#123;
    return length; //* 直接返回length
&#125;
*** 若单链表中未设置变量length存储当前表长，则需要遍历整个单链表以计算表长
template &lt;class T&gt;
int linkList&lt;T&gt;::size() const
&#123;
    Node *p = head-&gt;next; //* 从头到尾遍历整个单链表
    int count = 0;
    while (p != NULL)
    &#123;
        count++;
        p = p-&gt;next;
    &#125;

    return count;
&#125;
</code></pre>
<hr>
<ul>
<li><code>遍历</code>单链表</li>
</ul>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<pre><code class="C++">template &lt;class T&gt;
void linkList&lt;T&gt;::traverse() const
&#123;
    Node *p = head-&gt;next;
    cout &lt;&lt; &quot;traverse: &quot;;
    while (p != NULL)
    &#123;
        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;
        p = p-&gt;next;
    &#125;

    cout &lt;&lt; endl;
&#125;
</code></pre>
<hr>
<ul>
<li><code>头插法</code>创建单链表，<code>可用于逆置链表</code></li>
</ul>
<p><code>Example</code>：根据线性表(5,4,3,2,1)创建单链表，则读入数据的顺序应为：1,2,3,4,5，和线性表中的逻辑顺序<code>正好相反</code>。</p>
<blockquote>
<p>元素插入在链表头部，从后往前插入元素。</p>
</blockquote>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<pre><code class="C++">template &lt;class T&gt;
void linkList&lt;T&gt;::headCreate()
&#123;
    Node *p;
    T value, flag;
    cout &lt;&lt; &quot;input Elements, ended with: &quot;;
    cin &gt;&gt; flag; //* 输入结束标志

    while (cin &gt;&gt; value, value != flag)
    &#123;
        p = new Node(value, head-&gt;next);
        head-&gt;next = p;   //* 结点p插入到头结点后面
        if (head == tail) //* 原链表为空，则结点p为尾结点
            tail = p;

        length++;
    &#125;
&#125;
</code></pre>
<hr>
<ul>
<li><code>尾插法</code>创建单链表</li>
</ul>
<p><code>Example</code>：根据线性表(1,2,3,4,5)创建单链表，则读入顺序应为：1,2,3,4,5，读入顺序与单链表的结点<code>顺序相同</code></p>
<blockquote>
<p>元素依次从尾部插入。</p>
</blockquote>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<pre><code class="C++">template &lt;class T&gt;
void linkList&lt;T&gt;::tailCreate()
&#123;
    Node *p;
    T value, flag;
    cout &lt;&lt; &quot;input Elements, ended with: &quot;;
    cin &gt;&gt; flag; //* 输入结束标志

    while (cin &gt;&gt; value, value != flag)
    &#123;
        p = new Node(value, NULL);
        tail-&gt;next = p; //* 给尾指针的指针域赋值新的元素，结点p插入到尾结点的后面
        tail = p;       //* 结点p成为新的尾结点
        length++;
    &#125;
&#125;
</code></pre>
<hr>
<ul>
<li><code>查找</code>位于position位置的元素（<code>按序号</code>查找）</li>
</ul>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<pre><code class="C++">template &lt;class T&gt;
typename linkList&lt;T&gt;::Node *linkList&lt;T&gt;::getPosition(int position) const
&#123;
    Node *p = head; //* 查找指针p初始指向头节点
    int count = 0;

    if (position &lt; -1 || position &gt; length - 1) //* 合法查找位置为(-1..n-1)
        return NULL;                            //* 当要查找的position非法时返回NULL

    while (count &lt;= position)
    &#123;
        p = p-&gt;next;
        count++;
    &#125;

    return p; //* 返回位于position位置的结点的指针
&#125;
</code></pre>
<hr>
<ul>
<li><code>查找</code>值为value的元素（<code>按值</code>查找）</li>
</ul>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<pre><code class="C++">template &lt;class T&gt;
int linkList&lt;T&gt;::search(const T &amp;value) const
&#123;
    Node *p = head-&gt;next; //* 从头结点开始扫描链表
    int count = 0;

    //* 当p不为空与p所指向的data域的值不等于value时，继续扫描链表
    //* 结束循环条件：指针p为NULL 或 指针p的数据域不等于期望值value
    while (p != NULL &amp;&amp; p-&gt;data != value)
    &#123;
        p = p-&gt;next;
        count++;
    &#125;

    if (p == NULL) //* 当p为空时(空表)，直接返回非法值
        return -1;
    else
        return count; //* 返回value在链表中的位置
&#125;
</code></pre>
<hr>
<ul>
<li>在单链表的position位置<code>插入</code>值为value的元素，<code>挂链</code></li>
</ul>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<blockquote>
<p>算法思想：<br>s为指向新结点的指针，p为指向position-1位置元素的指针<br>(1) s-&gt;next = p-&gt;next<br>(2) p-&gt;next = s</p>
<blockquote>
<p>上述也可表示为：<br>p指向当前结点，pre表示前一个结点的指针，在<em>p前（</em>pre后）插入元素q<br>(1) q-&gt;next = pre-&gt;next<br>(2) pre-&gt;next = q</p>
</blockquote>
</blockquote>
<pre><code class="C++">template &lt;class T&gt;
void linkList&lt;T&gt;::insert(int position, const T &amp;value)
&#123;
    Node *p, *q;
    if (position &lt; 0 || position &gt; length) //* 合法位置(0..n)
        throw outOfRange();

    p = getPosition(position - 1); //* p为指向position-1位置的指针
    q = new Node(value, p-&gt;next);  //* 生成新结点
    p-&gt;next = q;                   //* q结点插入到p结点的后面
    if (p == tail)                 //* 若在表尾插入
        tail = q;                  //* 则修改表尾指针即可

    length++;
&#125;
</code></pre>
<hr>
<ul>
<li>在单链表中<code>删除</code>位于position位置的元素（按序号删除）</li>
</ul>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<blockquote>
<p>算法思想：<br>p指向当前结点(即待删除结点)，pre表示前一个结点的指针<br>(1) pre-&gt;next = p-&gt;next || 也可写成：pre-&gt;next = pre-&gt;next-&gt;next，其中将pre-&gt;next看成一个结点(即待删除结点)指针<br>(2) delete p</p>
</blockquote>
<pre><code class="C++">template &lt;class T&gt;
void linkList&lt;T&gt;::remove(int position)
&#123;
    Node *pre, *p;
    if (position &lt; 0 || position &gt; length - 1)
        throw outOfRange();

    pre = getPosition(position - 1); //* pre为指向position-1位置，即待删除元素的前一个元素的指针
    p = pre-&gt;next;                   //* p为指向pre指针的下一个结点的指针，即指向待删除结点
    if (p == tail)                   //* 若删除元素位于表尾
    &#123;
        tail = pre;       //* 则直接修改表尾
        pre-&gt;next = NULL; //* 并将待删除元素的前一个元素的指针域指向NULL
        delete p;         //* 释放待删除结点
    &#125;
    else //* 若删除元素位于表间
    &#123;
        pre-&gt;next = p-&gt;next; //* 将待删除结点的next指针交付给前一个结点的指针域
        delete p;            //* 释放待删除结点
    &#125;

    length--;
&#125;
</code></pre>
<hr>
<ul>
<li><code>逆置</code>单链表（<code>头插法</code>实现）</li>
</ul>
<p><code>时间</code>复杂度：<code>O(n)</code></p>
<p><code>空间</code>复杂度：<code>O(1)</code></p>
<blockquote>
<p>算法思想：</p>
<ol>
<li>断开链接，构造空链表</li>
<li><code>将原链表中元素用头插法重新插入head链表</code></li>
</ol>
</blockquote>
<pre><code class="C++">template &lt;class T&gt;
void linkList&lt;T&gt;::inverse()
&#123;
    Node *p, *temp;    //* p用于遍历单链表，temp用于保存后继结点
    p = head-&gt;next;    //* 指向首元结点
    head-&gt;next = NULL; //* 头结点指针域置空，构成空链表
    if (p)
        tail = p; //* 更新尾结点

    while (p)
    &#123;
        temp = p-&gt;next;       //* 暂存p的后继
        p-&gt;next = head-&gt;next; //* 修改首元结点
        head-&gt;next = p;       //* 修改头结点
        p = temp;             //* 处理下一结点
    &#125;
&#125;
</code></pre>
<hr>
<ul>
<li><code>查找</code>值为value的<code>前驱</code>（按值查找）</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
int linkList&lt;T&gt;::prior(const T &amp;value) const
&#123;
    Node *p = head-&gt;next;
    Node *pre = NULL;
    int count = -1;
    while (p &amp;&amp; p-&gt;data != value)
    &#123;
        pre = p;
        p = p-&gt;next;
        count++;
    &#125;

    if (p == NULL)
        return -1;
    else
        return count;
&#125;
</code></pre>
<!-- ---

### 双链表

`单链表`中只有一个指向后继的指针，使得单链表只能从头结点依次顺序地向后遍历。`要访问某个结点的前驱结点（插入、删除操作时），只能从头开始遍历`，访问后继结点的时间复杂度为：O(1)，访问前驱结点的时间复杂度为：O(n)。

为了克服单链表的上述缺点，引入了双链表，`双链表结点中有两个指针prior和next，分别指向其前驱和后继结点`。

```C
// 定义双链表结点类型
typedef struct DNode{
    ElemType data;              // 数据域
    struct DNode *prior,*next;  // 前驱和后继指针
}DNode, *DLinkList
```

---

### 双链表的运算

+ 插入

原：(p)->(c)

后：(p)->(s)->(c)

> 算法思想：
> 1. 先将待插入结点挂链
> 2. 解除插入元素前驱与后继关联（断链），并将其指向新结点。

```C
// 将结点 *s 插入到 结点 *p 之后
s->next = p->next;
p->next->prior = s;
s->prior = p;
p->next =s;
```

---

+ 删除

原：(p)->(q)->(c)

后：(p)->(c)

> 算法思想：
> 1. 将待删除结点q的后继指针赋值给前驱结点p中的后继指针
> 2. 修改待删除结点的后继结点c中的前驱指针，使其指向前一结点p

```C
p->next = q->next;
q->next->prior = p;
free(q);
``` -->

<hr>
<h3 id="顺序表、链表的比较"><a href="#顺序表、链表的比较" class="headerlink" title="顺序表、链表的比较"></a>顺序表、链表的比较</h3><table>
<thead>
<tr>
<th align="center"><strong>数据结构</strong></th>
<th><strong>存取（读写）方式</strong></th>
<th><strong>逻辑结构与物理结构</strong></th>
<th><strong>查找、插入和删除操作</strong></th>
<th><strong>空间分配</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">顺序存储</td>
<td>顺序存取、随机存取（O(1)）</td>
<td>逻辑相邻，物理相邻</td>
<td>按值查找：无序（O(n)），有序（折半查找，O(log2n)）；按序查找：随机访问，O(1)</td>
<td>预分配空间，易出现空间浪费与溢出</td>
</tr>
<tr>
<td align="center">链式存储</td>
<td>从头顺序存取（O(n)）</td>
<td>逻辑相邻，物理不一定相邻</td>
<td>按值查找：O(n)；按序查找：O(n)</td>
<td>动态分配，但插入删除需要移动大量元素，操作效率低</td>
</tr>
</tbody></table>
<hr>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><table>
<thead>
<tr>
<th align="center"><strong>数据结构</strong></th>
<th><strong>基于存储考虑</strong></th>
<th><strong>基于运算考虑</strong></th>
<th><strong>基于环境考虑</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">顺序存储</td>
<td>未知存储规模时，不宜采用顺序表</td>
<td>按序号访问时优于链式存储结构，时间复杂度：O(1)；但在插入与删除操作时劣于链式存储，需要移动大量元素，且平均移动一半元素</td>
<td>实现较为简单，任何高级语言中都有数组类型，适合稳定存储的线性表</td>
</tr>
<tr>
<td align="center">链式存储</td>
<td>动态分配存储空间，但存储密度低</td>
<td>按序号访问时，时间复杂度：O(n)；插入删除时优于顺序存储，虽要先查找位置，但总体优于顺序存储</td>
<td>基于指针，适合动态性较强（插入删除操作频繁）的线性表</td>
</tr>
</tbody></table>
<hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="基本定义-1"><a href="#基本定义-1" class="headerlink" title="基本定义"></a>基本定义</h3><blockquote>
<p>栈 (Stack) 是只允许在一端进行插入或删除操作的<code>线性表</code>。</p>
<p>首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。</p>
<p>栈的规律类似手枪的弹夹，羽毛球桶。</p>
</blockquote>
<p>栈顶：指线性表允许进行插入删除的一端</p>
<p>栈底：固定的，不允许进行插入删除的另一端</p>
<p>栈规则：<code>后进先出</code></p>
<hr>
<h3 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的<code>抽象数据类型</code></h3><pre><code class="C++">template &lt;class T&gt;
class Stack
&#123;
public:
    virtual bool empty() const = 0;        //* 判栈空
    virtual int size() const = 0;          //* 返回栈大小
    virtual void push(const T &amp;value) = 0; //* 进栈
    virtual T pop() = 0;                   //* 出栈
    virtual T getTop() const = 0;          //* 返回栈顶元素
    virtual void clear() = 0;              //* 清空栈
    virtual ~Stack()&#123;&#125;;
&#125;;
</code></pre>
<hr>
<h3 id="自定义的异常处理类-1"><a href="#自定义的异常处理类-1" class="headerlink" title="自定义的异常处理类"></a>自定义的异常处理类</h3><pre><code class="C++">
class outOfRange : public exception
&#123;
public:
    const char *what() const throw()
    &#123;
        return &quot;OUT of RANGE&quot;;
    &#125;
&#125;;

class errorSize : public exception
&#123;
public:
    const char *what() const throw()
    &#123;
        return &quot;ERROR size&quot;;
    &#125;
&#125;;
</code></pre>
<hr>
<h3 id="栈的【顺序】表示"><a href="#栈的【顺序】表示" class="headerlink" title="栈的【顺序】表示"></a>栈的【顺序】表示</h3><blockquote>
<p>采用顺序存储的栈称为顺序栈，利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设 top 指针指向当前栈顶元素位置。</p>
</blockquote>
<pre><code class="C++">template &lt;class T&gt;
class seqStack : public Stack&lt;T&gt;
&#123;
private:
    T *data;       //* 顺序栈中元素的数组
    int top;       //* 顺序栈顶指针，指向栈顶元素
    int maxSize;   //* 顺序栈的大小
    void resize(); //* 扩顺序栈空间

public:
    //* 构造函数
    seqStack(int initSize = 100)
    &#123;
        if (initSize &lt;= 0)
            throw errorSize();

        data = new T[initSize]; //* 数组
        maxSize = initSize;     //* 当top == maxSize - 1，则表示栈满
        top = -1;               //* 初始时top = -1，表示栈空
    &#125;

    ~seqStack() &#123; delete[] data; &#125;;          //* 析构函数
    bool empty() const &#123; return top == -1; &#125; //* 判栈空
    int size() const &#123; return top + 1; &#125;     //* 返回顺序栈大小
    void clear()                             //* 清空顺序栈
    &#123;
        //* 直接将top指针初始化即可清空栈
        top = -1;
    &#125;;
    void push(const T &amp;value); //* 顺序栈进栈
    T pop();                   //* 顺序栈出栈
    T getTop() const;          //* 获取顺序栈栈顶元素
&#125;;
</code></pre>
<hr>
<h3 id="顺序栈的运算"><a href="#顺序栈的运算" class="headerlink" title="顺序栈的运算"></a>顺序栈的运算</h3><ul>
<li>入栈，进栈</li>
</ul>
<blockquote>
<p>从栈顶依次将元素按后进先出的规则填充入栈。<br>需<code>注意</code>：入栈时，栈顶指针先 +1，后元素入栈。</p>
</blockquote>
<p><code>时间</code>复杂度：栈<code>满</code>时：O(n)，栈<code>未满</code>时：O(1)</p>
<pre><code class="C++">template &lt;class T&gt;
void seqStack&lt;T&gt;::push(const T &amp;value)
&#123;
    //* 当top == maxSize - 1，表示栈满
    if (top == maxSize - 1)
        resize(); //* 若栈满仍插入，则会导致上溢

    // ++top;
    // data[top] = value;
    //* --- 等效于下方代码 ---
    data[++top] = value; //* 修改栈顶指针，元素进栈，先+1后写入
&#125;
</code></pre>
<hr>
<ul>
<li>出栈，弹栈</li>
</ul>
<blockquote>
<p>将栈顶元素按后进先出的规则依次弹出。<br>需<code>注意</code>：出栈时，元素先出栈，后栈顶元素 -1。</p>
</blockquote>
<p><code>时间</code>复杂度：O(1)</p>
<pre><code class="C++">template &lt;class T&gt;
T seqStack&lt;T&gt;::pop()
&#123;
    if (empty()) //* 空栈无法出栈，即下溢
        throw outOfRange();

    // --top;
    // return data[top]
    //* --- 等效于下方代码 ---
    return data[top--]; //* 修改栈顶指针，元素出栈，先出栈后-1
&#125;
</code></pre>
<hr>
<ul>
<li>取栈顶元素</li>
</ul>
<blockquote>
<p>输出栈顶元素的值。</p>
</blockquote>
<p><code>时间</code>复杂度：O(1)</p>
<pre><code class="C++">template &lt;class T&gt;
T seqStack&lt;T&gt;::getTop() const
&#123;
    if (empty())
        throw outOfRange();

    return data[top]; //* 直接返回栈顶元素
&#125;
</code></pre>
<hr>
<ul>
<li>扩大栈空间</li>
</ul>
<blockquote>
<p>算法思想：</p>
<ol>
<li>遍历旧栈元素并临时存储。</li>
<li>申请新栈（容量大于旧栈，如申请两倍、三倍空间）。</li>
<li>将临时存放的旧栈元素依次重新填充进入新栈。</li>
<li>释放旧栈空间。</li>
</ol>
</blockquote>
<p><code>时间</code>复杂度：O(n)</p>
<pre><code class="C++">template &lt;class T&gt;
void seqStack&lt;T&gt;::resize()
&#123;
    T *temp = data;                  //* 将旧栈区数据临时存储
    data = new T[2 * maxSize];        //* 扩大栈区大小
    for (int i = 0; i &lt; maxSize; ++i) //* 将旧栈区的数据赋值到新栈区
        data[i] = temp[i];

    maxSize *= 2;
    delete[] temp; //* 释放旧栈区
&#125;
</code></pre>
<hr>
<h3 id="栈的【链式】表示"><a href="#栈的【链式】表示" class="headerlink" title="栈的【链式】表示"></a>栈的【链式】表示</h3><blockquote>
<p>链栈的优点是便于<code>多个栈共享存储空间和使用效率</code>，且<code>不存在栈满上溢的现象</code>。<br>链栈通常采用<code>单链表</code>表示，并规定<code>所有操作均在单链表表头进行</code>。</p>
</blockquote>
<pre><code class="C++">template &lt;class T&gt;
class linkStack : public Stack&lt;T&gt;
&#123;
private:
    struct Node
    &#123;
        T data;
        Node *next;
        Node() &#123; next = NULL; &#125;
        Node(const T &amp;value, Node *p = NULL)
        &#123;
            data = value;
            next = p;
        &#125;
    &#125;;
    Node *top;

public:
    linkStack() &#123; top = NULL; &#125;;               //* 初始化空栈
    ~linkStack() &#123; clear(); &#125;;                 //* 析构函数
    void clear();                              //* 清空栈
    bool empty() const &#123; return top == NULL; &#125; //* 判栈空，时间复杂度：O(n)
    int size() const;                          //* 返回链栈长度
    void push(const T &amp;value);                 //* 进栈
    T pop();                                   //* 出栈
    T getTop() const;                          //* 返回栈顶元素
&#125;;
</code></pre>
<hr>
<h3 id="链栈的运算"><a href="#链栈的运算" class="headerlink" title="链栈的运算"></a>链栈的运算</h3><ul>
<li>栈长度</li>
</ul>
<p><code>时间</code>复杂度：O(n)</p>
<pre><code class="C++">template &lt;class T&gt;
int linkStack&lt;T&gt;::size() const
&#123;
    Node *p = top;
    int count = 0;
    while (p) //* 遍历栈，统计元素个数
    &#123;
        count++;
        p = p-&gt;next;
    &#125;

    return count;
&#125;
</code></pre>
<hr>
<ul>
<li>入栈，进栈</li>
</ul>
<p><code>时间</code>复杂度：O(1)</p>
<pre><code class="C++">template &lt;class T&gt;
void linkStack&lt;T&gt;::push(const T &amp;value)
&#123;
    Node *p = new Node(value, top); //* 在栈顶插入元素
    top = p;                        //* 更新栈顶指针
&#125;
</code></pre>
<hr>
<ul>
<li>出栈，弹栈</li>
</ul>
<p><code>时间</code>复杂度：O(1)</p>
<pre><code class="C++">template &lt;class T&gt;
T linkStack&lt;T&gt;::pop()
&#123;
    if (empty())
        throw outOfRange();

    Node *p = top;
    T value = p-&gt;data; //* 保留栈顶元素的值
    top = top-&gt;next;   //* 更新栈顶指针至下一个栈顶元素
    delete p;          //* 释放出栈的栈顶元素
    return value;      //* 返回出栈元素值
&#125;
</code></pre>
<hr>
<ul>
<li>取栈顶元素</li>
</ul>
<p><code>时间</code>复杂度：O(1)</p>
<pre><code class="C++">template &lt;class T&gt;
T linkStack&lt;T&gt;::getTop() const
&#123;
    if (empty())
        throw outOfRange();

    return top-&gt;data; //* 返回栈顶元素值
&#125;
</code></pre>
<hr>
<ul>
<li>清空栈</li>
</ul>
<p>时间复杂度：O(n)</p>
<pre><code class="C++">template &lt;class T&gt;
void linkStack&lt;T&gt;::clear()
&#123;
    Node *p;
    while (top != NULL)
    &#123;
        p = top;         //* p指向当前栈顶元素
        top = top-&gt;next; //*top指针依次指向写一个栈顶元素
        delete p;        //* 释放p指向的当前元素
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基本定义-2"><a href="#基本定义-2" class="headerlink" title="基本定义"></a>基本定义</h3><blockquote>
<p>队列（Queue），是一种<code>操作受限</code>的线性表，<code>只允许在表的一端进行插入，在表的另一端进行删除</code>。</p>
<p>向队列中<code>插入</code>元素的操作成为入队或进队。</p>
<p><code>删除</code>元素称为出队或离队。</p>
<p>参考现实中排队的例子不难总结队列的规律：<code>先进先出</code></p>
</blockquote>
<hr>
<h3 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h3><pre><code class="C++">template &lt;class T&gt;
class Queue
&#123;
public:
    virtual bool empty() const = 0;           //* 判队空
    virtual int size() const = 0;             //* 求队长
    virtual void clear() = 0;                 //* 清空队列
    virtual void enQueue(const T &amp;value) = 0; //* 入队
    virtual T deQueue() = 0;                  //* 出队
    virtual T getHead() const = 0;            //* 获取队头元素
    virtual ~Queue();                         //* 析构函数
&#125;;
</code></pre>
<hr>
<h3 id="自定义的异常处理类-2"><a href="#自定义的异常处理类-2" class="headerlink" title="自定义的异常处理类"></a>自定义的异常处理类</h3><pre><code class="C++">class outOfRange : public exception
&#123;
public:
    const char *what() const throw()
    &#123;
        return &quot;ERROR, out of range&quot;;
    &#125;
&#125;;

class errorSize : public exception
&#123;
public:
    const char *what() const throw()
    &#123;
        return &quot;ERROR, error size&quot;;
    &#125;
&#125;;
</code></pre>
<hr>
<h3 id="队列的【顺序】表示"><a href="#队列的【顺序】表示" class="headerlink" title="队列的【顺序】表示"></a>队列的【顺序】表示</h3><blockquote>
<p>队列的顺序实现是指分配一块<code>连续的存储单元</code>存放队列中的元素，并附设两个指针：</p>
<p><code>队头指针</code> front 指向队头元素</p>
<p><code>队尾指针</code> rear 指向队尾元素的下一个位置</p>
</blockquote>
<pre><code class="C++">template &lt;class T&gt;
class seqQueue : public Queue&lt;T&gt;
&#123;
private:
    T *data;       //* 存放数据的数组
    int maxSize;   //* 队列大小
    int front;     //* 队首指针
    int rear;      //* 队尾指针
    void resize(); //* 扩大队列容量

public:
    seqQueue(int size = 100);
    ~seqQueue() &#123; delete[] data; &#125;
    void clear() &#123; front = rear = 1; &#125;
    bool empty() const &#123; return front == rear; &#125;
    bool full() const &#123; (rear + 1) % maxSize == front; &#125;
    int size() const &#123; return (rear - front + maxSize) % maxSize; &#125;
    void enQueue(const T &amp;value);
    T deQueue();
    T getHead() const;
&#125;;
</code></pre>
<hr>
<h3 id="顺序队列的运算"><a href="#顺序队列的运算" class="headerlink" title="顺序队列的运算"></a>顺序队列的运算</h3><ul>
<li>初始化</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
seqQueue&lt;T&gt;::seqQueue(int initSize)
&#123;
    if (initSize &lt;= 0)
        throw errorSize();

    data = new T[initSize];
    maxSize = initSize;
    front = rear = -1;
&#125;
</code></pre>
<hr>
<ul>
<li>进队，入队</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
void seqQueue&lt;T&gt;::enQueue(const T &amp;value)
&#123;
    if ((rear + 1) % maxSize == front)
        resize();

    rear = (rear + 1) % maxSize;
    data[rear] = value;
&#125;
</code></pre>
<hr>
<ul>
<li>出队，离队</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
T seqQueue&lt;T&gt;::deQueue()
&#123;
    if (empty())
        throw outOfRange();

    front = (front + 1) % maxSize;
    return data[front];
&#125;
</code></pre>
<hr>
<ul>
<li>取队头元素</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
T seqQueue&lt;T&gt;::getHead() const
&#123;
    if (empty())
        throw outOfRange();

    return data[(front + 1) % maxSize];
&#125;
</code></pre>
<hr>
<ul>
<li>扩大队列容量</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
void seqQueue&lt;T&gt;::resize()
&#123;
    T *p = data;
    data = new T[2 * maxSize];
    for (int i = 1; i &lt; maxSize; ++i)
        data[i] = p[(front + i) % maxSize];

    front = 0;
    rear = maxSize - 1;
    maxSize *= 2;
    delete p;
&#125;
</code></pre>
<hr>
<h3 id="队列的【链式】表示"><a href="#队列的【链式】表示" class="headerlink" title="队列的【链式】表示"></a>队列的【链式】表示</h3><blockquote>
<p>队列的链式表示成为链队列，它实际上是一个<code>同时带有队头指针和队尾指针的单链表</code>。</p>
<p><code>头指针</code>指向<code>对头</code>结点</p>
<p><code>尾指针</code>指向<code>队尾</code>结点</p>
</blockquote>
<pre><code class="C++">template &lt;class T&gt;
class linkQueue : public Queue&lt;T&gt;
&#123;
private:
    struct Node
    &#123;
        T data;
        Node *next;
        Node(const T &amp;value, Node *n = NULL)
        &#123;
            data = value;
            next = n;
        &#125;

        Node() : next(NULL) &#123;&#125;
        ~Node();
    &#125;;

    Node *front, *rear;

public:
    linkQueue() &#123; front = rear = NULL; &#125;
    ~linkQueue();
    void clear();
    bool empty() const &#123; return front == NULL; &#125;;
    int size() const;
    void enQueue(const T &amp;value);
    T deQueue();
    T getHead() const;
&#125;;
</code></pre>
<hr>
<h3 id="链队列的运算"><a href="#链队列的运算" class="headerlink" title="链队列的运算"></a>链队列的运算</h3><ul>
<li>析构</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
linkQueue&lt;T&gt;::~linkQueue&lt;T&gt;()
&#123;
    Node *p;
    while (front != NULL)
    &#123;
        p = front;
        front = front-&gt;next;
        delete p;
    &#125;
&#125;
</code></pre>
<hr>
<ul>
<li>清空链队列</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
void linkQueue&lt;T&gt;::clear()
&#123;
    Node *p;
    while (front != NULL)
    &#123;
        p = front;
        front = front-&gt;next;
        delete p;
    &#125;

    rear = NULL;
&#125;
</code></pre>
<hr>
<ul>
<li>求队长</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
int linkQueue&lt;T&gt;::size() const
&#123;
    Node *p = front;
    int count = 0;
    while (p)
    &#123;
        count++;
        p = p-&gt;next;
    &#125;

    return count;
&#125;
</code></pre>
<hr>
<ul>
<li>入队，进队</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
void linkQueue&lt;T&gt;::enQueue(const T &amp;value)
&#123;
    if (rear == NULL)
    &#123;
        front = rear = new Node(value);
    &#125;
    else
    &#123;
        rear-&gt;next = new Node(value);
        rear = rear-&gt;next;
    &#125;
&#125;
</code></pre>
<hr>
<ul>
<li>出队</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
T linkQueue&lt;T&gt;::deQueue()
&#123;
    if (empty())
        throw outOfRange();

    Node *p = front;
    T value = front-&gt;data;
    front = front-&gt;next;
    
    if (front == NULL)
        rear = NULL;

    delete p;
    return value;
&#125;
</code></pre>
<hr>
<ul>
<li>输出队头元素</li>
</ul>
<pre><code class="C++">template &lt;class T&gt;
T linkQueue&lt;T&gt;::getHead() const
&#123;
    if (empty())
        throw outOfRange();

    return front-&gt;data;
&#125;
</code></pre>
<hr>
<h2 id="有关树、图、查找与排序算法请直接参阅-Github-源码"><a href="#有关树、图、查找与排序算法请直接参阅-Github-源码" class="headerlink" title="有关树、图、查找与排序算法请直接参阅 Github 源码"></a>有关树、图、查找与排序算法请直接参阅 Github 源码</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/PhoenixNest/Hello-C">C • Github</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/PhoenixNest/Hello-C-Plus-Plus">C++ • Github</a></p>
</li>
</ul>

            <!--[if lt IE 9]>
            <script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                   data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://cdn.jsdelivr.net/gh/PhoenixNest/Blog-Repository@master/Music/StarCraft%20Terran%20Band%20-%20Blood%20and%20Glory.mp3'></li>
                        
                    
                </ul>
            
            
            
            
                <hr>
                <div id="vcomments"></div>
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="/img/favicon.png" height=300 width=300 />
                    <p>PhoenixNest</p>
                    <span>用实力让情怀落地</span>
                    
                </div>
                <ul>
                    <li><a href="/">32 <p>文章</p></a></li>
                    <li><a href="/categories">18 <p>分类</p></a></li>
                    <li><a href="/tags">25 <p>标签</p></a></li>
                </ul>
            </div>
            
                
                
                    <div class="box sticky animated fadeInRight faster">
                        <div id="toc" class="subbox">
                            <h4>目录</h4>
                            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.</span> <span class="toc-text">数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.</span> <span class="toc-text">数据元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B9"><span class="toc-number">2.3.</span> <span class="toc-text">数据项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.</span> <span class="toc-text">数据对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.</span> <span class="toc-text">数据的逻辑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">2.6.</span> <span class="toc-text">数据的存储结构(物理结构)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">2.7.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A6%81%E6%B1%82"><span class="toc-number">2.8.</span> <span class="toc-text">算法的设计要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E8%A1%A1%E9%87%8F%E6%96%B9%E6%B3%95"><span class="toc-number">2.9.</span> <span class="toc-text">算法效率的衡量方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.10.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.11.</span> <span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.12.</span> <span class="toc-text">抽象数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">基本定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">线性表的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">自定义的异常处理类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E3%80%90%E9%A1%BA%E5%BA%8F%E3%80%91%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.4.</span> <span class="toc-text">线性表的【顺序】表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">3.5.</span> <span class="toc-text">顺序表的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E3%80%90%E9%93%BE%E5%BC%8F%E3%80%91%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.6.</span> <span class="toc-text">线性表的【链式】表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">3.7.</span> <span class="toc-text">单链表的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.8.</span> <span class="toc-text">顺序表、链表的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">3.9.</span> <span class="toc-text">实际应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">4.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89-1"><span class="toc-number">4.1.</span> <span class="toc-text">基本定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">栈的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB-1"><span class="toc-number">4.3.</span> <span class="toc-text">自定义的异常处理类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E3%80%90%E9%A1%BA%E5%BA%8F%E3%80%91%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.4.</span> <span class="toc-text">栈的【顺序】表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">4.5.</span> <span class="toc-text">顺序栈的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E3%80%90%E9%93%BE%E5%BC%8F%E3%80%91%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.6.</span> <span class="toc-text">栈的【链式】表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">4.7.</span> <span class="toc-text">链栈的运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89-2"><span class="toc-number">5.1.</span> <span class="toc-text">基本定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">队列的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB-2"><span class="toc-number">5.3.</span> <span class="toc-text">自定义的异常处理类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E3%80%90%E9%A1%BA%E5%BA%8F%E3%80%91%E8%A1%A8%E7%A4%BA"><span class="toc-number">5.4.</span> <span class="toc-text">队列的【顺序】表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">5.5.</span> <span class="toc-text">顺序队列的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E3%80%90%E9%93%BE%E5%BC%8F%E3%80%91%E8%A1%A8%E7%A4%BA"><span class="toc-number">5.6.</span> <span class="toc-text">队列的【链式】表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">5.7.</span> <span class="toc-text">链队列的运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E6%A0%91%E3%80%81%E5%9B%BE%E3%80%81%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%B7%E7%9B%B4%E6%8E%A5%E5%8F%82%E9%98%85-Github-%E6%BA%90%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">有关树、图、查找与排序算法请直接参阅 Github 源码</span></a></li></ol>
                        </div>
                    </div>
                
            
        </div>
    </div>
</div>

    </div>
</div>
<div id="back-to-top" class="animated fadeIn faster">
    <div class="flow"></div>
    <span class="percentage animated fadeIn faster">0%</span>
    <span class="iconfont icon-top02 animated fadeIn faster"></span>
</div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2022
        <span class="gradient-text">
            PhoenixNest
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
    </p>
</footer>

    <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script>
        MathJax.Hub.Config({
            "HTML-CSS": {
                preferredFont: "TeX",
                availableFonts: ["STIX", "TeX"],
                linebreaks: {
                    automatic: true
                },
                EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
            },
            tex2jax: {
                inlineMath: [
                    ["$", "$"],
                    ["\\(", "\\)"]
                ],
                processEscapes: true,
                ignoreClass: "tex2jax_ignore|dno",
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            },
            TeX: {
                noUndefined: {
                    attributes: {
                        mathcolor: "red",
                        mathbackground: "#FFEEEE",
                        mathsize: "90%"
                    }
                },
                Macros: {
                    href: "{}"
                }
            },
            messageStyle: "none"
        });
    </script>
    <script>
        function initialMathJax() {
            MathJax.Hub.Queue(function () {
                var all = MathJax.Hub.getAllJax(),
                    i;
                // console.log(all);
                for (i = 0; i < all.length; i += 1) {
                    console.log(all[i].SourceElement().parentNode)
                    all[i].SourceElement().parentNode.className += ' has-jax';
                }
            });
        }

        function reprocessMathJax() {
            if (typeof MathJax !== 'undefined') {
                MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
            }
        }
    </script>




<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>


<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>


<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>


<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>

  
<script src="/js/busuanzi.min.js"></script>

<script>
    $(document).ready(function () {
        if ($('span[id^="busuanzi_"]').length) {
            initialBusuanzi();
        }
    });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
  

<script>
    function initialTyped() {
        var typedTextEl = $('.typed-text');
        if (typedTextEl && typedTextEl.length > 0) {
            var typed = new Typed('.typed-text', {
                strings: ['Beyond The World', '用实力让情怀落地'],
                typeSpeed: 90,
                loop: true,
                loopCount: Infinity,
                backSpeed: 20,
            });
        }
    }

    if ($('.article-header') && $('.article-header').length) {
        $(document).ready(function () {
            initialTyped();
        });
    }
</script>

 
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
    var valine = new Valine();

    function initValine(path) {
        if (!path) path = window.location.pathname;
        let language = 'zh-CN';
        if (!language) {
            language = 'en';
        } else {
            language = language.toLowerCase();
        }
        valine.init({
            el: '#vcomments',
            appId: 'HDzkYOSz3NGcQuXbWMLin1mS-gzGzoHsz',
            appKey: 'pJ9JxbsY5D5aEmhxtCSNBlCT',
            notify: '',
            verify: '',
            avatar: '',
            placeholder: '温酒会知音 😉',
            visitor: 'true',
            path: path,
            lang: language,
        });
    }

    $(document).ready(function () {
        initValine();
    });
</script>



 <!-- 例：百度统计 --> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?your_code"; var s = document.getElementsByTagName("script")[0];  s.parentNode.insertBefore(hm, s); })(); </script> 

</html>
