<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Welcome To PhoenixNest&#39;s Blog</title>
      <link href="/Welcome/"/>
      <url>/Welcome/</url>
      
        <content type="html"><![CDATA[<h2 id="Greetings-i-am-Peter-Chen-PhoenixNest"><a href="#Greetings-i-am-Peter-Chen-PhoenixNest" class="headerlink" title="Greetings i am Peter Chen [PhoenixNest]"></a>Greetings i am <code>Peter Chen [PhoenixNest]</code></h2><ul><li>一个正在备考<code>专插本</code>的专科院校<code>应届毕业生</code>。</li><li>一个知晓C++、Java、MySQL、SQL Server等拼写的程序猿（发量犹在，Still a ROOKIE）。</li><li>一个知晓MVVM开发架构，使用过<code>Google JetPack</code>快速开发框架，正在<code>学习Kotlin</code>的Android程序猿。</li><li>一个做过<code>高德地图(Android)</code>开发，正在转入Web前端的新人。</li><li>一个热爱<code>星际争霸2</code>，喜欢暴雪游戏，梦想进入<code>暴雪公司(Blizzard)</code>的SCer。</li><li>一个喜欢游泳，曾做过蛙泳与自由泳教练的泳客。</li><li>一个接触计算机编程开发<code>2年</code>，喜欢学习新技术的<code>前端攻城狮</code>。</li><li>一个做过高达模型评测，开过电台的小Up主。</li><li>一个喜欢拍照，喜欢记录生活，不会讲粤语的<code>广东潮汕人</code>。</li></ul><hr><h2 id="The-Original"><a href="#The-Original" class="headerlink" title="The Original"></a>The Original</h2><p>在接触计算机编程的2年，踩了不少坑，从一开始最经典的因为大小写导致程序出现Bug，再到现如今能独立开发Android移动端应用，<br>可以说很大方面来自于自己对技术的热爱与追求。有人说编程是枯燥的，但其实也充满了乐趣，你能亲眼看着你的项目如同孩子般，经历<br>不同的成长阶段，从一开始的<code>&quot;Hello World&quot;</code>，再到后来的能够完成用户诸多需求，成为程序界里的<code>&quot;搬砖工人&quot;</code>(🤣🤣🤣)。</p><p>用博客中书写自己在日常工作中的一些对于技术的见解与看法，记录自己生活的点滴感动。</p><p><code>以学生的角度看待世界，有书，哪里都是图书馆。</code></p><hr><h2 id="Donate-Me-☕️"><a href="#Donate-Me-☕️" class="headerlink" title="Donate Me ☕️"></a>Donate Me ☕️</h2><p>If you like my blog post, you can Donate to me in the following ways.</p><p>如果你喜欢我的博文，可以通过下面的方式支持我，你的支持是我最大的动力 😘</p><table><thead><tr><th align="center">Donate 😇</th><th align="center">Qr code</th></tr></thead><tbody><tr><td align="center">Wechat</td><td align="center"><img src="/img/wechat.png" alt="Wechat"></td></tr><tr><td align="center">Ali Pay</td><td align="center"><img src="/img/alipay.png" alt="Ali Pay"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 置顶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构复习笔记(1) • 基本概念和术语</title>
      <link href="/DataStructure-Basic/"/>
      <url>/DataStructure-Basic/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Introduction"><a href="#The-Introduction" class="headerlink" title="The Introduction"></a>The Introduction</h2><p>对实际问题进行<code>缜密解析</code>，并辅以<code>优雅的代码</code>进行编写。</p><p>Perform a “meticulous analysis” of the actual problem and supplement it with an “elegant code”.</p><hr><h2 id="Program-Data-Structure-Algorithm"><a href="#Program-Data-Structure-Algorithm" class="headerlink" title="Program = Data Structure + Algorithm"></a>Program = Data Structure + Algorithm</h2><p>“程序 = 数据结构 + 算法”，这句出自Nicklaus Wirth教授的经典名言，使其一举夺得计算机界的诺贝尔奖 - 图灵奖，该公式对于计算机科学的影响几乎等同于Albert Einstein最为著名的质能等价理论：”E = mc²”，通过这短短的一个公式，便展露出程序的本质。</p><p>“Program = data structure + algorithm” is a classic quote from Professor Nicklaus Wirth, which won the Nobel Prize-Turing Prize in the computer industry in one fell swoop. This formula has almost the same impact on computer science as Albert Einstein’s most famous. Mass-energy equivalence theory: “E = mc²”, through this short formula, the essence of the program is revealed.</p><hr><h2 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h2><p>“数据结构(Data Structure)”是计算机程序设计的<code>重要理论基础</code>，是计算机专业最为<code>核心</code>的一门专业课程，同是也是一门<code>考研课程</code>。本篇将介绍我在进行数据结构学习时，所经历的第一个章节：数据结构的基本概念和术语。</p><p>“Data Structure” is an important theoretical basis for computer programming. It is a professional course with the most core of computer majors, and it is also a postgraduate course. This article will introduce the first chapter I experienced when I was studying data structure: the basic concepts and terminology of data structure.</p><hr><h2 id="1-基本概念-Basic-Concept"><a href="#1-基本概念-Basic-Concept" class="headerlink" title="1. 基本概念 Basic Concept"></a>1. 基本概念 Basic Concept</h2><h3 id="1-1-数据-Data"><a href="#1-1-数据-Data" class="headerlink" title="1.1 数据 (Data)"></a><strong>1.1 数据 (Data)</strong></h3><p>数据是<code>信息的载体</code>，是<code>描述客观事物</code>的数字、字符，以及<code>所有能输入计算机中</code>的、<code>被计算机程序识别和处理的符号</code>的集合。包括<code>数值型数据</code>：整数、实数等，与<code>非数值型数据</code>：文字、图像、图形、声音等。</p><p>Data is a carrier of information, a collection of numbers and characters that describe objective things, and all symbols that can be entered into a computer and recognized and processed by computer programs. Including <code>numeric data</code>: integers, real numbers, etc., and <code>non-numeric data</code>: text, images, graphics, sounds, etc.</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Data%20Structure/Basic/Basic_1.png"><h3 id="1-2-数据元素-Data-Element"><a href="#1-2-数据元素-Data-Element" class="headerlink" title="1.2 数据元素 (Data Element)"></a><strong>1.2 数据元素 (Data Element)</strong></h3><p>数据元素是<code>数据中的一个&quot;个体&quot;</code>，是数据的<code>基本单位</code>。在有些情况下，数据元素也被称为<code>元素</code>、<code>结点</code>、<code>顶点</code>、<code>记录</code>等。数据元素<code>用于完整地描述一个对象</code>。如：一个学生记录、一张图片、图的一个顶点等。</p><p>The data element is an “individual” in the data, and it is the basic unit of the data. In some cases, data elements are also called <code>elements</code>, <code>nodes</code>, <code>vertices</code>, <code>records</code>, etc. The data element <code>used to completely describe an object</code>. Such as: a student record, a picture, a vertex of the picture, etc.</p><h3 id="1-3-数据项-Data-Item"><a href="#1-3-数据项-Data-Item" class="headerlink" title="1.3 数据项 (Data Item)"></a><strong>1.3 数据项 (Data Item)</strong></h3><p>数据项是<code>组成数据元素</code>的有特定意义的<code>不可分割的最小单位</code>。如构成一个数据元素的<code>字段</code>、<code>域</code>、<code>属性</code>等都可称之为数据项。数据元素<code>是数据项的集合</code>。</p><p>简而言之，如上述举例中若要<code>组成一个学生记录</code>，那么<code>一个学生</code>可能包含有<code>学号</code>、<code>姓名</code>、<code>性别</code>、<code>班级</code>等属性，这些学号、姓名就是<code>构成一个学生记录的数据项</code>。</p><p>Data items are <code>indivisible smallest units</code> that make up a data element. For example, <code>field</code>, <code>domain</code>, <code>attribute</code> that constitute a data element can be called data items. The data element <code>is a collection of data items</code>.</p><p>In short, if in the above example you want to <code>compose a student record</code>, then <code>a student</code> may contain attributes such as <code>student number</code>, <code>name</code>, <code>sex</code>, <code>class</code> etc. It is <code>a data item that constitutes a student record</code>.</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Data%20Structure/Basic/Basic_2.png"><h3 id="1-4-数据对象-Data-Object"><a href="#1-4-数据对象-Data-Object" class="headerlink" title="1.4 数据对象 (Data Object)"></a><strong>1.4 数据对象 (Data Object)</strong></h3><p>数据对象是具有<code>相同性质</code>的数据元素的<code>集合</code>，是<code>数据的一个子集</code>。</p><p>如：计算机专业的全体学生(其中<code>全体学生</code>为一个<code>集合</code>，<code>计算机专业</code>为每个学生个体的<code>相同性质</code>)。</p><p>A data object is a <code>collection</code> of data elements with <code>same nature</code>, which is a subset of <code>data</code>.</p><p>For example: all students of computer major (where <code>all students</code> is a <code>set</code>, and <code>computer major</code> is <code>same nature</code> of each individual student).</p><hr><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Data%20Structure/Basic/Basic_3.png"><h3 id="1-5-数据的逻辑结构-Logical-structure-of-data"><a href="#1-5-数据的逻辑结构-Logical-structure-of-data" class="headerlink" title="1.5 数据的逻辑结构 (Logical structure of data)"></a><strong>1.5 数据的逻辑结构 (Logical structure of data)</strong></h3><p>数据的<code>逻辑结构</code>讨论的是<code>元素之间的逻辑关系</code>，<code>与存储结构无关</code>，是<code>独立于计算机</code>的。常见的逻辑结构有：</p><p>The <code>logical structure</code> of the data discusses the <code>logical relationship between the elements</code>, <code>is not related to the storage structure</code>, and is <code>independent of the computer</code>. Common logical structures are:</p><ul><li><code>集合结构</code> Collection structure</li><li><code>线性结构</code> Linear structure – (1 : 1)</li><li><code>树结构(层次结构)</code> Tree structure (hierarchy) – (1 : n)</li><li><code>图结构</code> Graph structure – (n : m)</li></ul><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Data%20Structure/Basic/Basic_4.png"><h3 id="1-6-数据的存储结构-物理结构-Data-storage-structure-physical-structure"><a href="#1-6-数据的存储结构-物理结构-Data-storage-structure-physical-structure" class="headerlink" title="1.6 数据的存储结构(物理结构) (Data storage structure (physical structure))"></a><strong>1.6 数据的存储结构(物理结构) (Data storage structure (physical structure))</strong></h3><p>数据的存储结构(物理结构)研究的是数据及其逻辑关系<code>如何在计算机中存储与实现</code>。常见的存储结构有：</p><p>The storage structure (physical structure) of data is to study how data and its logical relationship <code>how to store and realize it in a computer</code>. Common storage structures are:</p><ul><li>顺序存储结构 (Sequential storage structure)</li></ul><p>借助元素在存储器中的<code>相对位置</code>表示数据元素之间的关系，通常用<code>数组</code>来实现。</p><p>Relying on the relative position of elements in the memory to represent the relationship between data elements, it is usually implemented with an array.</p><table><thead><tr><th align="center">数组下标(Array subscript)</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td align="center">数组元素(Array element)</td><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center">D</td></tr></tbody></table><ul><li>链式存储结构 (Chain storage structure)</li></ul><p>借助<code>表示数据元素存储地址的指针</code>显式地指出数据元素之间的逻辑关系。</p><p>Explicitly indicate the logical relationship between data elements with the help of <code>pointers representing the storage addresses of data elements</code>.</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Data%20Structure/Basic/Basic_5.png"><ul><li>散列(哈希)存储方式 (Hash (hash) storage method)</li></ul><p>是<code>专用于集合</code>的数据存储方式。<code>用一个哈希函数</code>将数据元素<code>按关键字</code>和<code>一个唯一的存储位置</code>关联起来。</p><p>It is a data storage method dedicated to collections. <code>Use a hash function to associate data elements</code> by keyword <code>with</code> a unique storage location`.</p><ul><li>索引存储方式 (Index storage)</li></ul><p>数据元素被<code>排成一个序列</code>：d1,d2,d3,…,dn，每个结点di在序列里都有<code>相应的位序i</code>(1 &lt;= i &lt;= n&gt;)，<code>位序</code>可以作为<code>结点的索引</code>存储在索引表中。检索时<code>利用结点的顺序号i来确定结点</code>的存储地址。(类似图书的<code>目录</code>。)</p><p>The data elements are <code>arranged into a sequence</code>: d1, d2, d3, …, dn, each node di has a corresponding bit sequence i <code>in the sequence (1 &lt;= i &lt;= n&gt;),</code> Sequence <code>can be stored in the index table as the</code> node index. When searching, <code>use the sequence number i of the node to determine the storage address of the node</code>. (Similar to the book’s catalogue.)</p><hr><h2 id="2-算法与算法分析-Algorithms-and-algorithm-analysis"><a href="#2-算法与算法分析-Algorithms-and-algorithm-analysis" class="headerlink" title="2. 算法与算法分析 Algorithms and algorithm analysis"></a>2. 算法与算法分析 Algorithms and algorithm analysis</h2><h3 id="2-1-算法-Algorithm"><a href="#2-1-算法-Algorithm" class="headerlink" title="2.1 算法 (Algorithm)"></a><strong>2.1 算法 (Algorithm)</strong></h3><p>算法是<code>指令的有限序列</code>，是对特定问题<code>求解步骤的描述</code>。算法具有下列五种<code>特性</code>：</p><p>An algorithm is a <code>finite sequence of instructions</code>, which is a description of a specific problem` solving step. The algorithm has the following five characteristics:</p><ul><li>(1) 有穷性</li></ul><p>步骤<code>有限</code>，执行时间<code>有限</code>。</p><p>The step <code>Limited</code>, the execution time <code>Limited</code>.</p><ul><li>(2) 确定性</li></ul><p>有<code>确切</code>的含义，<code>无二义性</code>，算法只有<code>唯一</code>的一条执行路径。</p><p>It has the meaning of <code>exact</code>, <code>ambiguity</code>, and the algorithm has only one execution path of <code>unique</code>.</p><ul><li>(3) 可行性</li></ul><p>可以通过<code>已经实现</code>的基本运算<code>执行有限次</code>来实现。</p><p>This can be achieved by <code>implemented basic operations</code> a limited number of times.</p><ul><li>(4) 输入</li></ul><p>算法具有<code>0个</code>或<code>多个</code>输入。</p><p>The algorithm has <code>0</code> or <code>multiple</code> inputs.</p><ul><li>(5) 输出</li></ul><p>算法具有<code>1个</code>或<code>多个</code>输出。(一个算法不能没有输出。)</p><p>The algorithm has <code>1</code> or <code>multiple</code> outputs. (An algorithm cannot have no output.)</p><pre><code class="C++">int sum(int num){    int result = 0;    for (int i = 1; i &lt;= num; i++)        result += i;    return result;}</code></pre><p><code>算法与程序</code>十分类似，但也有<code>区别</code>：</p><p><code>Algorithms</code> are very similar to programs, but there are also <code>diffs</code>:</p><ul><li>在<code>执行时间上</code>(In <code>execution time</code>)：</li></ul><p><code>算法</code>所描述的步骤是<code>一定有限</code>的，但<code>程序</code>可以<code>无限执行</code>下去。如：一个操作系统是在一个无限循环中执行的，而不是一个算法。</p><p>The steps described in <code>Algorithm</code> are <code>certainly limited</code>, but <code>Program</code> can be executed indefinitely. For example, an operating system is executed in an infinite loop, not an algorithm.</p><ul><li>在<code>语言描述上</code>(On <code>language description</code>)：</li></ul><p><code>程序</code>必须采用<code>规定的程序设计语言</code>来实现，而<code>算法没</code>有这种<code>限制</code>。</p><p><code>Program</code> must be implemented using <code>specified programming language</code>, and <code>algorithm does not have such</code> restrictions`.</p><h3 id="2-2-算法的设计要求-Algorithm-design-requirements"><a href="#2-2-算法的设计要求-Algorithm-design-requirements" class="headerlink" title="2.2 算法的设计要求 (Algorithm design requirements)"></a><strong>2.2 算法的<code>设计要求</code> (Algorithm design requirements)</strong></h3><ul><li>正确性(Correctness)</li></ul><p>算法应该能<code>正确</code>地<code>实现预定功能</code>；</p><p>The algorithm should be able to “correctly” achieve the intended function;</p><ul><li>易读性(Readability)</li></ul><p>算法应<code>易于阅读</code>和<code>理解</code>，以<code>便与调试</code>、<code>修改</code>和<code>扩充</code>；</p><p>The algorithm should be <code>easy to read</code> and <code>understand</code> in order to <code>comfort with debugging</code>, <code>modify</code> and <code>expand</code>;</p><ul><li>健壮性(Robustness)</li></ul><p>当<code>环境发生变化</code>(如非法输入)时，能<code>正确作出反应</code>或<code>进行处理</code>，<code>不产生</code>不正确的运算结果；</p><p>When <code>environment changes</code> (such as illegal input), it can <code>correctly respond</code> or <code>process</code>, and <code>do not produce</code> incorrect calculation results;</p><ul><li>高效性(Efficiency)</li></ul><p>算法应<code>有效地使用存储空间</code>并且<code>有较高的时间效率</code>。</p><p>The algorithm should <code>use storage space efficiently</code> and <code>have a high time efficiency</code>.</p><h3 id="2-3-算法效率的衡量方法-Method-of-measuring-algorithm-efficiency"><a href="#2-3-算法效率的衡量方法-Method-of-measuring-algorithm-efficiency" class="headerlink" title="2.3 算法效率的衡量方法 (Method of measuring algorithm efficiency)"></a><strong>2.3 算法效率的衡量方法 (Method of measuring algorithm efficiency)</strong></h3><ul><li>事前分析法 (Ex ante analysis)</li></ul><p>在<code>忽略计算机硬件、软件的因素后</code>，一个特定算法”工作量”的大小，只<code>依赖于问题的规模</code>。</p><p>After ignoring the factors of computer hardware and software, the size of the “workload” of a particular algorithm depends only on the scale of the problem.</p><ul><li>事后统计法(后期估算) (Post-mortem statistics (late estimation))</li></ul><p>通过<code>编写实际操作代码</code>，并将其<code>在计算机上进行运行</code>，通过<code>计算机的时钟</code>进行算法执行时间的统计。但由于时间统计<code>依赖于硬件与软件环境</code>，容易掩盖算法本身的优劣。</p><p>Calculate the execution time of the algorithm by writing the actual operation code and running it on the computer. However, because time statistics depend on the hardware and software environment, it is easy to obscure the pros and cons of the algorithm itself.</p><h3 id="2-4-时间复杂度-Time-Complexity"><a href="#2-4-时间复杂度-Time-Complexity" class="headerlink" title="2.4 时间复杂度 (Time Complexity)"></a><strong>2.4 时间复杂度 (Time Complexity)</strong></h3><p>O(N)是指该<code>算法的时间耗费</code>，是其所求解问题规模N的函数。当问题规模N趋于无穷大时，不考虑具体的运行时间函数，<code>只考虑运行时间函数的数量级(阶)</code>，这称为算法的渐进时间复杂度(Asymptotic Time Complexity)。</p><p>即：<code>忽略</code>低阶部分，只<code>保留</code>高阶部分，并<code>忽略</code>系数。</p><p>O (N) refers to the <code>time consumption of the algorithm</code> and is a function of the scale N of the problem it solves. When the problem size N tends to infinity, the specific runtime function is not considered, and only the magnitude (order) of the runtime function is considered. This is called the Asymptotic Time Complexity of the algorithm.</p><p>That is: <code>Ignore</code> low-order parts, only <code>remain</code> high-order parts, and <code>ignore</code> coefficients.</p><ul><li><strong>常量阶 (Constant order)</strong></li></ul><pre><code class="C++">{   ++x; s = 0; // 选取++x为基本操作，语句频度1，则时间复杂度O(n) = 1，即常量阶。}</code></pre><pre><code class="C++">for (j = 1; j &lt;= 10000; ++j)    {        ++x; // 选取++x为基本操作，语句频度为10000(即：1 * 10000)，但需要忽略系数，则时间复杂度为O(n) = 1，即常量阶。        s += x;    }</code></pre><ul><li><strong>对数阶 (Logarithmic order)</strong></li></ul><pre><code class="C++">s = 0;for (int j = 1; j &lt;= n; j *= 2)    ++x;// 选取++x为基本操作，语句频度为log2n(以2为底的对数阶)，则时间复杂度为O(log2n)，即对数阶。</code></pre><ul><li><strong>线性阶 (Linear order)</strong></li></ul><pre><code class="C++">for (int i = 1; i &lt;= 2 * n; ++i)    {        ++x;// 选取++x为基本操作，则语句频度为2 * n，但需要忽略系数，则时间复杂度为O(n)，即线性阶。        s += x;    }</code></pre><ul><li><strong>平方阶 (Square order)</strong></li></ul><pre><code class="C++">for (j = 1; j &lt;= n; ++j)    {// n + 1        for (k = 1; k &lt;= n / 4; ++k)        {            // n * (n/4 + 1)            ++x;// 选取++x为基本操作，则语句频度为n * n/4，忽略系数1/4，则时间复杂度为O(n^2)，即平方阶。            s += x;        }    }</code></pre><ul><li><strong>线性对数阶 (Linear logarithmic order)</strong></li></ul><pre><code class="C++">for (int j = 1; j &lt;= n; j *= 2)    {// 执行log2n次        for (int k = 1; k &lt;= n; ++k)        {            ++x;// 选取++x为基本操作，则时间复杂度为O(nlog2n)，即线性对数阶。            s += x;        }    }</code></pre><ul><li><strong>立方阶 (Cubic order)</strong></li></ul><pre><code class="C++">for (int i = 1; i &lt;= n; i++)    {// 执行n次        for (int j = 1; j &lt;= n; j++)        {// 执行n^2次            c[i][j] = 0;            for (int k = 1; k &lt;= n; k++)            {// 执行n^3次，语句频度为n * n^2 * n^ 3，但只取最高阶，即时间复杂度为O(n^3)，即立方阶。                c[i][j] = c[i][j] + a[i][k] * b[k][j];            }        }    }</code></pre><h3 id="2-5-空间复杂度-Space-Complexity"><a href="#2-5-空间复杂度-Space-Complexity" class="headerlink" title="2.5 空间复杂度 (Space Complexity)"></a><strong>2.5 空间复杂度 (Space Complexity)</strong></h3><p>如果<code>所需额外空间</code>相对于<code>输入数据量</code>来说只是一个<code>常数</code>，则称此算法为<code>&quot;原地工作&quot;</code>，此时的空间复杂度为O(1)。</p><p>If <code>required extra space</code> is only a <code>constant</code> relative to <code>input data volume</code>, then this algorithm is called <code>&quot;work in place&quot;</code> and the space complexity at this time is O(1).</p><p>例：问题<code>规模</code>为n，</p><p>(1)若使用<code>大小为n</code>的辅助一唯数组，则空间复杂度为：O(n)</p><p>(2)若使用<code>大小为n * n</code>的辅助一唯数组，则空间复杂度为：O(n^2)</p><p>(3)若使用了<code>100个</code>辅助变量，则空间复杂度为：O(1),即”原地工作”</p><p>Example: The problem <code>scale</code> is n,</p><p>(1) If an auxiliary one-only array of size n is used, the space complexity is: O (n)</p><p>(2) If an auxiliary one-only array whose size is n * n is used, the space complexity is: O (n ^ 2)</p><p>(3) If <code>100</code> auxiliary variables are used, the space complexity is: O (1), which means” work in place “</p><hr><h2 id="3-抽象数据类型-Abstract-Data-Type"><a href="#3-抽象数据类型-Abstract-Data-Type" class="headerlink" title="3. 抽象数据类型 (Abstract Data Type)"></a>3. 抽象数据类型 (<code>A</code>bstract <code>D</code>ata <code>T</code>ype)</h2><p>抽象数据类型和高级语言中的数据类型实质上<code>是一个概念</code>，抽象数据类型包含一般数据类型的概念，但<code>含义比一般数据类型更广、更抽象</code>。</p><p>Abstract data types and data types in high-level languages are essentially <code>a concept</code>. Abstract data types contain the concept of general data types, but the meaning is broader and more abstract than general data types.</p><p>抽象类型的<code>伪代码</code>定义格式如：</p><pre><code class="ADT">ADT 抽象数据类型名 {    数据对象 D: &lt;数据对象的定义&gt;    数据对象 R: &lt;数据对象的定义&gt;    数据对象 P: &lt;数据对象的定义&gt;} ADT 抽象数据类型名</code></pre><p>The abstract type of <code>pseudo code</code> is defined as follows:</p><pre><code class="ADT">ADT abstract data type name {     Data Object D: &lt;Definition of Data Object&gt;     Data Object R: &lt;Definition of Data Object&gt;     Data Object P: &lt;Definition of Data Object&gt;} ADT abstract data type name</code></pre><hr><h2 id="Donate-Me-☕️"><a href="#Donate-Me-☕️" class="headerlink" title="Donate Me ☕️"></a>Donate Me ☕️</h2><p>If you like my blog post, you can Donate to me in the following ways.</p><p>如果你喜欢我的博文，可以通过下面的方式支持我，你的支持是我最大的动力 😘</p><table><thead><tr><th align="center">Donate 😇</th><th align="center">Qr code</th></tr></thead><tbody><tr><td align="center">Wechat</td><td align="center"><img src="/img/wechat.png" alt="Wechat"></td></tr><tr><td align="center">Ali Pay</td><td align="center"><img src="/img/alipay.png" alt="Ali Pay"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning Notes </tag>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
