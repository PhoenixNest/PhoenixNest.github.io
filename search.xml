<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Welcome To PhoenixNest&#39;s Blog</title>
      <link href="Welcome/"/>
      <url>Welcome/</url>
      
        <content type="html"><![CDATA[<h2 id="Hi"><a href="#Hi" class="headerlink" title="Hi"></a>Hi</h2><p>👋 欢迎来到我的博客, 我是<code>PhoenixNest • (Peter Chen)</code>。</p><blockquote><ul><li>一个 <code>吉林大学珠海学院（现珠海科技学院） • 计算机学院 • 软件工程专业</code>的<strong>应届本科毕业生</strong>。</li><li>一个知晓 C++、Java、MySQL、SQL Server 等拼写的程序猿（发量犹在，Still a ROOKIE）。</li><li>一个做过<strong>服务器运维</strong>，知晓 <strong>Linux</strong>，调配过数据库与服务器底层硬件的苦逼练习生。</li><li>一个知晓 MVVM 开发架构，使用过 <strong>Google JetPack</strong> 快速开发框架的Android程序猿。</li><li>一个做过高德地图（<strong>Android</strong>）开发，正在转入 <strong>Flutter</strong> 跨平台开发的新人。</li><li>一个热爱星际争霸2，喜欢暴雪游戏，梦想进入暴雪公司（<strong>Blizzard</strong>）的SCer。</li><li>一个喜欢游泳，曾做过<strong>蛙泳与自由泳教练</strong>的泳客。</li><li>一个接触计算机编程开发<strong>3年</strong>，喜欢学习新技术的<strong>软硬件攻城狮</strong>。</li><li>一个做过高达模型评测，开过电台的小 Up 主。</li><li>一个喜欢拍照，喜欢记录生活，不会讲粤语的广东潮汕人。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 置顶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Review</title>
      <link href="Android-Review/"/>
      <url>Android-Review/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇将介绍我在整理<code>曾经学习 Android</code>时的一些笔记，也算是对曾经所学知识的<code>回顾</code>。</p></blockquote><blockquote><p>待完善ing……</p></blockquote><hr><h2 id="Java-•-Native"><a href="#Java-•-Native" class="headerlink" title="Java • Native"></a>Java • Native</h2><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/java.jpg" alt="Java"></p><h3 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h3><blockquote><p>封装</p></blockquote><p>原则：将不需要对外提供的内容隐藏起来，属性隐藏，提供公共的访问方式。</p><p>好处：提高安全性，代码复用性</p><p>局部变量隐藏成员变量（就近原则）</p><hr><blockquote><p>继承</p></blockquote><p>在程序中，继承是在描述类与类之间的所属关系，蒋多个类中的共有成员变量和成员方法抽取到一个类中（父类），让多个类去继承这个父类。</p><p><code>一个类继承另一个类，继承这个类以后，就继承了它所有的属性和方法</code>。</p><p>使用extends关键字继承另一个类。格式：class （子类或派生类） extends （父类、超类或基类）。</p><pre><code class="java">class Son extends Father&#123;    // ...&#125;</code></pre><hr><p>特点：</p><ul><li><p>Java中，类只支持单继承，不允许多继承。</p></li><li><p>一个类可以被多个类继承。</p></li><li><p>多层继承，一个类的父类可以在去继承另一个父类。</p></li><li><p>子父类的关系是相对概念。</p></li></ul><hr><p>继承中成员变量的特点：</p><ul><li><p>只能继承父类非私有化，成员变量名字相同就用子类自己的名字。名字不同，子类没有，就用父类。</p></li><li><p>就近原则：谁离得近就用谁，如果就局部变量就优先使用局部变量，如果没有局部变量，就先看子类的成员变量 ，如果子类的成员变量也没有，就看父类的成员变量。</p></li><li><p>super：和this用法很像，super表示父类（this和super都是写在方法的第一行，但是他俩不能出现在同一行）。</p></li></ul><hr><blockquote><p>多态</p></blockquote><p>父类应用变量指向子类对象</p><p>格式：父类类型 变量名 =new 子类类型（）；</p><p>多态的前提：</p><ul><li><p>子父类继承关系（实现关系）</p></li><li><p>父类引用指向子类对象</p></li><li><p>方法的重写</p></li></ul><p>一个父类类型的变量指向子类类型的对象，在运行时，变现出子类的特征。</p><p>多态情况下，只能直接调用父类中的方法，子类中的方法不直接调用。</p><p>出多态的原因：Java代码需要编译，在编译时，允许父类对象指向子类对象，该对象边线处父类特征，这叫编译时类型。在运行时，变现出子类特征，在运行时类型。</p><hr><blockquote><p>抽象</p></blockquote><p>抽象：使用abstract关键字修饰一个类，这个类就是抽象类。</p><p>用于修饰方法和类。</p><ul><li><p>抽象方法：不同类的方法是相似的，但是具体内容不一样，这是我们只抽取他们的声明。没有具体的方法体，没有集体方法体的方法就叫做抽象方法</p></li><li><p>抽象类：有抽象方法的类必须时抽象类。</p></li></ul><p>注意：一个类继承了抽象类需要重写所有的抽象方法，否则这个类就是抽象方法。</p><p>特点：</p><ul><li><p>抽象方法只能在抽象类中。</p></li><li><p>抽象方法和抽象类都被abstract修饰。</p></li><li><p>抽象类不能创建对象。</p></li><li><p>抽象类中，可以有非抽象方法。</p></li><li><p>抽象类与类的关系也是继承。</p></li><li><p>一个类继承了抽象类需要重写所有的抽象方法，否则这个类就是抽象类。</p></li></ul><p>抽象类的成员特点:</p><ul><li><p>成员变量：可以有成员变量，也可以有常量。</p></li><li><p>成员方法：可以有抽象方法，也可以有非抽象方法。</p></li><li><p>构造方法：可以有构造方法，也可以对成员变量初始化。</p></li><li><p>private：私有，只有当前类中可以访问。</p></li><li><p>[default]：默认的，同一个包可以访问。</p></li><li><p>protected：受保护的，字类可以访问。</p></li><li><p>public：公有的，所有类中都可以访问。</p></li></ul><hr><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final作为Java中的关键字可以用于三个地方。用于修饰类、类属性和类方法。</p><p>特征：凡是引用final关键字的地方皆不可修改。</p><ul><li><p>修饰<code>类</code>：表示该类不能被继承.</p></li><li><p>修饰<code>方法</code>：表示方法不能被重写。</p></li><li><p>修饰<code>变量</code>：表示变量只能一次赋值以后值不能被修改（常量）。</p></li></ul><hr><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><pre><code class="java">// 实体类public class Developer &#123;    private String name; // 姓名    private String department; // 所在部门    private int age; // 年龄    @Override    public String toString() &#123;        return &quot;Developer name: &quot; + name +                &quot; department: &quot; + department +                &quot; age &quot; + age;    &#125;    public Developer(String name, String department, int age) &#123;        this.name = name;        this.department = department;        this.age = age;    &#125;    // 创建一个让程序员开始工作的方法    public void work() &#123;        System.out.println(name + &quot; start work&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class Demo &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;        // 通过反射获取实体类        Class&lt;?&gt; developer = Class.forName(&quot;Developer&quot;);        // 获取构造函数        // 参数列表为实体类构造函数的参数列表类型        Constructor&lt;?&gt; constructor = developer.getConstructor(String.class, String.class, int.class);        // 接下来可通过该构造体，生成新的实例        // 参数列表为新实例的 属性        // 可以自行设置        Object instance = constructor.newInstance(&quot;Peter Chen&quot;, &quot;Dev&quot;, 22);        // 实例创建结束，调用方法        System.out.println(instance.toString());        // 可以通过反射，修改实例对象的属性值        // 修改姓名        Field name = developer.getDeclaredField(&quot;name&quot;);        // 公开访问        name.setAccessible(true);        // 修改        name.set(instance, &quot;zhangsan&quot;);        // 可通过反射，调用实体类的中的方法，试试让新的 zhangsan 程序员开始工作        Method work = developer.getMethod(&quot;work&quot;, null);        // 反馈回刚才生成的实例        work.invoke(instance, null);    &#125;&#125;</code></pre><hr><h3 id="强引用-软引用-弱引用-虚引用"><a href="#强引用-软引用-弱引用-虚引用" class="headerlink" title="强引用 / 软引用 / 弱引用 / 虚引用"></a>强引用 / 软引用 / 弱引用 / 虚引用</h3><blockquote><p>强引用</p></blockquote><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出 OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用 对象来解决内存不足的问题。</p><pre><code class="java">Object object = new Object();String string = &quot;Test&quot;;</code></pre><hr><blockquote><p>软引用</p></blockquote><p>软引用是用来描述一些有用但并不是必需的对象，在Java中用<code>java.lang.ref.SoftReference类</code>来表示。</p><p>对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。</p><p>因此，这一点可以<code>很好地用来解决OOM的问题</code>，并且这个特性很<code>适合用来实现缓存</code>：比如网页缓存、图片缓存等。</p><pre><code class="java">public class SoftRef &#123;       public static void main(String[] args)&#123;          System.out.println(&quot;start&quot;);                    Obj obj = new Obj();                    SoftReference&lt;Obj&gt; sr = new SoftReference&lt;Obj&gt;(obj);          obj = null;          System.out.println(sr.get());          System.out.println(&quot;end&quot;);         &#125;       &#125;   class Obj&#123;      int[] obj ;      public Obj()&#123;          obj = new int[1000];      &#125;  </code></pre><p>当内存足够大时可以把数组存入软引用，取数据时就可从内存里取数据，提高运行效率。</p><p>软引用在实际中有重要的应用，例如浏览器的后退按钮，这个后退时显示的网页内容可以重新进行请求或者从缓存中取出：</p><ul><li><p>如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建。</p></li><li><p>如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出这时候就可以使用软引用。</p></li></ul><hr><blockquote><p>弱引用</p></blockquote><p>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用<code>java.lang.ref.WeakReference类</code>来表示。</p><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。</p><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p><p>不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。所以被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</p><pre><code class="java">WeakReference&lt;String&gt; sr = new WeakReference&lt;String&gt;(new String(&quot;hello&quot;));System.out.println(sr.get());// 在使用软引用和弱引用的时候，我们可以显式地通过 System.gc() 来通知JVM进行垃圾回收。// 但是要注意的是，虽然发出了通知，JVM不一定会立刻执行。// 也就是说 System.gc() 是无法确保此时JVM一定会进行垃圾回收的。System.gc();System.out.println(sr.get());</code></pre><p>弱引用还可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><pre><code class="java">Object obj = new Object(); //只要obj还指向对象就不会被回收WeakReference&lt;Object&gt; wr = new WeakReference&lt;Object&gt;(obj);</code></pre><p>当要获得 WeakReference引用的object时, 首先需要判断它是否已经被回收，如果wr.get()方法为空, 那么说明 WeakReference 指向的对象已经被回收了。</p><hr><blockquote><p>虚引用</p></blockquote><p>虚引用和前面的软引用、弱引用不同，它<code>并不影响对象的生命周期</code>。在Java中用<code>java.lang.ref.PhantomReference类</code>表示。</p><p>如果一个对象与虚引用关联，则跟没有引用与之关联一样，<code>在任何时候都可能被垃圾回收器回收</code>。虚引用主要用来跟踪对象被垃圾回收的活动。</p><p><code>虚引用必须和引用队列关联使用</code>，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。</p><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。</p><p>如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><pre><code class="java">// 虚引用必须和引用队列关联使用ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;String&gt;();PhantomReference&lt;String&gt; pr = new PhantomReference&lt;String&gt;(new String(&quot;hello&quot;), queue);System.out.println(pr.get());</code></pre><hr><blockquote><p>总结</p></blockquote><table><thead><tr><th><strong>引用类型</strong></th><th><strong>被回收时间</strong></th><th><strong>用途</strong></th><th><strong>生存时间</strong></th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td><td>JVM停止运行时</td></tr><tr><td>软引用</td><td>内存不足时</td><td>对象缓存</td><td>内存不足时</td></tr><tr><td>弱引用</td><td>jvm垃圾回收时</td><td>对象缓存</td><td>gc运行后</td></tr><tr><td>虚引用</td><td>未知</td><td>未知</td><td>未知</td></tr></tbody></table><hr><h3 id="数组-集合"><a href="#数组-集合" class="headerlink" title="数组 / 集合"></a>数组 / 集合</h3><ul><li><p>数组是Java语言内置的数据类型，他是一个线性的序列，所有可以快速访问其他的元素，数组和其他语言不同，当你创建了一个数组时，他的容量是不变的，而且在生命周期也是不能改变的，还有Java数组会做边界检查，如果发现有越界现象，会报RuntimeException异常错误，当然检查边界会以效率为代价。</p></li><li><p>Java 还提供其他集合，List，Map，Set，他们处理对象的时候就好像这些对象没有自己的类型一样，而是直接归根于Object，这样只需要创建一个集合，把对象放进去，取出时转换成自己的类型就行了。</p></li></ul><hr><blockquote><p>区别</p></blockquote><ul><li><p>数组声明了它容纳的元素的类型，而集合不声明。</p></li><li><p>数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。</p></li><li><p>集合是可以动态扩展容量，可以根据需要动态改变大小，集合提供更多的成员方法，能满足更多的需求。</p></li><li><p>数组的存放的类型只能是一种（基本类型/引用类型）。</p></li><li><p>集合存放的类型可以不是一种（不加泛型时添加的类型是Object）。</p></li><li><p>数组是Java语言中内置的数据类型,是线性排列的,执行效率或者类型检查都是最快的。</p></li></ul><hr><h3 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String / StringBuffer / StringBuilder"></a>String / StringBuffer / StringBuilder</h3><p><a href="https://cloud.tencent.com/developer/article/1414756">腾讯云 • 深入理解String、StringBuffer和StringBuilder类的区别</a></p><blockquote><p>可变与不可变</p></blockquote><ul><li><p>String：<code>不可变</code>类，即创建String对象后，该对象中的字符串是不可改变的，直到这个对象被销毁</p></li><li><p>StringBuffer：继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，是<code>可变</code>类。</p></li><li><p>StringBuilder：继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，是<code>可变</code>类。</p></li></ul><p>由于String是可变类，适合在需要被共享的场合中使用，当一个字符串经常被修改时，最好使用StringBuffer实现。</p><p>如果用String保存一个经常被修改的字符串，该字符串每次修改时都会创建新的无用的对象，这些无用的对象会被垃圾回收器回收，会影响程序的性能，不建议这么做。</p><hr><blockquote><p>初始化方式</p></blockquote><p>由于String是可变类，适合在需要被共享的场合中使用，当一个字符串经常被修改时，最好使用StringBuffer实现。如果用String保存一个经常被修改的字符串，该字符串每次修改时都会创建新的无用的对象，这些无用的对象会被垃圾回收器回收，会影响程序的性能，不建议这么做。</p><hr><blockquote><p>字符串修改方式</p></blockquote><p>String字符串修改方法：</p><ol><li><p>创建一个StringBuffer</p></li><li><p>调用StringBuffer的append方法</p></li><li><p>调用StringBuffer 的 toString()方法 把结果返回</p></li></ol><p>示例代码如下：</p><pre><code class="java">// StringString str = &quot;hello&quot;;str += &quot;java&quot;;// 对String的修改等价于以下使用StringBuffer的代码：// StringBufferStringBuffer stringBuffer = new StringBuffer(str);stringBuffer.append(&quot;java&quot;);str = stringBuffer.toString();</code></pre><p>上述String字符串的修改过程要比StringBuffer多一些额外操作，会增加一些临时的对象，从而导致程序的执行效率降低。</p><p>StringBuffer和StringBuilder在修改字符串方面比String的性能要高。</p><hr><blockquote><p>内部实现 equals 和 hashCode 方法</p></blockquote><p>String 实现了 equals()方法 和 hashCode()方法。</p><pre><code class="java">new String(&quot;java&quot;).equals(new String(&quot;java&quot;)) // 结果为true</code></pre><hr><p>StringBuffer没有实现equals()方法和hashCode()方法。</p><pre><code class="java">new StringBuffer(&quot;java&quot;).equals(new StringBuffer(&quot;java&quot;)) // 结果为false</code></pre><p>将StringBuffer对象存储进Java集合类中会出现问题。</p><hr><blockquote><p>线程安全</p></blockquote><p>StringBuffer与StringBuilder都提供了一系列插入、追加、改变字符串里的字符序列的方法，它们的用法基本相同，只是<code>StringBuilder是线程不安全的</code>，<code>StringBuffer是线程安全的</code>。</p><p>如果只是在单线程中使用字符串缓冲区，则StringBuilder的效率会高些，但是当多线程访问时，最好使用StringBuffer。</p><hr><blockquote><p>总结</p></blockquote><p>综上，在执行效率方面，StringBuilder最高，StringBuffer次之，String最低，对于这种情况，一般而言，如果要操作的数量比较小，应优先使用String类；如果是在单线程下操作大量数据，应优先使用StringBuilder类；如果是在多线程下操作大量数据，应优先使用StringBuilder类。</p><hr><blockquote><p>用例：将字符串反转</p></blockquote><pre><code class="java">// StringBuffer reverseStringBuffer stringBuffer = new StringBuffer();stringBuffer.append(&quot;abcdefg&quot;);System.out.println(stringBuffer. reverse()); // gfedcba// StringBuilder reverseStringBuilder stringBuilder = new StringBuilder();stringBuilder.append(&quot;abcdefg&quot;);System.out.println(stringBuilder. reverse()); // gfedcba</code></pre><hr><h2 id="Android-•-Native"><a href="#Android-•-Native" class="headerlink" title="Android • Native"></a>Android • Native</h2><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Android/Android.png" alt="Android"></p><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><blockquote><p>在 Google 公开 Jetpack 后，官方提倡 <code>单Activity，多Fragment</code> 的开发模式。</p></blockquote><p>优点：</p><ul><li><p>Fragment 比 Activity 占用较少系统资源，使 App 能在较低端的手机上流畅运行。</p></li><li><p>Fragment 作为碎片，更容易控制每个场景的生命周期与状态。</p></li></ul><hr><blockquote><p>生命周期</p></blockquote><p>下图为Activity的生命周期示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Android/activity_lifecycle.png" alt="Activity Lifecycle"></p><p>场景：用户点击 App图标 启动App</p><p>Activity启动 -&gt; onCreate() -&gt; onStart() -&gt; onResume()</p><ul><li><p>onCreate()：设置布局资源，数据加载，图片预加载等。</p></li><li><p>onStart()：Activity暂未处在前台状态，用户无法对 Activity 进行触摸点击或者滑动等操作。</p></li><li><p>onResume()：该生命周期方法调用后，用户即可对Activity进行控制，也可在该方法中进行数据预加载。</p></li></ul><hr><blockquote><p>场景：用户将App退居后台。</p></blockquote><p>Activity 不可见 -&gt; onPause() -&gt; onStop()</p><ul><li><p>onPause()：表明 Activity 处于停滞状态，Activity 可见但不可被操作，Activity退居后台时被调用。</p></li><li><p>onStop()：整个 Activity 处于后台不可见或被其他 Activity 覆盖，若系统处于内存吃紧状态时可能会被系统回收。</p></li></ul><hr><blockquote><p>场景：用户从后台返回App、用户再次点击App图标使其回到前台。</p></blockquote><p>再次回到 Activity 时 -&gt; onRestart() -&gt; onStart() -&gt; onResume()</p><ul><li>onRestart()：Activity由不可见状态到可见状态时调用，常见场景为后台App重新回到前台。</li></ul><hr><blockquote><p>场景：用户将App从后台堆栈中移除。</p></blockquote><p>退出当前Activity时 -&gt; onPause() -&gt; onStop -&gt; onDestroy()</p><ul><li>onDestroy()：最后一个生命周期方法，资源释放、内存回收。</li></ul><hr><blockquote><p>显式Intent、隐式Intent</p></blockquote><ul><li>显示Intent</li></ul><p>对于已经在 Manifest清单文件 中定义的Activity，可使用以下代码进行显示跳转</p><pre><code class="java">// 模拟从欢迎页跳转到主页startActivity(new Intent(WelcomeActivity.this, MainActivity.class));</code></pre><hr><ul><li>隐式Intent</li></ul><p>相较于显式Intent，隐式Intent则含蓄了许多，它并不明确指出想要启动哪一个Activity，而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并找出合适的Activity去启动。</p><pre><code class="java">// 模拟拨号，隐式Intent 将会判断传入的意图，并自动搜索适合的Activity进行启动Intent telIntent = new Intent(Intent.ACTION_DIAL)// 设置电话号码Uri data = Uri.parse(&quot;tel:&quot; + telNum);telIntent.setData(data);startActivity(telIntent);</code></pre><hr><blockquote><p>进程优先级</p></blockquote><p>由高到低依次为：</p><p>前台 / 可见 / 服务 / 后台 / 空</p><ul><li><p>前台进程：App前台可操作。</p></li><li><p>可见：App处于后台堆栈，可见但不可操作。</p></li><li><p>服务：Service服务进程通常是一种可在后台执行长时间操作而不提供界面的应用组件。</p></li><li><p>后台：App处于后台堆栈不可见，若手机内存不足，则该进程可能被后台回收。</p></li><li><p>空：在该进程内，没有任何东西运行，该进程目的是用作缓存。以减少应用在下次启动中所需的时间。</p></li></ul><hr><blockquote><p>启动模式</p></blockquote><ul><li><p>standard：普通模式，走所有生命周期方法，对内存有很大消耗。</p></li><li><p>singleTop：<code>栈顶复用</code>模式，判断 待创建的Activity 是否已位于栈顶，若 待创建Activity 已位于栈顶，则会复用 栈顶 Activity；若没有，则还是会走所有生命周期创建一个 新的Activity。</p></li><li><p>singleTask：<code>栈内复用</code>模式，检测整个任务栈中是否存在当前需要启动的Activity，若存在，则直接置于栈顶，并将已有 栈顶Activity 全数销毁出栈，并回调 onNewIntent() 方法</p></li><li><p>singleInstance：<code>独享</code>模式，若Activity在整个App中只有一个实例，且独占一个任务栈，则称为独享模式。</p></li></ul><hr><blockquote><p>进程间通信</p></blockquote><p><a href="https://cloud.tencent.com/developer/article/1441385">Android中进程间通信（IPC）方式</a></p><p>IPC（Inter-Process Communication）为进程间通信或跨进程通信，是指两个进程进行进程间通信的过程。</p><p>在Android中，为每一个应用程序都分配了一个独立的虚拟机，不同虚拟机在内存分配上都有不同的地址空间，互相访问数据需要借助其他手段。</p><ul><li>Bundle模式</li></ul><p>在Android中三大组件（Activity，Service，Receiver）都支持在Intent中传递Bundle数据，由于Bundle实现了Parcelable接口（一种特有的序列化方法），所以它可以很方便的在不同的进程之间进行传输。当在一个进程中启动另外一个进程的Activity，Service，Receiver时，可以在Bundle中附加需要传输给远程的进程的信息，并通过Intent发送出去。</p><pre><code class="java">Intent intent = new Intent(MainActivity.this, SecondActivity.class);Bundle bundle = new Bundle();bundle.putString(&quot;key&quot;, &quot;value&quot;);intent.putExtras(bundle);startActivity(intent);</code></pre><hr><ul><li>文件共享模式</li></ul><p>文件共享：将对象序列化之后保存到文件中，在通过反序列，将对象从文件中读取出来。此方式对文件的格式没有具体的要求，可以是文件、XML、JSON等。</p><p>文件共享方式也存在着很大的局限性，如并发读/写问题，如读取的数据不完整或者读取的数据不是最新的。文件共享适合在对数据同步要求不高的进程间通信，并且要妥善处理并发读/写的问题。</p><hr><ul><li>Message模式</li></ul><hr><ul><li>使用 AIDL 的方式</li></ul><hr><ul><li>ContentProvider</li></ul><hr><ul><li>广播（Broadcast）</li></ul><hr><ul><li>Socket</li></ul><hr><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Android/fragment-screen-sizes.png" alt="Fragment"></p><blockquote><p>生命周期</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Android/fragment-view-lifecycle.png" alt="Fragment Lifecycle"></p><blockquote><p>场景：Activity 携带的 Fragment 初始化。</p></blockquote><p>CREATED -&gt; STARTED -&gt; RESUMED</p><ul><li>CREATED：onCreate() -&gt; onCreateView() -&gt; onViewCreated() -&gt; onViewStateRestored()</li></ul><p>对于 onCreteView()，可在该方法内手动填充或创建 Fragment 视图，且可在该方法内使用 getViewLifecycleOwnerLiveData() 对 LiveData 进行初始化或更新。若属兔已经创建完成，则会调用<br> onViewStateRestored()，在该方法内需要对已与 Fragment视图 进行关联的状态进行重建。</p><ul><li>STARTED：onStart()</li></ul><p>Fragment实体已经处于可用状态（用户暂不可操作），当前Fragment 所属的 FragmentManager 将执行相应 Fragment事务。</p><ul><li>RESUMED：onResumed()</li></ul><p>Fragment可见，其动画与事务均执行完毕，且可响应用户操作。</p><hr><blockquote><p>场景：用户选择离开当前Fragment页面、宿主Activity 退居后台、当前Fragment 退居后台不可见。</p></blockquote><p>RESUMED -&gt; STARTED -&gt; CREATED</p><ul><li><p>RESUMED：onResumed()</p></li><li><p>STARTED：onPause()</p></li><li><p>CREATED：onStop() -&gt; onSaveInstanceSate() -&gt; onDestroyView()</p></li></ul><p>对于API级别28（Android 9）之前的设备，onSaveInstanceState() 函数将在 onStop() 前调用。</p><p>对于API级别28（Android 9）之后的设备，则反之。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Android/fragment-stop-save-order.png" alt="onSaveInstanceState() 与 onStop()"></p><hr><blockquote><p>场景：宿主Activity 或 当前Fragment 被回收、当前Fragment的FragmentManager被销毁。</p></blockquote><p>DESTROYED</p><ul><li>onDestroy()</li></ul><hr><blockquote><p>Fragment 通信</p></blockquote><p>大部分情况下，通过ViewModel在多个Fragment或与其宿主Activity之间共享数据是一个理想的选择。</p><p>普通模式：</p><ul><li><p>在<code>Fragment</code>中 调用<code>Activity</code>中 的方法 <code>GetActivity</code>（F -&gt; A）</p></li><li><p>在<code>Activity</code>中 调用<code>Fragment</code>中 的方法进行 <code>接口回调</code>（A -&gt; F）</p></li><li><p>在<code>Fragment</code>中 调用<code>Fragment</code>中 的方法 <code>findFragmentById</code> （F -&gt; F）</p></li></ul><hr><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><blockquote><p>应用场景</p></blockquote><p>一种可在后台执行长时间运行操作而不提供界面的应用组件，如后台处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序进行交互。</p><p>简单地说，服务是一种即使用户未与应用交互也可在后台运行的组件，因此，只有在需要服务时才应创建服务。</p><hr><blockquote><p>与 线程Thread 区别</p></blockquote><p>如果必须在主线程之外执行操作，但只在用户与应用交互时执行此操作，则应创建新线程。例如，如果只是想在 Activity 运行的同时播放一些音乐，则可在 onCreate() 中创建线程，在 onStart() 中启动线程运行，然后在 onStop() 中停止线程。</p><hr><blockquote><p>生命周期</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Android/service_lifecycle.png" alt="Service Lifecycle"></p><p>onStartCommand() -&gt; onBind() -&gt; onCreate() -&gt; onDestroy()</p><ul><li>onStartCommand()</li></ul><p>当一个组件，如Activity请求启动服务时，系统将调用该方法，在服务启动后，会在后台无限期运行，直到调用stopSelf() 或 stopService() 停止。</p><p>PS：若只需要绑定服务，则无需实现此方法。</p><hr><ul><li>onBind()</li></ul><p>当另一个组件想要与服务绑定时，系统将调用该方法，在此方法中，必须返回IBinder提供的接口，以供客户端与服务进行通信。</p><hr><ul><li>onCreate()</li></ul><p>首次创建服务时，系统会首先调用此方法执行一次性设置（先于onStartCommand()或onBind()），若该服务已在运行，则不会调用。</p><hr><ul><li>onDestroy()</li></ul><p>不再使用服务并且准备将其销毁时，系统将调用该方法，服务应通过使用该方法清理并回收资源，如：线程、注册的侦听器、接受器等。</p><hr><blockquote><p>前台Service</p></blockquote><p>若希望Service一直保持运行状态，则可以考虑使用前台Service，该Service会有一个一直运行在系统状态栏的图标，下拉状态栏可以看到更加详细的信息，类似通知的效果。</p><p>由于状态栏中一直有一个正在运行的图标，相当于应用的另一种前台可见状态，因此系统不会倾向于回收前台Service。</p><hr><blockquote><p>IntentService</p></blockquote><p>处理异步请求，实现多线程。</p><p>若 Service中 处理过多耗时逻辑，则有可能出现 ANR（Application Not Responding）的情况。</p><ul><li>与 普通Service 区别</li></ul><p>Service需要主动调用 stopSelf() 来结束服务，而IntentService不需要。</p><p>在 IntentService中，onHandleIntent() 方法可用来处理一些耗时逻辑。</p><p>在所有Intent被处理完后，系统会自动关闭服务。</p><pre><code class="java">public class MyIntentService extends IntentService &#123;    public MyIntentService() &#123;        super(&quot;MyIntentService&quot;);    &#125;    @Override    protected void onHandleIntent(Intent intent) &#123;        // 处理耗时逻辑    &#125;&#125;</code></pre><hr><h3 id="Content-Provider"><a href="#Content-Provider" class="headerlink" title="Content Provider"></a>Content Provider</h3><p>使用场景：当前应用需要与其他应用共享数据，如当前应用需使用拨号，则会寻求电话应用共享数据。</p><hr><h3 id="Broadcast-Receiver"><a href="#Broadcast-Receiver" class="headerlink" title="Broadcast Receiver"></a>Broadcast Receiver</h3><p>使用场景：登录异常强制退出、用户身份认证过期需重新登陆。</p><ul><li><p>标准广播：是一种<code>完全异步执行</code>的广播，在广播发出之后，所有的BroadcastReceiver几乎会在一时刻收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的<code>效率会比较高</code>，但同时也意味着它是<code>无法被截断</code>的。</p></li><li><p>有序广播（消息队列）：是一种<code>同步执行</code>的广播，在广播发出之后，同一时刻只会有一个BroadcastReceiver能够收到这条广播消息，当这个BroadcastReceiver中的逻辑执行完毕后，广播才会继续传递。所以此时的BroadcastReceiver是有先后顺序的，优先级高的BroadcastReceiver就可以先收到广播消息，并且前面的BroadcastReceiver还可以截断正在传递的广播，这样后面的BroadcastReceiver就无法收到广播消息了。</p></li></ul><hr><h3 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h3><hr><h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><blockquote><p>Android 本身不允许我们在Ui线程中进行复杂的耗时操作，这些耗时操作极易造成 ANR（Application Not Responding），因此耗时操作通常会在后台子线程中执行。</p></blockquote><p>在 Android中，官方提供了诸如Handler、AsyncTask来处理后台耗时消息。</p><blockquote><p>异步消息处理机制</p></blockquote><ul><li>Message</li></ul><p>Message是<code>在线程之间传递的消息</code>，它可以在内部携带少量的信息，用于在不同线程之间传递数据。</p><hr><ul><li>Handler</li></ul><p>Handler顾名思义也就是<code>处理者</code>的意思，它主要是用于发送和处理消息的。发送消息一般是使用Handler的sendMessage()方法、post()方法等，而发出的消息经过一系列地辗转处理后，最终会传递到Handler的handleMessage()方法中。</p><hr><ul><li>MessageQueue</li></ul><p>MessageQueue是<code>消息队列</code>的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象。</p><hr><ul><li>Looper</li></ul><p>Looper是<code>每个线程中的MessageQueue的管家</code>，调用Looper的loop()方法后，就会进入一个无限循环当中，然后每当发现MessageQueue中存在一条消息时，就会将它取出，并传递到Handler的handleMessage()方法中。<code>每个线程中只会有一个Looper对象</code>。</p><hr><blockquote><p>AsyncTask</p></blockquote><p>首先来看一下AsyncTask的基本用法。由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须创建一个子类去继承它。在继承时我们可以为AsyncTask类指定3个泛型参数，这3个参数的用途如下。</p><ul><li><p>Params：在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。</p></li><li><p>Progress：在后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。</p></li><li><p>Result：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型</p></li></ul><pre><code class="java">class DownloadTask extends AsyncTask&lt;Params, Progress, Result&gt;() &#123; ...&#125;</code></pre><hr><p>对于AsyncTask的使用我们还需要重写以下4个方法才能完成对任务的定制。</p><ul><li>onPreExecute()</li></ul><p>这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。</p><hr><ul><li>doInBackground(Params…)</li></ul><p>这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成，就可以通过return语句将任务的执行结果返回，如果AsyncTask的第三个泛型参数指定的是Unit，就可以不返回任务执行结果。</p><p>注意，在这个方法中是不可以进行UI操作的。</p><p>如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用 publishProgress(Progress…)方法来完成。</p><hr><ul><li>onProgressUpdate(Progress…)</li></ul><p>当在后台任务中调用了publishProgress(Progress…)方法后，onProgressUpdate (Progress…)方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。</p><p>在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。</p><hr><ul><li>onPostExecute(Result)</li></ul><p>当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。</p><p>返回的数据会作为参数传递到此方法中，可以利用返回的数据进行一些UI操作，比如说提醒任务执行的结果，以及关闭进度条对话框等。</p><hr><blockquote><p>一个模拟下载的AsyncTask例子：</p></blockquote><pre><code class="java">public static class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;        @Override        protected void onPreExecute() &#123;            progressDialog.show(); // 显示进度对话框        &#125;        @Override        protected Boolean doInBackground(Void... voids) &#123;            try &#123;                while (true) &#123;                    Integer downloadPercent = doDownload(); // 这是一个虚构的方法                    publishProgress(downloadPercent);                    if (downloadPercent &gt;= 100) &#123;                        break;                    &#125;                &#125;                return true;            &#125; catch (Exception exception) &#123;                return false;            &#125;        &#125;        @Override        protected void onProgressUpdate(Integer... values) &#123;            // 在这里更新下载进度            progressDialog.setMessage(&quot;Downloaded &quot; + values[0] + &quot;%&quot;);        &#125;        @Override        protected void onPostExecute(Boolean result) &#123;            progressDialog.dismiss();// 关闭进度对话框            // 在这里提示下载结果            if (result) &#123;                Toast.makeText(context, &quot;Download succeeded&quot;, Toast.LENGTH_SHORT).show();            &#125; else &#123;                Toast.makeText(context, &quot;Download failed&quot;, Toast.LENGTH_SHORT).show();            &#125;        &#125;    &#125;</code></pre><p>在这个DownloadTask中，我们在doInBackground()方法里执行具体的下载任务。这个方法里的代码都是在子线程中运行的，因而不会影响主线程的运行。注意，这里虚构了一个doDownload()方法，用于计算当前的下载进度并返回，我们假设这个方法已经存在了。在得到了当前的下载进度后，下面就该考虑如何把它显示到界面上了，由于doInBackground()方法是在子线程中运行的，在这里肯定不能进行UI操作，所以我们可以调用publishProgress()方法并传入当前的下载进度，这样onProgressUpdate()方法就会很快被调用，在这里就可以进行UI操作了。</p><p>当下载完成后，doInBackground()方法会返回一个布尔型变量，这样onPostExecute()方法就会很快被调用，这个方法也是在主线程中运行的。然后，在这里我们会根据下载的结果弹出相应的Toast提示，从而完成整个DownloadTask任务。</p><blockquote><p>简单来说，使用AsyncTask的诀窍就是，在doInBackground()方法中执行具体的耗时任务，在onProgressUpdate()方法中进行UI操作，在onPostExecute()方法中执行一些任务的收尾工作。</p></blockquote><p>如果想要启动这个任务，只需编写以下代码即可：</p><pre><code class="java">new DownloadTask().execute();</code></pre><hr><h3 id="点击事件分发机制"><a href="#点击事件分发机制" class="headerlink" title="点击事件分发机制"></a>点击事件分发机制</h3><blockquote><p>事件传递的顺序</p></blockquote><p>Activity -&gt; ViewGroup -&gt; View</p><hr><h3 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h3><p>使用场景：聊天信息实时接收</p><hr><h2 id="Android-•-Jetpack"><a href="#Android-•-Jetpack" class="headerlink" title="Android • Jetpack"></a>Android • Jetpack</h2><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/android_jetpack.png" alt="Jetpack"></p><p>Jetpack 是一个架构组件库，其中任何一个组件也可独立拆分使用，采用由 Google 官方推荐的 MVVM 架构（Model、View、ViewModel），旨在为开发者提供开箱即用的快速开发体验。</p><blockquote><p>主要的 Jetpack 框架组件：</p></blockquote><ul><li><p>Lifecycle（生命周期）</p></li><li><p>LiveData（观察者模式的数据监控）</p></li><li><p>ViewModel（状态管理，页面通信）</p></li><li><p>ViewBinding or DataBinding（数据双向绑定与Ui访问控制）</p></li><li><p>Navigation（页面管理）</p></li><li><p>Paging（分页）</p></li><li><p>WorkManager（多线程处理）</p></li><li><p>ROOM（数据库接口）</p></li></ul><blockquote><p>组件库提供的新 Ui 组件</p></blockquote><ul><li><p>Jetpack Compose（声明式Ui，所见即所得）</p></li><li><p>ViewPager2</p></li></ul><hr><h3 id="MVC-MVP-MVVM"><a href="#MVC-MVP-MVVM" class="headerlink" title="MVC / MVP / MVVM"></a>MVC / MVP / MVVM</h3><ul><li><p>MVC：Model，View，Controller</p></li><li><p>MVP：Model，View，Presenter</p></li><li><p>MVVM：Model，View，ViewModel</p></li></ul><blockquote><p>架构差异</p></blockquote><ul><li><p>MVC：Controller通常为Activity，将包含数据处理与逻辑业务，但该模式中Activity既充当着View与Controller角色，将导致代码极度耦合。</p></li><li><p>MVP：Presenter 持有 View接口，不直接操作View，并在其中执行业务操作，可将视图操作与业务逻辑解耦，使 Activity 成为 真正View层</p></li></ul><blockquote><p>MVVM</p></blockquote><p>Model：实体模型。</p><p>View：对应于Activity和XML，负责View的绘制以及用户交互。</p><p>ViewModel：负责完成View与Model间的交互，负责业务逻辑。</p><hr><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><p>常见的 Lifecycle 组件用法是通过其提供的观察者模式，将生命周期的复杂操作进行封装，开发者只需在视图控制器（配合ViewBinding或DataBinding使用）中注册生命周期持有者，即可优雅完成对当前 Activity 或 Fragment 生命周期控制。</p><hr><h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p>LiveData的出现主要是为了帮助开发者遵循 “通过唯一可信源分发状态” 的标准化开发理念。</p><p>通过与Lifecycle配合使用，以观察者模式将Ui与数据动态解耦，使Ui能动态响应数据变化，LiveData仅在当前状态为 STARTED 或 RESUMED 时才会通知 Ui 进行更新。</p><blockquote><p>LiveData 带来的优点：</p></blockquote><ul><li><p>确保 Ui 与数据始终保持一致：LiveData 将时刻关注被赋予 Observer 的对象，当你的数据发生变化时，无需手动对 Ui 进行重绘，LiveData将自动通知 Ui 更新数据。</p></li><li><p>减少内存泄漏：由于 Observer 对象的生命周期与当前 Activity 或 Fragment绑定，LiveData将自动对已进入 Destroyed 状态的对象进行清理，从而减少不必要的内存泄漏。若当前 Activity 或 Fragment 在栈区中处于不活跃状态，LiveData则不会接收任何对于数据的更新直到绑定对象重新位于前台活跃状态。</p></li><li><p>减少通过人为手段对生命周期的管理监控：LiveData能够自动管理其绑定对象的生命周期，并在 App 处于前/后台状态时自动更新其状态。</p></li></ul><hr><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><hr><h3 id="ViewBinding-DataBinding"><a href="#ViewBinding-DataBinding" class="headerlink" title="ViewBinding / DataBinding"></a>ViewBinding / DataBinding</h3><blockquote><p>与使用 findViewById 相比，视图绑定（ViewBinding）具有一些很显著的优点：</p></blockquote><ul><li><p>Null 安全：由于视图绑定会创建对视图的直接引用，因此不存在因视图 ID 无效而引发 Null 指针异常的风险。此外，如果视图仅出现在布局的某些配置中，则绑定类中包含其引用的字段会使用 @Nullable 标记。</p></li><li><p>类型安全：每个绑定类中的字段均具有与它们在 XML 文件中引用的视图相匹配的类型。这意味着不存在发生类转换异常的风险。<br>这些差异意味着布局和代码之间的不兼容将会导致构建在编译时（而非运行时）失败。</p></li></ul><blockquote><p>与数据绑定的对比</p></blockquote><p>视图绑定和数据绑定均会生成可用于直接引用视图的绑定类。但是，视图绑定旨在处理更简单的用例，与数据绑定相比，具有以下优势：</p><ul><li><p>更快的编译速度：视图绑定不需要处理注释，因此编译时间更短。</p></li><li><p>易于使用：视图绑定不需要特别标记的 XML 布局文件，因此在应用中采用速度更快。在模块中启用视图绑定后，它会自动应用于该模块的所有布局。</p></li></ul><blockquote><p>反过来，与数据绑定（DataBinding）相比，视图绑定也具有以下限制：</p></blockquote><ul><li><p>视图绑定不支持布局变量或布局表达式，因此不能用于直接在 XML 布局文件中声明动态界面内容。</p></li><li><p>视图绑定不支持双向数据绑定。</p></li></ul><blockquote><p>考虑到这些因素，在某些情况下，最好在项目中同时使用视图绑定和数据绑定。您可以在需要高级功能的布局中使用数据绑定，而在不需要高级功能的布局中使用视图绑定。</p></blockquote><hr><h3 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h3><p>与 IOS开发 中的故事板一样，Jetpack为<code>导航</code>提供Navigation组件以管控各页面间的关联跳转。使用了 Navigation组件 构建的App通常需要有一个其实目的地，在应用中，<code>back操作</code> 与 <code>pop up操作</code>将会起到一样的作用。</p><blockquote><p>导航组件提供各种其他优势，包括以下内容：</p></blockquote><ul><li><p>处理 Fragment 事务。</p></li><li><p>默认情况下，正确处理往返操作。</p></li><li><p>为动画和转换提供标准化资源。</p></li><li><p>实现和处理深层链接。</p></li><li><p>包括导航界面模式（例如抽屉式导航栏和底部导航），用户只需完成极少的额外工作。</p></li><li><p>Safe Args - 可在目标之间导航和传递数据时提供类型安全的 Gradle 插件。</p></li><li><p>ViewModel 支持 - 您可以将 ViewModel 的范围限定为导航图，以在图表的目标之间共享与界面相关的数</p></li></ul><hr><h3 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h3><p>任务管理。</p><hr><h3 id="ROOM"><a href="#ROOM" class="headerlink" title="ROOM"></a>ROOM</h3><p>Room 持久性库在 SQLite 的基础上提供了一个抽象层，让用户能够在充分利用 SQLite 的强大功能的同时，获享更强健的数据库访问机制。</p><blockquote><p>具体来说，ROOM具有以下优势：</p></blockquote><ul><li><p>针对 SQL 查询的编译时验证。</p></li><li><p>可最大限度减少重复和容易出错的样板代码的方便注解。</p></li><li><p>简化了数据库迁移路径。</p></li></ul><blockquote><p>ROOM 概览</p></blockquote><ul><li>Entity</li></ul><p>ROOM 使用 @Entity 注解对类进行标识，数据实体通常为数据库中的一行，如常见的 User实体，通常会包括含<code>主键id</code>在内的姓名，昵称，出生日期，性别等列属性。</p><p>对于<code>主键</code>，可使用 @PrimaryKey 对其进行标注，并使用 unique属性 指定唯一性；</p><p>对于<code>列属性</code>，可使用 @ColumInfo 对其进行标注，并通过 name属性 指定别名。</p><ul><li>Dao</li></ul><p>数据访问对象（Data Access Object），开发者可通过使用 Dao，对数据实体以及数据库进行交互，包括常见的 CURD操作。</p><p>常见的<code>Dao注解</code>有：@Insert，@Update, @Delete，@Query</p><ul><li>Database</li></ul><p>在使用数据库之前通常需要对数据库实例进行初始化，这一操作最好在 ViewModel 中进行，通过与 ViewModel 进行生命周期绑定，使其能与 整体App 生命周期统一管理。</p><p>通过继承 RoomDatabase 并进行单例操作，以创建全局唯一数据库实例。</p><blockquote><p>局限性</p></blockquote><p>由于数据库操作通常是耗时操作，Google Android官方不推荐将 ROOM 直接应用于主线程中，而是以异步的形式在后台进行数据处理，通常配合 AsyncTask 进行异步使用。</p><hr><h3 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h3><p>通过与ROOM进行配合，Paging库 能轻松对所接受数据进行分页。</p><hr><h3 id="Jetpack-Compose"><a href="#Jetpack-Compose" class="headerlink" title="Jetpack Compose"></a>Jetpack Compose</h3><p>声明式 Ui 组件库</p><hr><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/flutter.png" alt="Flutter"></p><blockquote><p>优势</p></blockquote><ul><li><p>编译为本地机器码，支持跨平台，代码简洁。</p></li><li><p>与使用 JavaScript 的React-Native 对比，性能更高效且支持更多平台。</p></li></ul><hr><blockquote><p>层级</p></blockquote><ul><li><p>Framework：Dart层，为 Dart 上级Api 提供支持。</p></li><li><p>Engine：引擎层，包含 Skia、Dart 和 Text。</p></li><li><p>Embedder：嵌入层，使 Flutter 能嵌入到任何平台。</p></li></ul><hr><blockquote><p>为什么使用 Dart</p></blockquote><ul><li><p>DartVM 可编译为 ARM代码，直接运行在硬件上。</p></li><li><p>使用isolate实现多线程，且不共享内存，可实现无锁快速分配。</p></li><li><p>线性指针，保证内存线性增长。</p></li><li><p>底层为 OpenGL绘制库，先调用OpenGL 后调用操作系统API，性能接近原生渲染。</p></li></ul><hr><h3 id="混合开发"><a href="#混合开发" class="headerlink" title="混合开发"></a>混合开发</h3><p><a href="https://flutter.cn/docs/development/add-to-app">将 Flutter 集成到现有应用 • Flutter.cn</a></p><hr><h2 id="第三方库（Android）"><a href="#第三方库（Android）" class="headerlink" title="第三方库（Android）"></a>第三方库（Android）</h2><h3 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h3><p>Google官方出品的异步请求框架，2013年发布，适合数据量小，通信量大的发布。</p><ul><li>步骤1：创建 RequestQueue请求队列</li></ul><p>请求队列通常只需要生成一个，可使用单例模式进行创建，进行高并发请求。</p><pre><code class="java">public class VolleyUtils &#123;    private static RequestQueue requestQueue;    public static synchronized RequestQueue getInstance(Context context) &#123;        if (requestQueue == null) &#123;            requestQueue = Volley.newRequestQueue(context.getApplicationContext());        &#125;        return requestQueue;    &#125;&#125;</code></pre><hr><ul><li>步骤2：创建 StringRequest请求对象</li></ul><pre><code class="java">StringRequest request = new StringRequest(requestUrl, response -&gt; &#123;            // success        &#125;, error -&gt; &#123;            // failure        &#125;);</code></pre><hr><ul><li>步骤3：向 RequestQueue请求队列 中添加 StringRequest请求对象</li></ul><pre><code class="java">VolleyUtils.getInstance(context).add(request);</code></pre><hr><blockquote><p>源码分析</p></blockquote><ul><li><p>CacheDispatcher：内部就是一个线程，开启子线程的缓存请求队列，while时刻运行网络请求。首次操作会先从本地判断是否存在缓存，如果有则直接从缓存中获取，否则直接走NetworkDispatcher</p></li><li><p>NetworkDispatcher：内部也是一个线程，开启网络请求队列，while时刻运行网络请求。首次操作会先从CacheDispatcher中判断是否存在缓存，有的话则走CacheDispatcher，若无缓存或缓存过期则会新建一个请求，并将响应回传主线程。</p></li><li><p>ResponseDelivery：响应分发器，对响应进行分发回传。</p></li></ul><hr><h3 id="okHttp"><a href="#okHttp" class="headerlink" title="okHttp"></a>okHttp</h3><ul><li>步骤1：创建 okHttp Client</li></ul><pre><code class="java">private final OkHttpClient _client = new OkHttpClient();</code></pre><hr><ul><li>步骤2： 建立请求</li></ul><p>Builder模式：将一个复杂对象的构建与表示相分离。</p><pre><code class="java">Request request = new Request.Builder().url(&quot;you url&quot;).build();</code></pre><hr><ul><li>步骤3：执行请求（<code>同步</code>请求）</li></ul><p>阻塞当前线程获取数据。</p><pre><code class="java">OkHttp3.Response response = _client.newCall(request).execute()</code></pre><blockquote><p>OR</p></blockquote><ul><li>步骤3：执行请求（<code>异步</code>请求）</li></ul><pre><code class="java">_client.newCall(request).enqueue(  new Callback()&#123;    @Override    public void onFailure(Call call, IOException e)&#123;       // handle error      return e.printStackTrace();      &#125;    @Override    public void onResponse(Call call, okhttp3.Response response) throw IOException&#123;      // get response      System.out.println(response.body().string())    &#125;  &#125;)</code></pre><hr><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Android/okhttp_interceptors.png" alt="拦截器" style="zoom:50%;" /><blockquote><p>拦截器（同步请求）</p></blockquote><p>将以下拦截器进行逐次调用，形成链条。</p><ul><li><p>retryAndFollowUpInterceptor：失败重试，重定向。</p></li><li><p>BridgeInterceptor：将用户构造的请求转换为服务器请求，并将服务器响应转化为用户易于查看的响应，起桥接作用。</p></li><li><p>CacheInterceptor：缓存拦截器，负责读取或更新缓存。</p></li><li><p>ConnectInterceptor：负责与服务端进行连接。</p></li><li><p>CallServerInterceptor：负责网络端进行连接。</p></li></ul><hr><blockquote><p>拦截器（异步请求）</p></blockquote><p>dispatcher().enqueue()方法中：</p><ul><li><p>readyAsyncCalls：正在准备的一些异步请求。</p></li><li><p>runningAsyncCalls：正在运行的异步请求。</p></li><li><p>runningSyncCalls：正在运行的同步请求。</p></li></ul><p>内部会开启几个线程池，任务在后台执行。</p><hr><blockquote><p>事件</p></blockquote><table><thead><tr><th><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Android/okhttp_events.png" alt="基本事件"></th><th><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Android/okhttp_events_with_failures.png" alt="基本事件 + 失败事件"></th><th><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Android/okhttp_events_with_failures_and_retries.png" alt="基本事件 + 失败事件 + 重试事件"></th></tr></thead></table><hr><h3 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h3><p>Json解析。</p><hr><h3 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h3><p>图像解析。</p><hr><h3 id="GreenDao"><a href="#GreenDao" class="headerlink" title="GreenDao"></a>GreenDao</h3><p>ORM数据库。</p><hr><h3 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h3><p>内存泄漏检测。</p><hr><h2 id="第三方库（Flutter）"><a href="#第三方库（Flutter）" class="headerlink" title="第三方库（Flutter）"></a>第三方库（Flutter）</h2><h3 id="dio"><a href="#dio" class="headerlink" title="dio"></a>dio</h3><p>网络请求。</p><p><a href="https://github.com/flutterchina/dio">Github • Dio</a></p><hr><h3 id="GetX"><a href="#GetX" class="headerlink" title="GetX"></a>GetX</h3><p>状态管理、依赖注入。</p><p><a href="https://github.com/jonataslaw/getx">Github • GetX</a></p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.android.google.cn/jetpack">Android for Developer • Jetpack</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TnesorFlow-GPU • Initialization</title>
      <link href="TnesorFlow-Gpu-Initialization/"/>
      <url>TnesorFlow-Gpu-Initialization/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote><p>本篇将介绍我在我的笔记本上部署有关<code>TensorFlow-GPU</code>时的一些笔记分享。</p></blockquote><p>本文将着重介绍在<code>Windows</code>上的部署方案。</p><hr><h2 id="获取-Nvidia-相关开发组件"><a href="#获取-Nvidia-相关开发组件" class="headerlink" title="获取 Nvidia 相关开发组件"></a>获取 Nvidia 相关开发组件</h2><p><a href="https://developer.nvidia.com/cuda-gpus">支持 CUDA 的显卡列表</a></p><blockquote><p>CUDA 与 cuDNN 有着<code>严格的版本规定</code>，建议在部署前核查好版本。</p></blockquote><p>我的部署版本为：<code>CUDA v11.5</code> + <code>cuDNN v8.3.3</code></p><ul><li>CUDA</li></ul><p><a href="https://developer.nvidia.com/cuda-toolkit-archive">Download CUDA Toolkit</a></p><p><a href="https://docs.nvidia.com/cuda/cuda-installation-guide-microsoft-windows/index.html">Nvidia • CUDA Toolkit Documentation</a></p><ul><li>cuDNN（需登录 Nvidia 账号）</li></ul><p><a href="https://developer.nvidia.com/cudnn">Download cuDNN</a></p><p><a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html#install-windows">Nvidia • cuDNN Documentation</a></p><ul><li>ZLIB</li></ul><p><a href="http://www.winimage.com/zLibDll/zlib123dllx64.zip">Download ZLIB</a></p><blockquote><p>将zlibwapi.dll所在文件夹添加到系统变量。</p></blockquote><hr><h2 id="迁移关键文件"><a href="#迁移关键文件" class="headerlink" title="迁移关键文件"></a>迁移关键文件</h2><p>针对该步骤，Nvidia 官方文档中的描述如下：</p><ul><li><p>a. Copy <installpath>\cuda\bin\cudnn*.dll to C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\vx.x\bin.</p></li><li><p>b. Copy <installpath>\cuda\include\cudnn*.h to C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\vx.x\include.</p></li><li><p>c. Copy <installpath>\cuda\lib\x64\cudnn*.lib to C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\vx.x\lib\x64.</p></li></ul><hr><h3 id="添加系统变量"><a href="#添加系统变量" class="headerlink" title="添加系统变量"></a>添加系统变量</h3><ul><li><p>变量键: CUDA_PATH</p></li><li><p>变量值: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\vx.x</p></li></ul><hr><h2 id="终端核验"><a href="#终端核验" class="headerlink" title="终端核验"></a>终端核验</h2><ul><li>我的CUDA安装位置：C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.5\extras\demo_suite</li></ul><blockquote><p>nvcc -V</p></blockquote><pre><code class="powershell">PS C:\Users\P7XXTM1-G&gt; nvcc -Vnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2021 NVIDIA CorporationBuilt on Mon_Sep_13_20:11:50_Pacific_Daylight_Time_2021Cuda compilation tools, release 11.5, V11.5.50Build cuda_11.5.r11.5/compiler.30411180_0</code></pre><blockquote><p>deviceQuery.exe</p></blockquote><pre><code class="powershell">PS C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.5\extras\demo_suite&gt; .\deviceQuery.exeC:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.5\extras\demo_suite\deviceQuery.exe Starting... CUDA Device Query (Runtime API) version (CUDART static linking)Detected 1 CUDA Capable device(s)Device 0: &quot;NVIDIA GeForce GTX 1060&quot;  CUDA Driver Version / Runtime Version          11.6 / 11.5  CUDA Capability Major/Minor version number:    6.1  Total amount of global memory:                 6144 MBytes (6442254336 bytes)  (10) Multiprocessors, (128) CUDA Cores/MP:     1280 CUDA Cores  GPU Max Clock rate:                            1771 MHz (1.77 GHz)  Memory Clock rate:                             4004 Mhz  Memory Bus Width:                              192-bit  L2 Cache Size:                                 1572864 bytes  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers  Total amount of constant memory:               zu bytes  Total amount of shared memory per block:       zu bytes  Total number of registers available per block: 65536  Warp size:                                     32  Maximum number of threads per multiprocessor:  2048  Maximum number of threads per block:           1024  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)  Maximum memory pitch:                          zu bytes  Texture alignment:                             zu bytes  Concurrent copy and kernel execution:          Yes with 1 copy engine(s)  Run time limit on kernels:                     Yes  Integrated GPU sharing Host Memory:            No  Support host page-locked memory mapping:       Yes  Alignment requirement for Surfaces:            Yes  Device has ECC support:                        Disabled  CUDA Device Driver Mode (TCC or WDDM):         WDDM (Windows Display Driver Model)  Device supports Unified Addressing (UVA):      Yes  Device supports Compute Preemption:            Yes  Supports Cooperative Kernel Launch:            Yes  Supports MultiDevice Co-op Kernel Launch:      No  Device PCI Domain ID / Bus ID / location ID:   0 / 1 / 0  Compute Mode:     &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 11.6, CUDA Runtime Version = 11.5, NumDevs = 1, Device0 = NVIDIA GeForce GTX 1060Result = PASS</code></pre><hr><blockquote><p>bandwidthTest.exe</p></blockquote><pre><code class="powershell">PS C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.5\extras\demo_suite&gt; .\bandwidthTest.exe[CUDA Bandwidth Test] - Starting...Running on... Device 0: NVIDIA GeForce GTX 1060 Quick Mode Host to Device Bandwidth, 1 Device(s) PINNED Memory Transfers   Transfer Size (Bytes)        Bandwidth(MB/s)   33554432                     12440.9 Device to Host Bandwidth, 1 Device(s) PINNED Memory Transfers   Transfer Size (Bytes)        Bandwidth(MB/s)   33554432                     12180.1 Device to Device Bandwidth, 1 Device(s) PINNED Memory Transfers   Transfer Size (Bytes)        Bandwidth(MB/s)   33554432                     54242.5Result = PASSNOTE: The CUDA Samples are not meant for performance measurements. Results may vary when GPU Boost is enabled.</code></pre><hr><h2 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h2><p><a href="https://www.anaconda.com/">Download Anaconda</a></p><blockquote><p>对于需要管理多个Python开发环境的开发者来说，Anaconda为开发者提供开箱即用的开发环境，集成包括数据科学与机器学习在内的多个开发环境与开发组件，开发者可无需花费大量时间在部署开发环境上，大幅提高开发效率。</p></blockquote><hr><h3 id="新增一个本地环境"><a href="#新增一个本地环境" class="headerlink" title="新增一个本地环境"></a>新增一个本地环境</h3><p>Anaconda安装完成后，将会自带一个基于 Python 3.9.7 的基础开发环境，但此处我们不建议直接使用该基础环境。</p><blockquote><p>本文将新建一个基于 Python 3.9.11 的开发环境用于部署 TensorFlow-GPU。</p></blockquote><table><thead><tr><th><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/TensorFlow-GPU/Init-1.png" alt="步骤 1"></th><th><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/TensorFlow-GPU/Init-2.png" alt="步骤 2"></th></tr></thead></table><hr><h3 id="部署-TensorFlow-GPU"><a href="#部署-TensorFlow-GPU" class="headerlink" title="部署 TensorFlow-GPU"></a>部署 TensorFlow-GPU</h3><pre><code class="powershell">pip install tensorflow-gpu</code></pre><hr><h3 id="在-Jupyter-Notebook-中核验"><a href="#在-Jupyter-Notebook-中核验" class="headerlink" title="在 Jupyter Notebook 中核验"></a>在 Jupyter Notebook 中核验</h3><pre><code class="ipynb">import tensorflow as tfprint(tf.__version__)</code></pre><p>输出如下：</p><blockquote><p>2.8.0</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RL • PySC2</title>
      <link href="Hello-PySC2/"/>
      <url>Hello-PySC2/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇将介绍我在对<code>《星际争霸2》进行AI开发</code>的一些笔记分享。</p><p>相关代码已上传<a href="https://github.com/PhoenixNest/Hello-PySC2">Github</a>托管。</p></blockquote><hr><blockquote><p>开发环境与所需软件包</p></blockquote><ul><li><p>Windows 10</p></li><li><p>Python 3.9.9</p></li></ul><hr><pre><code class="python">pip install pysc2pip install burnysc2pip install opencv-contrib-pythonpip install tensorflow# pip install tensorflow-gpu</code></pre><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="游戏背景"><a href="#游戏背景" class="headerlink" title="游戏背景"></a>游戏背景</h3><p>《星际争霸2》（StarCraft2）是由暴雪娱乐在2010年7月27日推出的一款即时战略游戏，是《星际争霸》系列的第二部作品。游戏以三部曲的形式推出，即《星际争霸2：自由之翼》（Wings of Liberty）、《星际争霸2：虫群之心》（Heart of the Swarm）和《星际争霸2：虚空之遗》（Legacy of the Void）。游戏结构类似于《星际争霸》，主要的游戏技巧着重在资源上，玩家用采集的资源建造不同的建筑、军队并进行升级 。</p><p>《星际争霸》有着专业的职业赛事与选手选拔机制，其中不乏进入过早期有着“电子竞技奥运会”之称的WCG（World Cyber Games），官方赛事有着诸如：暴雪WCS（World Championship Series）世界锦标赛，ESL（Electronic Sports League）电子竞技联盟与GSL（Global StarCraft2 League）全球《星际争霸2》联赛等赛事。</p><center><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/PySC2/WCS.png" alt="WCS • World Championship Series"></center><hr><h3 id="DeepMind-•-AlphaStar"><a href="#DeepMind-•-AlphaStar" class="headerlink" title="DeepMind • AlphaStar"></a>DeepMind • AlphaStar</h3><p>2016年，继AlphaGo在韩国首尔击败顶尖棋手李世石后，DeepMind的下一个目标战场来到了《星际争霸2》，尝试在战略游戏领域挑战顶尖人类选手。次年，DeepMind开始在欧服天梯上放出自己开发的人工智能AI，开始在PVP实战中训练AI。</p><p>时间转到2019年，在DeepMind的人工智能登顶星际争霸最高天梯级别（宗师）后，DeepMind释出了AlphaStar，一个专精于星灵（神族）的人工智能AI，并于1月首次公开挑战来自Team Liquid的职业选手Mana与TLO，结果也如DeepMind所愿，AlphaStar仅仅输了两局，便击败了这两位欧洲职业选手。</p><p>籍此，AlphaStar的胜利将AI的可能性再度拔高，并在《Nature》发表<a href="https://www.nature.com/articles/s41586-019-1724-z.epdf?author_access_token=lZH3nqPYtWJXfDA10W0CNNRgN0jAjWel9jnR3ZoTv0PSZcPzJFGNAZhOlk4deBCKzKm70KfinloafEF1bCCXL6IIHHgKaDkaTkBcTEv7aT-wqDoG1VeO9-wO3GEoAMF9bAOt7mJ0RWQnRVMbyfgH9A==">相关论文</a>。</p><table><thead><tr><th><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/PySC2/DeepMind.png" alt="Deepmind"></th><th><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/PySC2/AlphaStar.gif" alt="AlphaStar"></th></tr></thead></table><hr><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>本文使用 Anaconda + PyCharm 的开发环境对Ai进行编码。</p><ul><li><p>Anaconda为大数据与人工智能开发者提供了开箱即用的工具包，使开发者无需在环境配置方面花费大量无用时间，并对原型进行快速编写；</p></li><li><p>在神经网络框架方面，使用Google的TensorFlow框架对模型进行编码；</p></li><li><p>开发使用IDE方面，采用了JetBrains的PyCharm辅以开发上的智能协助；</p></li></ul><blockquote><p>主要软件包及版本：</p></blockquote><ul><li><p>Python：3.9</p></li><li><p>PySC2：3.0.0</p></li><li><p>BurnySC2：5.0.12</p></li><li><p>TensorFlow-GPU：2.7.0</p></li></ul><hr><h2 id="Ai设计"><a href="#Ai设计" class="headerlink" title="Ai设计"></a>Ai设计</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在《星际争霸2》中，整个系统分为自然资源与人口（最高200）两种主要的资源，自然资源包括晶体矿与瓦斯，而人口则包括了采集单位人口与战斗单位人口；在对战方面，大量的职业联赛也为其带来了数不胜数的战术选择。</p><p>即时战略具有高度可变性与不确定性，通常的建筑都需要晶体矿，而对于科技建筑与科技升级，则往往需要额外的瓦斯支出；在人口方面，过量的采集单位会使战斗人口较少而导致正面军队疲软，而低效的采集单位占比则往往会导致后续战局中缓慢的经济收入，无法快速弥补前线战斗导致的战损与及时的攀升科技；战术选择方面，早期偏激的战术在可能的带来高收益（挫败对手采集单位，延缓其经济收入甚至一击制胜）的同时往往也带来高风险，若该战术被对手成功防下，优势将如滚雪球似伴随整场比赛，胜者可能易主；在操作方面，高质量的兵种搭配将为整只部队带来极大的人口优势，同人口下的高级兵种与低级兵种战斗中往往能出现以少胜多的局面。</p><p>合理的分配当前所采集到的资源并将其转化为单位，协调采集人口与战斗人口的占比，对当前战况进行分析并制定采取下一步行动，对现有兵种进行合理搭配与操作，是Ai设计中的一大挑战。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://sc2ai.net/">sc2ai.net</a></p></li><li><p><a href="https://eschamp.discourse.group/">Eschamp</a></p></li><li><p><a href="https://github.com/deepmind/pysc2">Deepmind-PySC2</a></p></li><li><p><a href="https://burnysc2.github.io/python-sc2/docs/index.html">Burnysc2-Python-Index</a></p></li><li><p><a href="https://lotv.spawningtool.com/">Spawning Tool: StarCraft 2 Build Orders</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter • Initialization</title>
      <link href="Flutter-Initialization/"/>
      <url>Flutter-Initialization/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇将介绍我在学习有关<code>Flutter</code>时的一些笔记分享。</p></blockquote><blockquote><p>Flutter是 Google 的移动UI框架，可以快速在 iOS 和 Android 上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p></blockquote><blockquote><p><strong>为什么</strong>使用 Flutter ：</p><ul><li><p>快速开发 - 毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。</p></li><li><p>富有表现力和灵活的UI - 快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。</p></li><li><p>富有表现力和灵活的UI - Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。</p></li></ul></blockquote><hr><h2 id="获取-Flutter-SDK"><a href="#获取-Flutter-SDK" class="headerlink" title="获取 Flutter SDK"></a>获取 Flutter SDK</h2><p><a href="https://flutter.dev/docs/get-started/install">Get the Flutter SDK</a></p><blockquote><p>下载完成后解压到任意位置。</p></blockquote><hr><h2 id="安装-Android-Studio"><a href="#安装-Android-Studio" class="headerlink" title="安装 Android Studio"></a>安装 Android Studio</h2><p><a href="https://developer.android.google.cn/studio?hl=zh-cn">Download Android Studio and SDK tools  |  Android Developers</a></p><p><code>Android Studio</code> 将用于下载 <code>Android SDK</code> 与 <code>Flutter</code> &amp;&amp; <code>Dart</code> 两个插件。</p><blockquote><p>插件的下载在 Android Studio 的 Setting - Plugins中，搜索 Flutter 并点击 Install，期间会提示捆绑下载 Dart 插件，两个都下载即可。</p></blockquote><hr><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><blockquote><p>将刚才解压的 flutter 文件路径添加到系统变量的 Path 变量中。</p></blockquote><ul><li>例：D:\flutter\bin</li></ul><hr><h3 id="配置-Flutter-环境变量"><a href="#配置-Flutter-环境变量" class="headerlink" title="配置 Flutter 环境变量"></a>配置 Flutter 环境变量</h3><blockquote><p>在系统变量中新建两个值。</p></blockquote><ul><li><p>PUB_HOSTED_URL = <a href="https://pub.flutter-io.cn/">https://pub.flutter-io.cn</a></p></li><li><p>FLUTTER_STORAGE_BASE_URL = <a href="https://storage.flutter-io.cn/">https://storage.flutter-io.cn</a></p></li></ul><hr><h3 id="配置-Android-SDK-环境变量"><a href="#配置-Android-SDK-环境变量" class="headerlink" title="配置 Android SDK 环境变量"></a>配置 Android SDK 环境变量</h3><blockquote><p>SDK 下载完毕后，在系统变量中新建 ANDROID_HOME 变量，将 SDK 的地址填入即可。</p></blockquote><ul><li>ANDROID_HOME = D:\Android\Android SDK</li></ul><hr><h3 id="配置-Android-toolchain"><a href="#配置-Android-toolchain" class="headerlink" title="配置 Android toolchain"></a>配置 Android toolchain</h3><p><code>Android toolchain</code> 将用于<code>证书许可</code>。</p><p>将 Android SDK 配置到环境变量中后，终端执行：</p><pre><code class="bash">flutter doctor --android-licenses</code></pre><p>根据提示，输入 y ，直到全部许可都得到授权。</p><hr><h3 id="flutter-doctor"><a href="#flutter-doctor" class="headerlink" title="flutter doctor"></a>flutter doctor</h3><p>所有配置完成后，终端执行</p><pre><code class="bash">flutter doctor</code></pre><p>最终结果如下，</p><pre><code class="bash">Doctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel beta, 2.2.0-10.3.pre, on Microsoft Windows [Version 10.0.19043.1023], locale zh-CN)[✓] Android toolchain - develop for Android devices (Android SDK version 30.0.3)[✓] Android Studio (version 4.2.1)[✓] IntelliJ IDEA Ultimate Edition (version 2021.1)[✓] Connected device (2 available)! No issues found!</code></pre><hr><h2 id="Apple-macOS"><a href="#Apple-macOS" class="headerlink" title="Apple macOS"></a>Apple macOS</h2><h3 id="通过终端编辑配置文件"><a href="#通过终端编辑配置文件" class="headerlink" title="通过终端编辑配置文件"></a>通过终端编辑配置文件</h3><blockquote><p>这里使用 vim 进行编辑。</p></blockquote><pre><code class="bash">vim ~/.bash_profile</code></pre><hr><h3 id="配置-Flutter-环境变量-1"><a href="#配置-Flutter-环境变量-1" class="headerlink" title="配置 Flutter 环境变量"></a>配置 Flutter 环境变量</h3><pre><code class="bash">export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn# 这里的 hackintosh 改为你的 macOS 用户名export PATH=/Users/hackintosh/flutter/bin:$PATH</code></pre><hr><h3 id="配置-Android-SDK-环境变量-1"><a href="#配置-Android-SDK-环境变量-1" class="headerlink" title="配置 Android SDK 环境变量"></a>配置 Android SDK 环境变量</h3><pre><code class="bash"># 这里的 hackintosh 改为你的 macOS 用户名export ANDROID_HOME=&quot;/Users/hackintosh/Library/Android/sdk&quot;export PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-tools</code></pre><blockquote><p>保存上述配置</p></blockquote><pre><code class="bash">source ~/.bash_profile</code></pre><hr><h3 id="配置-Android-toolchain-1"><a href="#配置-Android-toolchain-1" class="headerlink" title="配置 Android toolchain"></a>配置 Android toolchain</h3><p><code>Android toolchain</code> 将用于<code>证书许可</code>。</p><p>将 Android SDK 配置到环境变量中后，终端执行：</p><pre><code class="bash">flutter doctor --android-licenses</code></pre><p>根据提示，输入 y ，直到全部许可都得到授权。</p><hr><h3 id="flutter-doctor-1"><a href="#flutter-doctor-1" class="headerlink" title="flutter doctor"></a>flutter doctor</h3><p>所有配置完成后，终端执行</p><pre><code class="bash">flutter doctor</code></pre><p>最终结果如下，</p><pre><code class="bash">Doctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel beta, 2.2.0, on Mac OS X 10.13.6 17G14042 darwin-x64, locale zh-Hans-CN)[✓] Android toolchain - develop for Android devices (Android SDK version 30.0.3)[!] Xcode - develop for iOS and macOS    ✗ Xcode installation is incomplete; a full installation is necessary for iOS development.      Download at: https://developer.apple.com/xcode/download/      Or install Xcode via the App Store.      Once installed, run:        sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer        sudo xcodebuild -runFirstLaunch[✓] Chrome - develop for the web[✓] Android Studio (version 4.2)[✓] IntelliJ IDEA Ultimate Edition (version 2021.1.1)[✓] VS Code (version 1.56.2)[!] Proxy Configuration    ! NO_PROXY is not set[✓] Connected device (1 available)! Doctor found issues in 2 categories.</code></pre><blockquote><p>由于我的机器是黑苹果，且止步于 macOS 10.13.6，无法向上升级（10.14以上不支持 Nvidia 显卡），无法下载 Xcode<br>有能力的读者可以购买白果，或者自行组一台 AMD 的黑苹果，即可解决 Xcode 的系统版本限制问题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Cross Platform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="Docker-Manual/"/>
      <url>Docker-Manual/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇整理了我学习<code>Docker</code>时的一些笔记。<br>部署环境：Windows 10 Professional Workstation</p></blockquote><blockquote><p>Docker 是 PaaS 提供商 dotCloud 开源的一个基于 LXC 的高级容器引擎，源代码托管在 Github 上, 基于go语言并遵从Apache2.0协议开源。<br>Docker自2013年以来非常火热，无论是从 github 上的代码活跃度，还是Redhat在RHEL6.5中集成对Docker的支持, 就连 Google 的 Compute Engine 也支持 docker 在其之上运行。</p><ul><li><strong>环境管理复杂</strong> - 从各种OS到各种中间件到各种app, 一款产品能够成功作为开发者需要关心的东西太多，且难于管理，这个问题几乎在所有现代IT相关行业都需要面对。</li><li><strong>云计算时代的到来</strong> - AWS的成功, 引导开发者将应用转移到 cloud 上, 解决了硬件管理的问题，然而中间件相关的问题依然存在 (所以openstack HEAT和 AWS cloudformation 都着力解决这个问题)。开发者思路变化提供了可能性。</li><li><strong>虚拟化手段的变化</strong> - cloud 时代采用标配硬件来降低成本，采用虚拟化手段来满足用户按需使用的需求以及保证可用性和隔离性。然而无论是KVM还是Xen在 docker 看来,都在浪费资源，因为用户需要的是高效运行环境而非OS, GuestOS既浪费资源又难于管理, 更加轻量级的LXC更加灵活和快速</li><li><strong>LXC的移动性</strong> - LXC在 linux 2.6 的 kernel 里就已经存在了，但是其设计之初并非为云计算考虑的，缺少标准化的描述手段和容器的可迁移性，决定其构建出的环境难于迁移和标准化管理(相对于KVM之类image和snapshot的概念)。docker 就在这个问题上做出实质性的革新。这是docker最独特的地方。<br>面对上述几个问题，docker设想是交付运行环境如同海运，OS如同一个货轮，每一个在OS基础上的软件都如同一个集装箱，用户可以通过标准化手段自由组装运行环境，同时集装箱的内容可以由用户自定义，也可以由专业人员制造。这样，交付一个软件，就是一系列标准化组件的集合的交付，如同乐高积木，用户只需要选择合适的积木组合，并且在最顶端署上自己的名字(最后一个标准化组件是用户的app)。这也就是基于docker的PaaS产品的原型。</li></ul></blockquote><hr><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><ul><li><p><a href="https://www.docker.com/">Docker</a></p></li><li><p><a href="https://docs.docker.com/">Docker • Docs</a></p></li><li><p><a href="https://docs.docker.com/get-docker/">Install Docker</a></p></li></ul><hr><h3 id="Docker-vs-VM"><a href="#Docker-vs-VM" class="headerlink" title="Docker vs VM"></a>Docker vs VM</h3><ul><li><p><a href="https://www.zhihu.com/question/48174633">Docker容器与虚拟机有什么区别？</a></p></li><li><p><a href="https://blog.csdn.net/qq_40576301/article/details/94482901">关于Docker与vm虚拟机的比较及优缺点</a></p></li></ul><blockquote><p><strong>优点</strong></p></blockquote><ul><li><p><strong>配置快</strong> - 提供独立的开发环境，便于开发， 由于 Docker 可以在各种各样的环境中使用，而基础架构不要求与应用程序的环境相关联，因此不存在兼容性问题。</p></li><li><p><strong>提高工作效率</strong> - 这是一种类似于集装箱的概念，在开发之初就将项目放到一个类似于集装箱的独立环境进行开发，到部署的时候只是部署集装箱环境，而集装箱环境已经被所有的系统指定了统一标准，不存在兼容问题，所以可以提高工作效率。</p></li><li><p><strong>应用隔离</strong> - Docker 提供用于在隔离环境中运行应用程序的容器。每个容器都是独立，并允许执行任何类型的应用程序，并且不存在入侵和病毒感染的问题，甚至可以使用沙箱进行病毒隔离。</p></li><li><p><strong>云集</strong> - 它是 Docker 容器的集群和调度工具。 Swarm 使用 Docker API作为其前端，这有助于我们使用各种工具来控制它。 它还可以将 Docker 主机集群控制为一个虚拟主机。 这是一个用于启用可插拔后端的自组织引擎组。</p></li><li><p><strong>路由网</strong> - 它能够将可用节点上已发布端口的传入请求路由到活动容器，实现连接。</p></li><li><p><strong>服务</strong> - 服务是允许指定集群内的容器状态的任务列表。 每个任务表示一个应该运行的容器的一个实例，并且 Swarm 在节点之间调度它们。</p></li><li><p><strong>安全管理</strong> - 安全性和管理应当是一个高优先级的考虑因素;企业用户不应再把它们当作应用程序迁移至容器的最后一步。反之，企业必须从一开始就做好安全性和管理的规划，把它们的功能纳入应用程序的开发过程中，并在应用程序运行过程中积极主动地关注这些方面。</p></li></ul><blockquote><p><strong>局限</strong></p></blockquote><ul><li><p>Docker 是基于 Linux64 bit的，<strong>无法</strong>在 32bit 的 Linux/Windows/unix环境下使用。</p></li><li><p>LXC 是基于 cgroup等 linux kernel 功能的，因此container的 guest 系统<strong>只能</strong>是 linux base 的。</p></li><li><p>隔离性相比KVM之类的虚拟化方案还是<strong>有些欠缺</strong>，所有 container 公用一部分的运行库。</p></li><li><p><strong>网络管理相对简单</strong>，主要是基于 namespace 隔离，cgroup 的 cpu 和 cpuset 提供的cpu功能相比 KVM 的等虚拟化方案相比难以度量（所以 Dotcloud 主要是按内存收费）。</p></li><li><p>Docker 对 disk 的<strong>管理比较有</strong>限，container 随着用户进程的停止而销毁，container 中的 log 等<strong>用户数据不便收集</strong>。</p></li></ul><hr><h3 id="Welcome-To-Docker"><a href="#Welcome-To-Docker" class="headerlink" title="Welcome To Docker"></a>Welcome To Docker</h3><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/</code></pre><hr><h2 id="Docker-帮助命令"><a href="#Docker-帮助命令" class="headerlink" title="Docker 帮助命令"></a>Docker 帮助命令</h2><h3 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h3><blockquote><p>查看 Docker 版本信息。</p></blockquote><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker versionClient: Docker Engine - Community Cloud integration: 1.0.9 Version:           20.10.5 API version:       1.41 Go version:        go1.13.15 Git commit:        55c4c88 Built:             Tue Mar  2 20:14:53 2021 OS/Arch:           windows/amd64 Context:           default Experimental:      trueServer: Docker Engine - Community Engine:  Version:          20.10.5  API version:      1.41 (minimum version 1.12)  Go version:       go1.13.15  Git commit:       363e9a8  Built:            Tue Mar  2 20:15:47 2021  OS/Arch:          linux/amd64  Experimental:     false......</code></pre><hr><h3 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a>docker info</h3><blockquote><p>查看 Docker 信息。</p></blockquote><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker infoClient: Context:    default Debug Mode: false Plugins:  app: Docker App (Docker Inc., v0.9.1-beta3)  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)  scan: Docker Scan (Docker Inc., v0.5.0)Server: Containers: 2  Running: 0  Paused: 0  Stopped: 2 Images: 2 Server Version: 20.10.5 Storage Driver: overlay2  Backing Filesystem: extfs  Supports d_type: true  Native Overlay Diff: true Logging Driver: json-file Cgroup Driver: cgroupfs Cgroup Version: 1 Plugins:  Volume: local  Network: bridge host ipvlan macvlan null overlay  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog Swarm: inactive Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc Default Runtime: runc Init Binary: docker-init containerd version: 269548fa27e0089a8b8278fc4fc781d7f65a939b runc version: ff819c7e9184c13b7c2607fe6c30ae19403a7aff init version: de40ad0 Security Options:  seccomp   Profile: default Kernel Version: 5.4.72-microsoft-standard-WSL2 Operating System: Docker Desktop OSType: linux Architecture: x86_64 CPUs: 6 Total Memory: 12.44GiB Name: docker-desktop ID: LJH4:2VZK:AH4N:WRBD:A27I:KKRD:IWQP:C4ML:D753:TVQD:53ES:YECZ Docker Root Dir: /var/lib/docker Debug Mode: false Registry: https://index.docker.io/v1/ Labels: Experimental: false Insecure Registries:  127.0.0.0/8 Registry Mirrors:  https://w3z80w3y.mirror.aliyuncs.com/  https://hub-mirror.c.163.com/ Live Restore Enabled: falseWARNING: No blkio throttle.read_bps_device supportWARNING: No blkio throttle.write_bps_device supportWARNING: No blkio throttle.read_iops_device supportWARNING: No blkio throttle.write_iops_device support</code></pre><hr><h3 id="docker-xx-–help"><a href="#docker-xx-–help" class="headerlink" title="docker xx –help"></a>docker xx –help</h3><blockquote><p>查看 Docker 命令的帮助文档。</p></blockquote><p>例如：<code>docker images --help</code></p><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker images --helpUsage:  docker images [OPTIONS] [REPOSITORY[:TAG]]List imagesOptions:  -a, --all             Show all images (default hides intermediate images)      --digests         Show digests  -f, --filter filter   Filter output based on conditions provided      --format string   Pretty-print images using a Go template      --no-trunc        Don&#39;t truncate output  -q, --quiet           Only show image IDs</code></pre><hr><h2 id="Docker-镜像命令"><a href="#Docker-镜像命令" class="headerlink" title="Docker 镜像命令"></a>Docker 镜像命令</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><blockquote><p>查看本机所有 Docker 镜像。</p></blockquote><ul><li>-a, –all 列出所有镜像</li><li>-q, –quite 只显示镜像id</li></ul><blockquote><p>-aq可在后续 <strong>删除镜像命令</strong> 时配合使用</p></blockquote><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker imagesREPOSITORY               TAG       IMAGE ID       CREATED         SIZEdocker/getting-started   latest    021a1b85e641   3 months ago    27.6MBhello-world              latest    bf756fb1ae65   14 months ago   13.3kB</code></pre><hr><h3 id="docker-search-镜像关键词"><a href="#docker-search-镜像关键词" class="headerlink" title="docker search 镜像关键词"></a>docker search 镜像关键词</h3><blockquote><p>搜索 Docker 镜像。</p></blockquote><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker search ubuntuNAME                                                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDubuntu                                                    Ubuntu is a Debian-based Linux operating sys…   11944     [OK]dorowu/ubuntu-desktop-lxde-vnc                            Docker image to provide HTML5 VNC interface …   504                  [OK]......</code></pre><hr><h3 id="docker-pull-镜像名-tag"><a href="#docker-pull-镜像名-tag" class="headerlink" title="docker pull 镜像名[:tag]"></a>docker pull 镜像名[:tag]</h3><p><a href="https://hub.docker.com/">Docker 镜像库</a></p><blockquote><p>拉取 Docker 镜像。</p></blockquote><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker pull mysql:latestlatest: Pulling from library/mysql # 如果不指定 tag，则默认 latesta076a628af6f: Pull complete # 分层下载，联合文件系统f6c208f3f991: Pull complete88a9455a9165: Pull complete406c9b8427c6: Pull complete7c88599c0b25: Pull complete25b5c6debdaf: Pull complete43a5816f1617: Pull complete1a8c919e89bf: Pull complete9f3cf4bd1a07: Pull complete80539cea118d: Pull complete201b3cad54ce: Pull complete944ba37e1c06: Pull completeDigest: sha256:feada149cb8ff54eade1336da7c1d080c4a1c7ed82b5e320efb5beebed85ae8c # 签名Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest # 真实地址</code></pre><hr><h3 id="docker-rmi-镜像"><a href="#docker-rmi-镜像" class="headerlink" title="docker rmi 镜像"></a>docker rmi 镜像</h3><blockquote><p>删除 Docker 镜像。</p></blockquote><pre><code class="bash">docker rmi -f 容器id # 删除指定镜像docker rmi -f 容器id 容器id ... # 删除多个镜像docker rmi -f $(docker images -aq) # 删除所有镜像</code></pre><hr><h2 id="Docker-容器命令"><a href="#Docker-容器命令" class="headerlink" title="Docker 容器命令"></a>Docker 容器命令</h2><h3 id="docker-run-可选参数-image"><a href="#docker-run-可选参数-image" class="headerlink" title="docker run [可选参数] image"></a>docker run [可选参数] image</h3><blockquote><p>通过指定镜像，生成指定容器。</p></blockquote><p>搭配 -it 与终端路径可对应进入指定 Linux 容器。</p><table><thead><tr><th align="center"><strong>常用可选参数</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">–name=”Name”</td><td align="center">容器名</td></tr><tr><td align="center">-d</td><td align="center">后台方式运行</td></tr><tr><td align="center">-it</td><td align="center">使用交互方式运行，进入容器查看内容</td></tr><tr><td align="center">-p ip:主机端口:容器端口</td><td align="center">指定容器端口</td></tr><tr><td align="center">-p 主机端口:容器端口（常用）</td><td align="center">指定容器端口</td></tr><tr><td align="center">-p 容器端口</td><td align="center">指定容器端口</td></tr><tr><td align="center">-P</td><td align="center">指定随机端口</td></tr></tbody></table><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker run -it ubuntu /bin/bashroot@33339890e94c:/# lsbin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  varroot@33339890e94c:/# cat /etc/os-releaseNAME=&quot;Ubuntu&quot;VERSION=&quot;20.04.2 LTS (Focal Fossa)&quot;ID=ubuntuID_LIKE=debianPRETTY_NAME=&quot;Ubuntu 20.04.2 LTS&quot;VERSION_ID=&quot;20.04&quot;HOME_URL=&quot;https://www.ubuntu.com/&quot;SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;VERSION_CODENAME=focalUBUNTU_CODENAME=focalroot@33339890e94c:/#</code></pre><hr><h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><blockquote><p>退出<code>且停止容器</code></p></blockquote><pre><code class="bash">root@33339890e94c:/# exitexitPS C:\Users\P7XXTM1-G&gt;</code></pre><blockquote><p>若要退出容器，但<code>不想停止容器</code>，则通过<code>快捷键 Ctrl + P + Q</code> 即可。</p></blockquote><pre><code class="bash">root@cd9e271f0792:/#PS C:\Users\P7XXTM1-G&gt; docker psCONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMEScd9e271f0792   ubuntu    &quot;/bin/bash&quot;   7 seconds ago   Up 6 seconds             serene_hopperPS C:\Users\P7XXTM1-G&gt;</code></pre><hr><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><blockquote><p>查看运行的容器。</p></blockquote><table><thead><tr><th align="center"><strong>常用可选参数</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">列出当前正在运行的容器与历史运行容器</td></tr><tr><td align="center">-n=?</td><td align="center">显示最近运行的容器，”?” 可指定输出条目，如：-n=1，则输出最近一条记录</td></tr><tr><td align="center">-q</td><td align="center">只显示容器编号</td></tr></tbody></table><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker psCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMESPS C:\Users\P7XXTM1-G&gt; docker ps -aCONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                          PORTS     NAMES33339890e94c   ubuntu    &quot;/bin/bash&quot;   5 minutes ago   Exited (0) About a minute ago             inspiring_zhukovskyPS C:\Users\P7XXTM1-G&gt;</code></pre><hr><h3 id="docker-rm-容器id"><a href="#docker-rm-容器id" class="headerlink" title="docker rm 容器id"></a>docker rm 容器id</h3><blockquote><p>删除容器</p></blockquote><pre><code class="bash">docker rm 容器id # 删除指定容器，不能删除正在运行的容器，如果要强制删除则需要通过 rm -f 执行docker rm -f $(docker ps -aq) # 删除所有容器docker ps -aq|xargs docker rm # 删除所有容器（管道锁）</code></pre><hr><h3 id="容器的-启动-重启-停止-强制停止-命令"><a href="#容器的-启动-重启-停止-强制停止-命令" class="headerlink" title="容器的 启动/重启/停止/强制停止 命令"></a>容器的 启动/重启/停止/强制停止 命令</h3><pre><code class="bash">docker start 容器id # 启动容器docker restart 容器id # 重启容器docker stop 容器id # 停止当前正在运行的容器docker kill 容器id # 强制停止当前正在运行的容器</code></pre><hr><h2 id="Docker-其他常用命令"><a href="#Docker-其他常用命令" class="headerlink" title="Docker 其他常用命令"></a>Docker 其他常用命令</h2><h3 id="docker-run-d-镜像名"><a href="#docker-run-d-镜像名" class="headerlink" title="docker run -d 镜像名"></a>docker run -d 镜像名</h3><blockquote><p>以后台启动方式启动容器。</p></blockquote><p>此时若后台启动的容器中<code>没有前台应用</code>，则 Docker 会停止该后台容器，则使用 docker ps 命令将不会后台运行容器。</p><p>若需要容器在后台保持运行，则必须有一个前台进程。</p><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker run -d ubuntue0f36dc3a166a6dd9c612d26b17e845a8a3a0a2c071f47b8fd9f8cf9ee78082a</code></pre><hr><h3 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h3><blockquote><p>查看容器日志。</p></blockquote><table><thead><tr><th align="center"><strong>常用可选参数</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">-f</td><td align="center">打印日志</td></tr><tr><td align="center">-t</td><td align="center">以时间戳字符串输出</td></tr><tr><td align="center">–tail</td><td align="center">输出日志条数</td></tr></tbody></table><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker run -d ubuntu /bin/sh -c &quot;while true;do echo hello-from-ubunut;sleep 1;done&quot;2f090441e6e80fcf526e664973e968fbf8b33d1228ea4a91d38a02d4661edc3aPS C:\Users\P7XXTM1-G&gt; docker psCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES2f090441e6e8   ubuntu    &quot;/bin/sh -c &#39;while t…&quot;   4 seconds ago   Up 2 seconds             gallant_elgamalPS C:\Users\P7XXTM1-G&gt; docker logs -f -t --tail 10 2f090441e6e82021-03-18T05:13:02.218287300Z hello-from-ubunut2021-03-18T05:13:03.219282500Z hello-from-ubunut2021-03-18T05:13:04.220377900Z hello-from-ubunut2021-03-18T05:13:05.221435600Z hello-from-ubunut2021-03-18T05:13:06.223104800Z hello-from-ubunut2021-03-18T05:13:07.223687300Z hello-from-ubunut2021-03-18T05:13:08.224903600Z hello-from-ubunut2021-03-18T05:13:09.225778500Z hello-from-ubunut2021-03-18T05:13:10.226692700Z hello-from-ubunut2021-03-18T05:13:11.227667300Z hello-from-ubunut2021-03-18T05:13:12.228729200Z hello-from-ubunut2021-03-18T05:13:13.229784400Z hello-from-ubunut2021-03-18T05:13:14.230961900Z hello-from-ubunut2021-03-18T05:13:15.232517700Z hello-from-ubunut2021-03-18T05:13:16.233134900Z hello-from-ubunut2021-03-18T05:13:17.234228900Z hello-from-ubunut2021-03-18T05:13:18.235945200Z hello-from-ubunut2021-03-18T05:13:19.236571400Z hello-from-ubunut2021-03-18T05:13:20.238078900Z hello-from-ubunutPS C:\Users\P7XXTM1-G&gt;</code></pre><hr><h3 id="docker-stats"><a href="#docker-stats" class="headerlink" title="docker stats"></a>docker stats</h3><blockquote><p>查看 Docker 资源占用情况。</p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ docker statsCONTAINER ID   NAME              CPU %     MEM USAGE / LIMIT     MEM %     NET I/O        BLOCK I/O   PIDSf3a8f8e37903   dreamy_tesla      0.00%     6.809MiB / 12.44GiB   0.05%     516B / 0B      0B / 0B     1c08739536043   quirky_roentgen   0.00%     2.285MiB / 12.44GiB   0.02%     656B / 0B      0B / 0B     19e8cb66f4144   Elasticsearch     0.21%     2.224GiB / 12.44GiB   17.87%    1.8kB / 867B   0B / 0B     48</code></pre><hr><h3 id="docker-top-容器id"><a href="#docker-top-容器id" class="headerlink" title="docker top 容器id"></a>docker top 容器id</h3><blockquote><p>查看容器中的的进程信息。</p></blockquote><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker run -d ubuntu /bin/sh -c &quot;while true;do echo hello-from-ubunut;sleep 1;done&quot;a7e9449469b287e1cfc7c2768fa66c19113135421659568ca4da14b9ac9bcdd3PS C:\Users\P7XXTM1-G&gt; docker psCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMESa7e9449469b2   ubuntu    &quot;/bin/sh -c &#39;while t…&quot;   8 seconds ago   Up 7 seconds             great_chaumPS C:\Users\P7XXTM1-G&gt; docker top a7e9449469b2UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMDroot                1720                1699                0                   05:59               ?                   00:00:00            /bin/sh -c while true;do echo hello-from-ubunut;sleep 1;doneroot                1777                1720                0                   06:00               ?                   00:00:00            sleep 1PS C:\Users\P7XXTM1-G&gt;</code></pre><hr><h3 id="docker-inspect-容器id"><a href="#docker-inspect-容器id" class="headerlink" title="docker inspect 容器id"></a>docker inspect 容器id</h3><blockquote><p>查看容器信息。</p></blockquote><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker run -d ubuntu1147368a1740a8a9367f550447faa808bbf8fe3eb43a3fb5d890f88153ee2e80PS C:\Users\P7XXTM1-G&gt; docker ps -aCONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                      PORTS     NAMES1147368a1740   ubuntu    &quot;/bin/bash&quot;   18 seconds ago   Exited (0) 17 seconds ago             naughty_engelbartPS C:\Users\P7XXTM1-G&gt; docker inspect 1147368a1740[    &#123;        &quot;Id&quot;: &quot;1147368a1740a8a9367f550447faa808bbf8fe3eb43a3fb5d890f88153ee2e80&quot;,        &quot;Created&quot;: &quot;2021-03-18T06:04:28.0414634Z&quot;,        &quot;Path&quot;: &quot;/bin/bash&quot;,        &quot;Args&quot;: [],        &quot;State&quot;: &#123;            &quot;Status&quot;: &quot;exited&quot;,            &quot;Running&quot;: false,            &quot;Paused&quot;: false,            &quot;Restarting&quot;: false,            &quot;OOMKilled&quot;: false,            &quot;Dead&quot;: false,            &quot;Pid&quot;: 0,            &quot;ExitCode&quot;: 0,            &quot;Error&quot;: &quot;&quot;,            &quot;StartedAt&quot;: &quot;2021-03-18T06:04:28.2739845Z&quot;,            &quot;FinishedAt&quot;: &quot;2021-03-18T06:04:28.2748083Z&quot;        &#125;,        &quot;Image&quot;: &quot;sha256:4dd97cefde62cf2d6bcfd8f2c0300a24fbcddbe0ebcd577cc8b420c29106869a&quot;,        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/1147368a1740a8a9367f550447faa808bbf8fe3eb43a3fb5d890f88153ee2e80/resolv.conf&quot;,        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/1147368a1740a8a9367f550447faa808bbf8fe3eb43a3fb5d890f88153ee2e80/hostname&quot;,        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/1147368a1740a8a9367f550447faa808bbf8fe3eb43a3fb5d890f88153ee2e80/hosts&quot;,        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/1147368a1740a8a9367f550447faa808bbf8fe3eb43a3fb5d890f88153ee2e80/1147368a1740a8a9367f550447faa808bbf8fe3eb43a3fb5d890f88153ee2e80-json.log&quot;,        &quot;Name&quot;: &quot;/naughty_engelbart&quot;,        &quot;RestartCount&quot;: 0,        &quot;Driver&quot;: &quot;overlay2&quot;,        &quot;Platform&quot;: &quot;linux&quot;,        &quot;MountLabel&quot;: &quot;&quot;,        &quot;ProcessLabel&quot;: &quot;&quot;,        &quot;AppArmorProfile&quot;: &quot;&quot;,        &quot;ExecIDs&quot;: null,        ......    &#125;]</code></pre><hr><h3 id="docker-exec-it-容器id-终端地址"><a href="#docker-exec-it-容器id-终端地址" class="headerlink" title="docker exec -it 容器id 终端地址"></a>docker exec -it 容器id 终端地址</h3><blockquote><p>进入当前正在运行的容器，<code>开启新终端</code>。</p></blockquote><p>常用的终端地址：</p><ul><li>/bin/bash（常用）</li><li>/bin/sh</li></ul><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker psCONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES4172c4f6f390   ubuntu    &quot;/bin/bash&quot;   7 seconds ago   Up 5 seconds             eloquent_bohrPS C:\Users\P7XXTM1-G&gt; docker exec -it 4172c4f6f390 /bin/bashroot@4172c4f6f390:/# ps -efUID        PID  PPID  C STIME TTY          TIME CMDroot         1     0  0 06:11 pts/0    00:00:00 /bin/bashroot        10     0  0 06:12 pts/1    00:00:00 /bin/bashroot        19    10  0 06:12 pts/1    00:00:00 ps -efroot@4172c4f6f390:/#</code></pre><hr><h3 id="docker-attach-容器id"><a href="#docker-attach-容器id" class="headerlink" title="docker attach 容器id"></a>docker attach 容器id</h3><blockquote><p>进入当前正在运行的容器，但<code>不会开启新终端</code>，会继续以前终端的操作</p></blockquote><pre><code class="bash">PS C:\Users\P7XXTM1-G&gt; docker psCONTAINER ID   IMAGE     COMMAND       CREATED              STATUS              PORTS     NAMES4172c4f6f390   ubuntu    &quot;/bin/bash&quot;   About a minute ago   Up About a minute             eloquent_bohrPS C:\Users\P7XXTM1-G&gt; docker attach 4172c4f6f390正在运行的终端指令......</code></pre><hr><h3 id="docker-cp-容器id-容器目录-本地目录"><a href="#docker-cp-容器id-容器目录-本地目录" class="headerlink" title="docker cp 容器id:/容器目录 本地目录"></a>docker cp 容器id:/容器目录 本地目录</h3><blockquote><p>从容器（无论容器是否运行）中将文件拷贝到外部。</p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ docker run -it ubuntu /bin/bashroot@0619c363583e:/# lsbin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  varroot@0619c363583e:/# cd home/root@0619c363583e:/home# ls# 在容器中新建一个测试用的 test.fileroot@0619c363583e:/home# touch test.fileroot@0619c363583e:/home# lstest.fileroot@0619c363583e:/home# exitexit# 查看容器idubuntu@DESKTOP-5IG459O:~$ docker ps -aCONTAINER ID   IMAGE     COMMAND           CREATED          STATUS                     PORTS     NAMES0619c363583e   ubuntu    &quot;/bin/bash&quot;       25 seconds ago   Exited (0) 3 seconds ago             optimistic_cartwright# 将容器中的文件拷贝到本地（由于我未将 Docker 加入用户组，故在使用 Docker 的部分命令时需使用 sudo 权限）ubuntu@DESKTOP-5IG459O:~$ sudo docker cp 0619c363583e:/home/test.file /home# 查看 Docker 容器中的文件是否已拷贝到本地目录下ubuntu@DESKTOP-5IG459O:~$ lsubuntu@DESKTOP-5IG459O:~$ cd /home/ubuntu@DESKTOP-5IG459O:/home$ lstest.file  ubuntuubuntu@DESKTOP-5IG459O:/home$</code></pre><hr><h3 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h3><blockquote><p>生成本地 Docker 自定义镜像。</p></blockquote><table><thead><tr><th align="center"><strong>常用可选参数</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">提交镜像作者</td></tr><tr><td align="center">-m</td><td align="center">提交镜像信息</td></tr></tbody></table><blockquote><p>这里我们制作一个带有 Vim 编辑器的 Ubuntu 镜像（ubuntu-vim），并通过 docker commit 命令制作一个本地镜像。</p></blockquote><blockquote><p>当我们尝试对 Ubuntu 镜像添加软件或对一些系统配置进行修改时，我们就生成了一个属于自己的自定义镜像，通过使用自定义镜像，我们可以对日常工作时的项目进行客制化修改，并可以省去大部分需要因为配置开发环境与部署环境的高度重合的工作，<code>只需要对自定义镜像进行二次修改，即可满足需求再次上线。</code></p></blockquote><pre><code class="bash">docker commit -a &quot;Peter Chen&quot; -m &quot;Add Vim&quot; c79bc37440d2 ubuntu-vimsha256:8e9d1c74cd2404d7c006c5f7074b1f00b61f8c10a22044ab5b24da68c34a67aeubuntu@DESKTOP-5IG459O:~$ docker imagesREPOSITORY               TAG       IMAGE ID       CREATED         SIZEubuntu-vim               latest    8e9d1c74cd24   4 seconds ago   168MBubuntu                   latest    4dd97cefde62   2 weeks ago     72.9MBmysql                    latest    c8562eaf9d81   2 months ago    546MBredis                    latest    621ceef7494a   2 months ago    104MBtomcat                   latest    040bdb29ab37   2 months ago    649MBnginx                    latest    f6d0b4767a6c   2 months ago    133MBportainer/portainer-ce   latest    980323c8eb3f   2 months ago    196MBcentos                   latest    300e315adb2f   3 months ago    209MBkibana                   latest    a674d23325b0   2 years ago     388MBelasticsearch            latest    5acf0e8da90b   2 years ago     486MBubuntu@DESKTOP-5IG459O:~$</code></pre><hr><h2 id="Docker-命令简单应用"><a href="#Docker-命令简单应用" class="headerlink" title="Docker 命令简单应用"></a>Docker 命令简单应用</h2><h3 id="部署-Nginx"><a href="#部署-Nginx" class="headerlink" title="部署 Nginx"></a>部署 Nginx</h3><blockquote><p><code>WSL2</code> 下通过 Docker 命令部署 <code>Nginx</code>，通过端口映射到主机上的 <code>80</code> 端口，并通过 <code>curl</code> 命令对该端口内容进行查看。<br><strong>Nginx 默认端口：80</strong></p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ docker run -d --name Nginx -p 80:80 nginxae4f49240c2af6e20faa786a8fc144b78aacb6c7625ff11cf7ea39e67193ac22ubuntu@DESKTOP-5IG459O:~$ docker psCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                  NAMESae4f49240c2a   nginx     &quot;/docker-entrypoint.…&quot;   5 seconds ago   Up 3 seconds   0.0.0.0:80-&gt;80/tcp   Nginxubuntu@DESKTOP-5IG459O:~$ curl localhost:80&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;    body &#123;        width: 35em;        margin: 0 auto;        font-family: Tahoma, Verdana, Arial, sans-serif;    &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h3 id="部署-Tomcat"><a href="#部署-Tomcat" class="headerlink" title="部署 Tomcat"></a>部署 Tomcat</h3><blockquote><p><code>WSL2</code> 下通过 Docker 命令部署 <code>Tomcat</code>，通过端口映射到主机上的 <code>8080</code> 端口，并通过 <code>curl</code> 命令对该端口内容进行查看。<br><strong>Tomcat 默认端口：8080</strong></p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ docker run -d --name Tomcat -p 8080:8080 tomcat1d5186fd99fae677916b5ddb7012a3277881bfefd8ee7da762b264b3aca05dddubuntu@DESKTOP-5IG459O:~$ docker ps -aCONTAINER ID   IMAGE     COMMAND             CREATED         STATUS         PORTS                    NAMES1d5186fd99fa   tomcat    &quot;catalina.sh run&quot;   4 seconds ago   Up 4 seconds   0.0.0.0:8080-&gt;8080/tcp   Tomcatubuntu@DESKTOP-5IG459O:~$ curl localhost:8080&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;title&gt;HTTP Status 404 – Not Found&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123;font-family:Tahoma,Arial,sans-serif;&#125; h1, h2, h3, b &#123;color:white;background-color:#525D76;&#125; h1 &#123;font-size:22px;&#125; h2 &#123;font-size:16px;&#125; h3 &#123;font-size:14px;&#125; p &#123;font-size:12px;&#125; a &#123;color:black;&#125; .line &#123;height:1px;background-color:#525D76;border:none;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;HTTP Status 404 – Not Found&lt;/h1&gt;&lt;hr class=&quot;line&quot; /&gt;&lt;p&gt;&lt;b&gt;Type&lt;/b&gt; Status Report&lt;/p&gt;&lt;p&gt;&lt;b&gt;Description&lt;/b&gt; The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.&lt;/p&gt;&lt;hr class=&quot;line&quot; /&gt;&lt;h3&gt;Apache Tomcat/9.0.41&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;ubuntu@DESKTOP-5IG459O:~$</code></pre><blockquote><p>在这里我们会感受到 Docker 镜像的最小化体验，即我们通过 curl 命令直接访问是会报 404的，这是因为 Docker 的镜像通常只包含最小运行环境，会省去大量无用的资源。<br>在进入容器后，我们会发现 Tomcat 中的 webapps 文件夹目录下并无任何东西。</p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ docker exec -it Tomcat /bin/bashroot@1d5186fd99fa:/usr/local/tomcat# whereis tomcattomcat: /usr/local/tomcatroot@1d5186fd99fa:/usr/local/tomcat# cd /usr/local/tomcat/root@1d5186fd99fa:/usr/local/tomcat# lsBUILDING.txt     LICENSE  README.md      RUNNING.txt  conf  logs            temp     webapps.distCONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin          lib   native-jni-lib  webapps  workroot@1d5186fd99fa:/usr/local/tomcat# cd webappsroot@1d5186fd99fa:/usr/local/tomcat/webapps# lsroot@1d5186fd99fa:/usr/local/tomcat/webapps#</code></pre><blockquote><p>通过翻阅资料，我们可以知道：Tomcat 镜像会将原有 webapps 文件夹下的文件删除，如需要恢复则可通过将 webapps.dist 文件夹下的文件拷贝到 webapps 文件夹解决。</p></blockquote><pre><code class="bash">root@1d5186fd99fa:/usr/local/tomcat# cp -r webapps.dist/* webappsroot@1d5186fd99fa:/usr/local/tomcat# cd webappsroot@1d5186fd99fa:/usr/local/tomcat/webapps# lsROOT  docs  examples  host-manager  managerroot@1d5186fd99fa:/usr/local/tomcat/webapps#ubuntu@DESKTOP-5IG459O:~$ curl localhost:8080&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot; /&gt;        &lt;title&gt;Apache Tomcat/9.0.41&lt;/title&gt;        &lt;link href=&quot;favicon.ico&quot; rel=&quot;icon&quot; type=&quot;image/x-icon&quot; /&gt;        &lt;link href=&quot;tomcat.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;wrapper&quot;&gt;            &lt;div id=&quot;navigation&quot; class=&quot;curved container&quot;&gt;                &lt;span id=&quot;nav-home&quot;&gt;&lt;a href=&quot;https://tomcat.apache.org/&quot;&gt;Home&lt;/a&gt;&lt;/span&gt;                &lt;span id=&quot;nav-hosts&quot;&gt;&lt;a href=&quot;/docs/&quot;&gt;Documentation&lt;/a&gt;&lt;/span&gt;                &lt;span id=&quot;nav-config&quot;&gt;&lt;a href=&quot;/docs/config/&quot;&gt;Configuration&lt;/a&gt;&lt;/span&gt;                &lt;span id=&quot;nav-examples&quot;&gt;&lt;a href=&quot;/examples/&quot;&gt;Examples&lt;/a&gt;&lt;/span&gt;                &lt;span id=&quot;nav-wiki&quot;&gt;&lt;a href=&quot;https://wiki.apache.org/tomcat/FrontPage&quot;&gt;Wiki&lt;/a&gt;&lt;/span&gt;                &lt;span id=&quot;nav-lists&quot;&gt;&lt;a href=&quot;https://tomcat.apache.org/lists.html&quot;&gt;Mailing Lists&lt;/a&gt;&lt;/span&gt;                &lt;span id=&quot;nav-help&quot;&gt;&lt;a href=&quot;https://tomcat.apache.org/findhelp.html&quot;&gt;Find Help&lt;/a&gt;&lt;/span&gt;                &lt;br class=&quot;separator&quot; /&gt;            &lt;/div&gt;            &lt;div id=&quot;asf-box&quot;&gt;                &lt;h1&gt;Apache Tomcat/9.0.41&lt;/h1&gt;            &lt;/div&gt;            ......    &lt;/body&gt;&lt;/html&gt;</code></pre><hr><h3 id="部署-Elasticsearch"><a href="#部署-Elasticsearch" class="headerlink" title="部署 Elasticsearch"></a>部署 Elasticsearch</h3><blockquote><p><code>WSL2</code> 下通过 Docker 命令部署 <code>Elasticsearch</code>，通过端口映射到主机上的 <code>9200</code> 端口，并通过 <code>curl</code> 命令对该端口内容进行查看。<br><strong>Elasticsearch 默认端口：9200</strong></p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ docker run -d --name Elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:latest9e8cb66f41446d40ec2ce3dd8bd1aab7189e9c37daf5233795e25926bece5587ubuntu@DESKTOP-5IG459O:~$ docker psCONTAINER ID   IMAGE                  COMMAND                  CREATED         STATUS         PORTS                                            NAMES9e8cb66f4144   elasticsearch:latest   &quot;/docker-entrypoint.…&quot;   4 seconds ago   Up 2 seconds   0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp   Elasticsearchubuntu@DESKTOP-5IG459O:~$ curl localhost:9200&#123;  &quot;name&quot; : &quot;03-Xaze&quot;,  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,  &quot;cluster_uuid&quot; : &quot;afbJDcPlTJuv2-FI0n7rIA&quot;,  &quot;version&quot; : &#123;    &quot;number&quot; : &quot;5.6.12&quot;,    &quot;build_hash&quot; : &quot;cfe3d9f&quot;,    &quot;build_date&quot; : &quot;2018-09-10T20:12:43.732Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;6.6.1&quot;  &#125;,  &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;ubuntu@DESKTOP-5IG459O:~$ docker statusdocker: &#39;status&#39; is not a docker command.See &#39;docker --help&#39;</code></pre><blockquote><p>ES 默认会占用大量内存，若想通过修改配置的方式对 ES 进行配置，可追加 -e [参数]，对其进行环境配置。<br>此处我们将 ES 的内存限制为最小内存 64m，最大内存 1024m。</p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ docker run -d --name Elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;-Xms=64m -Xmx=1024m&quot; elasticsearch:latest021abaaf2148248188c8add919576895dc9d61bca8834601d4947058616ce1ecubuntu@DESKTOP-5IG459O:~$ docker statsCONTAINER ID   NAME            CPU %     MEM USAGE / LIMIT    MEM %     NET I/O     BLOCK I/O   PIDS021abaaf2148   Elasticsearch   0.17%     2.22GiB / 12.44GiB   17.84%    696B / 0B   0B / 0B     43</code></pre><hr><h2 id="可视化管理工具"><a href="#可视化管理工具" class="headerlink" title="可视化管理工具"></a>可视化管理工具</h2><h3 id="Portiner"><a href="#Portiner" class="headerlink" title="Portiner"></a>Portiner</h3><blockquote><p>官方地址：<a href="https://www.portainer.io/">Portiner</a><br><strong>Portiner 默认端口：9000</strong></p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ docker run -d -p 9000:9000 --name=Portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-cea60bf182bf76b2ce5971cb47da02c6be15d4132b37364bf63987e98079195d30ubuntu@DESKTOP-5IG459O:~$ docker psCONTAINER ID   IMAGE                    COMMAND        CREATED         STATUS         PORTS                              NAMESa60bf182bf76   portainer/portainer-ce   &quot;/portainer&quot;   2 seconds ago   Up 2 seconds   8000/tcp, 0.0.0.0:9000-&gt;9000/tcp   Portainerubuntu@DESKTOP-5IG459O:~$</code></pre><hr><blockquote><p>Portainer 显示效果</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Docker/docker_portainer_login.png" alt="Portainer 登录页"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Docker/docker_portainer_manage.png" alt="Portainer 管理配置页"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Docker/docker_portainer_home.png" alt="Portainer 主页"></p><hr><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>当我们想要通过 Docker 进行数据持久化存储的时候，若我们将数据全部存放于 Docker 容器中，则当我们删除容器时，容器中的数据也就被我们一并删除，也就是通俗意义上讲的“删库跑路”。<br>现实中为了防止此类事情发生，通常可以通过容器数据卷技术，将容器中的目录挂载到外部目录（这个外部目录通常是当前计算机上的物理地址）。</p><blockquote><p>即：双向绑定，容器的持久化和同步操作，即使 Docker 中各个容器间互相隔离，但容器间也是可以数据共享的。</p></blockquote></blockquote><hr><h3 id="docker-run-it-v-主机目录-容器内目录"><a href="#docker-run-it-v-主机目录-容器内目录" class="headerlink" title="docker run -it -v 主机目录:容器内目录"></a>docker run -it -v 主机目录:容器内目录</h3><p>在这里我们尝试将本地 Ubuntu WSL2 虚拟机上的目录挂载到 Docker 中新建的 Ubuntu 容器上。</p><blockquote><p>本地挂载目录：/home/test，若本地无此目录，则 Docker 会帮助创建。<br>容器挂载目录：/home</p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ docker run -it -v /home/test:/home ubuntu /bin/bash</code></pre><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Docker/docker_data_share.png" alt="挂载后容器与外部的数据共享"></p><blockquote><p>通过 docker inspect，我们可以检查容器挂载信息。</p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ docker psCONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES562e4b3c9d92   ubuntu    &quot;/bin/bash&quot;   6 minutes ago   Up 6 minutes             nervous_darwinubuntu@DESKTOP-5IG459O:~$ docker inspect 562e4b3c9d92[    &#123;        &quot;Id&quot;: &quot;562e4b3c9d92cc41642ccaf6e4883ec328a9df205b0ea2d6c00e54fab253e42e&quot;,        &quot;Created&quot;: &quot;2021-03-23T01:33:55.8844317Z&quot;,        &quot;Path&quot;: &quot;/bin/bash&quot;,        &quot;Args&quot;: [],        &quot;State&quot;: &#123;            &quot;Status&quot;: &quot;running&quot;,            &quot;Running&quot;: true,            &quot;Paused&quot;: false,            &quot;Restarting&quot;: false,            &quot;OOMKilled&quot;: false,            &quot;Dead&quot;: false,            &quot;Pid&quot;: 1277,            &quot;ExitCode&quot;: 0,            &quot;Error&quot;: &quot;&quot;,            &quot;StartedAt&quot;: &quot;2021-03-23T01:33:56.1845627Z&quot;,            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;        &#125;,        ......                &quot;Mounts&quot;: [            &#123;                &quot;Type&quot;: &quot;bind&quot;,                &quot;Source&quot;: &quot;/home/test&quot;, # 容器内的挂载目录                &quot;Destination&quot;: &quot;/home&quot;, # 容器外的挂载目录                &quot;Mode&quot;: &quot;&quot;,                &quot;RW&quot;: true,                &quot;Propagation&quot;: &quot;rprivate&quot;            &#125;        ],        ......    &#125;]ubuntu@DESKTOP-5IG459O:~$</code></pre><hr><h3 id="测试-MySQL-数据"><a href="#测试-MySQL-数据" class="headerlink" title="测试 MySQL 数据"></a>测试 MySQL 数据</h3><blockquote><p>这里我们测试将容器中的 MySQL 配置文件挂载到外部，并将数据目录也挂载到外部，防止因为误删容器而导致的数据丢失。</p></blockquote><p>建立一个通过 3306 端口映射到本地，配置文件与数据文件目录挂载到本地，MySQL root 账户密码为 root，容器名为 testMySQL 的 MySQL 容器。</p><blockquote><p>本地挂载配置文件目录：/home/mysql/conf<br>容器配置文件目录：/etc/mysql/conf.d</p></blockquote><blockquote><p>本地挂载数据目录：/home/mysql/data<br>容器数据目录：/var/lib/mysql</p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name testMySQL mysql:latestubuntu@DESKTOP-5IG459O:~$ cd /home/ubuntu@DESKTOP-5IG459O:/home$ lsmysql  ubuntuubuntu@DESKTOP-5IG459O:/home$ cd mysql/ubuntu@DESKTOP-5IG459O:/home/mysql$ lsconf  dataubuntu@DESKTOP-5IG459O:/home/mysql$ cd data/ubuntu@DESKTOP-5IG459O:/home/mysql/data$ ls&#39;#ib_16384_0.dblwr&#39;   auto.cnf        binlog.index   client-cert.pem   ib_logfile0   ibtmp1      performance_schema   server-cert.pem   undo_001&#39;#ib_16384_1.dblwr&#39;   binlog.000001   ca-key.pem     client-key.pem    ib_logfile1   mysql       private_key.pem      server-key.pem    undo_002&#39;#innodb_temp&#39;        binlog.000002   ca.pem         ib_buffer_pool    ibdata1       mysql.ibd   public_key.pem       sys# 这里我们通过 DataGrip，对映射出来的本地 3306 进行控制，并添加一个 test 表。ubuntu@DESKTOP-5IG459O:/home/mysql/data$ ls&#39;#ib_16384_0.dblwr&#39;   auto.cnf        binlog.index   client-cert.pem   ib_logfile0   ibtmp1      performance_schema   server-cert.pem   test&#39;#ib_16384_1.dblwr&#39;   binlog.000001   ca-key.pem     client-key.pem    ib_logfile1   mysql       private_key.pem      server-key.pem    undo_001&#39;#innodb_temp&#39;        binlog.000002   ca.pem         ib_buffer_pool    ibdata1       mysql.ibd   public_key.pem       sys               undo_002ubuntu@DESKTOP-5IG459O:/home/mysql/data$ docker run -d -it /bin/bash mysql</code></pre><blockquote><p>假设我们删除容器，挂载目录中的数据文件也不会丢失。</p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:/home/mysql$ docker stop testMySQLubuntu@DESKTOP-5IG459O:/home/mysql$ docker rm testMySQLtestMySQLubuntu@DESKTOP-5IG459O:/home/mysql$ cd data/ubuntu@DESKTOP-5IG459O:/home/mysql/data$ ls&#39;#ib_16384_0.dblwr&#39;   auto.cnf        binlog.index   client-cert.pem   ib_logfile0   mysql                private_key.pem   server-key.pem   undo_002&#39;#ib_16384_1.dblwr&#39;   binlog.000001   ca-key.pem     client-key.pem    ib_logfile1   mysql.ibd            public_key.pem    sys&#39;#innodb_temp&#39;        binlog.000002   ca.pem         ib_buffer_pool    ibdata1       performance_schema   server-cert.pem   undo_001ubuntu@DESKTOP-5IG459O:/home/mysql/data$</code></pre><hr><blockquote><p>PS：这里有一个<code>暂时未解决</code>的问题，即 Docker 的容器数据卷挂载会将本地目录覆盖容器内目录，即会隐藏容器内的文件。</p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ docker exec -it testMySQL /bin/bashroot@a0a84f3635e0:/# whereis mysqlmysql: /usr/bin/mysql /usr/lib/mysql /etc/mysqlroot@a0a84f3635e0:/# cd /etc/mysql/root@a0a84f3635e0:/etc/mysql# lsconf.d  my.cnf  my.cnf.fallbackroot@a0a84f3635e0:/etc/mysql# cd conf.d/root@a0a84f3635e0:/etc/mysql/conf.d# lsroot@a0a84f3635e0:/etc/mysql/conf.d#</code></pre><hr><h3 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h3><blockquote><p>当我们尝试创建 Docker 容器卷时，若不指定容器卷的卷名直接挂载外部目录，就是匿名挂载。</p></blockquote><p>这里我们生成一个测试用的 Nginx 容器，并通过<code>匿名挂载方式</code>，挂载 Nginx 的配置文件目录。</p><pre><code class="bash"> docker run -d -P --name AnonymousMountNginx -v /etc/nginx nginx1cbff8ab5b4c295384d1d0a508a6d828997cca6e992c5416fbc9c9668367c957ubuntu@DESKTOP-5IG459O:~$ docker psCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                   NAMES1cbff8ab5b4c   nginx     &quot;/docker-entrypoint.…&quot;   2 seconds ago   Up 2 seconds   0.0.0.0:49153-&gt;80/tcp   AnonymousMountNginx</code></pre><blockquote><p>docker volume … 命令是 Docker 的容器卷管理命令。</p></blockquote><pre><code class="bash"># 通过 docker volume ls 命令可查看当前 Docker 中的容器卷# 未指定名字的就是匿名挂载卷（这里是43145ccdd2df15993af6a2077e044a8089e003b5a4e564be8dad03162aa8816b）ubuntu@DESKTOP-5IG459O:~$ docker volume lsDRIVER    VOLUME NAMElocal     43145ccdd2df15993af6a2077e044a8089e003b5a4e564be8dad03162aa8816b# 通过 docker volume inspect [容器卷名]docker volume inspect 43145ccdd2df15993af6a2077e044a8089e003b5a4e564be8dad03162aa8816b[    &#123;        &quot;CreatedAt&quot;: &quot;2021-03-23T06:39:05Z&quot;,        &quot;Driver&quot;: &quot;local&quot;,        &quot;Labels&quot;: null,        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/43145ccdd2df15993af6a2077e044a8089e003b5a4e564be8dad03162aa8816b/_data&quot;,        &quot;Name&quot;: &quot;43145ccdd2df15993af6a2077e044a8089e003b5a4e564be8dad03162aa8816b&quot;,        &quot;Options&quot;: null,        &quot;Scope&quot;: &quot;local&quot;    &#125;]ubuntu@DESKTOP-5IG459O:~$</code></pre><blockquote><p>Windows10 WSL2 Ubuntu20.04中的镜像位置：<br>\wsl$\docker-desktop-data\version-pack-data\community\docker\volumes</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Docker/docker_volumes_folder_for_windows.png" alt="Windows 中的 Docker 容器数据卷位置"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Docker/docker_volumes_test.png" alt="通过 docker volume inspect 命令提供的目录，如果你的操作系统是 Linux，则可以直接访问挂载的命令目录，由于我的机器是 Windows，挂载目录较其他系统不一样"></p><hr><h3 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h3><p>这里我们生成一个测试用的 Nginx 容器，并通过<code>具名挂载方式</code>，挂载 Nginx 的配置文件目录。</p><pre><code class="bash">ubuntu@DESKTOP-5IG459O:/mnt/c/Users/P7XXTM1-G$ docker run -d -P --name NamedMountNginx -v named-nginx-volume:/etc/nginx nginxfa91bb3dd49f476874d99a1e1199ecf24dd309d4240535611156b6dc5f5ab10aubuntu@DESKTOP-5IG459O:/mnt/c/Users/P7XXTM1-G$ docker psCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                   NAMESfa91bb3dd49f   nginx     &quot;/docker-entrypoint.…&quot;   5 seconds ago   Up 4 seconds   0.0.0.0:49153-&gt;80/tcp   NamedMountNginxubuntu@DESKTOP-5IG459O:/mnt/c/Users/P7XXTM1-G$ docker volume lsDRIVER    VOLUME NAMElocal     43145ccdd2df15993af6a2077e044a8089e003b5a4e564be8dad03162aa8816blocal     named-nginx-volumeubuntu@DESKTOP-5IG459O:/mnt/c/Users/P7XXTM1-G$ docker volume inspect named-nginx-volume[    &#123;        &quot;CreatedAt&quot;: &quot;2021-03-25T02:31:48Z&quot;,        &quot;Driver&quot;: &quot;local&quot;,        &quot;Labels&quot;: null,        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/named-nginx-volume/_data&quot;,        &quot;Name&quot;: &quot;named-nginx-volume&quot;,        &quot;Options&quot;: null,        &quot;Scope&quot;: &quot;local&quot;    &#125;]ubuntu@DESKTOP-5IG459O:/mnt/c/Users/P7XXTM1-G$</code></pre><hr><h3 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h3><blockquote><p><strong>匿名挂载</strong><br>-v 容器内路径</p></blockquote><blockquote><p><strong>具名挂载</strong><br>-v 卷名：容器内路径</p></blockquote><blockquote><p><strong>指定路径挂载（普通挂载，也是匿名挂载）</strong><br>-v /宿主机路径：容器内路径</p></blockquote><hr><h3 id="读写权限"><a href="#读写权限" class="headerlink" title="读写权限"></a>读写权限</h3><blockquote><p>通过 -v 容器内路径：ro 或 rw 改变读写权限</p></blockquote><ul><li>ro read-only # 只读</li><li>rw read-and-write # 可读写</li></ul><pre><code class="bash"># rodocker run -d -P --name NamedMountNginx -v named-nginx-volume:/etc/nginx:ro nginx# rwdocker run -d -P --name NamedMountNginx -v named-nginx-volume:/etc/nginx:rw nginx</code></pre><hr><h2 id="Docker-File"><a href="#Docker-File" class="headerlink" title="Docker File"></a>Docker File</h2><p>即用来构建 Docker 镜像的构建文件。</p><h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><p>创建 Docker File。</p><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ mkdir Test-Docker-Fileubuntu@DESKTOP-5IG459O:~$ lsTest-Docker-Fileubuntu@DESKTOP-5IG459O:~$ cd Test-Docker-File/ubuntu@DESKTOP-5IG459O:~/Test-Docker-File$ vim docker-file</code></pre><blockquote><p>docker-file 文件中的内容<br>通过编辑该文件，对 Docker 镜像进行客制化。</p></blockquote><pre><code class="bash">FROM ubuntuVOLUME [&quot;volume1&quot;, &quot;volume2&quot;]CMD echo &quot;---BUILD END---&quot;CMD /bin/bash</code></pre><hr><h3 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h3><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~/Test-Docker-File$ docker build -f /home/ubuntu/Test-Docker-File/docker-file -t custom/ubuntu .[+] Building 0.2s (5/5) FINISHED =&gt; [internal] load build definition from docker-file                                                                                              0.0s =&gt; =&gt; transferring dockerfile: 123B                                                                                                               0.0s =&gt; [internal] load .dockerignore                                                                                                                  0.0s =&gt; =&gt; transferring context: 2B                                                                                                                    0.0s =&gt; [internal] load metadata for docker.io/library/ubuntu:latest                                                                                   0.0s =&gt; [1/1] FROM docker.io/library/ubuntu                                                                                                            0.1s =&gt; exporting to image                                                                                                                             0.0s =&gt; =&gt; exporting layers                                                                                                                            0.0s =&gt; =&gt; writing image sha256:5212c89e92e63e84857aa6cb946d18b0e161adfb9a606ff1762e174d299aac57                                                       0.0s =&gt; =&gt; naming to docker.io/custom/ubuntu                                                                                                           0.0subuntu@DESKTOP-5IG459O:~/Test-Docker-File$</code></pre><blockquote><p>查看构建完成后的镜像</p></blockquote><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~/Test-Docker-File$ docker image lsREPOSITORY               TAG       IMAGE ID       CREATED        SIZEubuntu                   latest    4dd97cefde62   3 weeks ago    72.9MBcustom/ubuntu            latest    5212c89e92e6   3 weeks ago    72.9MB</code></pre><hr><h3 id="检查生成的镜像"><a href="#检查生成的镜像" class="headerlink" title="检查生成的镜像"></a>检查生成的镜像</h3><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~/Test-Docker-File$ docker run -it custom/ubuntu /bin/bashroot@3e8bb3cc0c7a:/# ls -ltotal 56lrwxrwxrwx   1 root root    7 Feb 17 01:04 bin -&gt; usr/bindrwxr-xr-x   2 root root 4096 Apr 15  2020 boot...# 这里是我们在之前脚本中挂载的容器数据卷drwxr-xr-x   2 root root 4096 Mar 29 13:55 volume1drwxr-xr-x   2 root root 4096 Mar 29 13:55 volume2root@3e8bb3cc0c7a:/#</code></pre><blockquote><p>我们在 volume1 文件夹中创建一个测试文件 testFile。<br>通过 docker inspect 命令，检查<code>用客制化镜像所生成的容器</code>。<br>通过检查 Windows 中的 Docker Volume文件夹，验证我们创建的容器的正确性。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Docker/docker_file_custom_ubuntu_test.png" alt="检查挂载容器数据卷中的文件"></p><hr><h2 id="数据卷容器（待完善）"><a href="#数据卷容器（待完善）" class="headerlink" title="数据卷容器（待完善）"></a>数据卷容器（待完善）</h2><p>当容器与容器之间需要同步数据的时候，一般使用数据卷容器进行挂载。</p><p>使用场景示例：多个 MySQL 同步数据。</p><p>类似 Windows 中的共享文件夹</p><p>步骤：</p><blockquote><ol><li>创建父容器</li><li>通过 –volumes-from 命令，将子容器挂载到父容器</li></ol></blockquote><hr><h3 id="创建父容器"><a href="#创建父容器" class="headerlink" title="创建父容器"></a>创建父容器</h3><pre><code class="bash">ubuntu@DESKTOP-5IG459O:~$ docker image lsREPOSITORY               TAG       IMAGE ID       CREATED        SIZEcustom/ubuntu            latest    715329a7458b   5 weeks ago    72.9MBubuntu                   latest    4dd97cefde62   5 weeks ago    72.9MB# 运行我们刚才创建的自定义容器，并运行，可以看到 VOLUME01 与 VOLUME02 为自定义容器中默认挂载的两个容器。ubuntu@DESKTOP-5IG459O:~$ docker run -it --name Docker-Host custom/ubunturoot@0d03cf71815e:/# ls -ltotal 56drwxr-xr-x   2 root root 4096 Apr 12 08:41 VOLUME01drwxr-xr-x   2 root root 4096 Apr 12 08:41 VOLUME02lrwxrwxrwx   1 root root    7 Feb 17 01:04 bin -&gt; usr/bindrwxr-xr-x   2 root root 4096 Apr 15  2020 boot...root@0d03cf71815e:/#</code></pre><hr><h3 id="创建子容器"><a href="#创建子容器" class="headerlink" title="创建子容器"></a>创建子容器</h3><blockquote><p>–volumes-from</p></blockquote><pre><code class="bash"># 查看正在运行中的父容器。ubuntu@DESKTOP-5IG459O:~$ docker psCONTAINER ID   IMAGE           COMMAND                  CREATED         STATUS         PORTS     NAMES0d03cf71815e   custom/ubuntu   &quot;/bin/sh -c /bin/bash&quot;   2 minutes ago   Up 2 minutes             Docker-Host# 通过 --volumes-from 命令，指定子容器所要继承的父容器。ubuntu@DESKTOP-5IG459O:~$ docker run -it --name Docker-Child01 --volumes-from Docker-Host custom/ubuntu# 运行子容器，可以看到挂载到父容器的 VOLUME01 与 VOLUME02 卷。root@2864c4f3b8ba:/# ls -ltotal 56drwxr-xr-x   2 root root 4096 Apr 12 08:41 VOLUME01drwxr-xr-x   2 root root 4096 Apr 12 08:41 VOLUME02lrwxrwxrwx   1 root root    7 Feb 17 01:04 bin -&gt; usr/bindrwxr-xr-x   2 root root 4096 Apr 15  2020 boot...root@2864c4f3b8ba:/#</code></pre><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Docker/docker-host-child-file-sharing.png" alt="当我们在父容器 Docker-Host 中创建文件时，子容器 Docker-Child01 会同步文件"></p><hr><p>创建多个子容器，当我们在子容器中进行文件的修改，父容器也会同步。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Docker/docker-host-child-sharing-file-from-child02.png" alt="子容器 Docker-Child02 创建文件，父容器 Docker-Host 同步文件"></p><hr><p>PS：</p><blockquote><p>只要有一个容器尚在，容器中的文件都不会被删除。</p></blockquote><blockquote><p>容器创建时使用的镜像已挂载了两个卷（VOLUME01 与 VOLUME02），所以是肯定有两个目录的，跟数据卷容器没关系。</p></blockquote><blockquote><p>–volumes-from 不是同步所有目录，而是同步挂载点，这就是同步 Docker-Child01 与 Docker-Child02，但在其他目录是不会同步的。</p></blockquote><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://yeasy.gitbook.io/docker_practice/">Docker —— 从入门到实践</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?from=search&seid=9603368310329855182">狂神说 – Docker 最新超详细版教程通俗易懂</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cloud-Serving </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简明 Python 基础</title>
      <link href="Basic-Python/"/>
      <url>Basic-Python/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇将介绍我在学习有关<code>Python</code>时的一些笔记分享。<br>所用教学平台：<a href="%22https://www.icourse163.org/%22">MOOC</a><br>所用IDE：<a href="https://jupyter.org/">Jupyter Notebok</a></p></blockquote><blockquote><p>Python由荷兰数学和计算机科学研究学会的Guido van Rossum 于1990 年代初设计，作为一门叫做ABC语言的替代品。Python提供了高效的高级数据结构，还能简单有效地面向对象编程。Python语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的编程语言，随着版本的不断更新和语言新功能的添加，逐渐被用于独立的、大型项目的开发。<br>Python解释器易于扩展，可以使用C或C++（或者其他可以通过C调用的语言）扩展新的功能和数据类型。Python 也可用于可定制化软件中的扩展程序语言。Python丰富的标准库，提供了适用于各个主要系统平台的源码或机器码。</p></blockquote><hr><h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><pre><code class="Python"># Jupyter Notebook 首单元添加： %config IPComplete.greddy=True</code></pre><hr><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h3><pre><code class="Python">print(&quot;Hello Python...&quot;)# print 默认换行，若不需要换行，则：print(&quot;Hello&quot;, end=&quot;&quot;)print(&quot;Python...&quot;)# 或print(&quot;Hello&quot;, &quot; Python...&quot;)</code></pre><hr><h3 id="变量与基本数据类型"><a href="#变量与基本数据类型" class="headerlink" title="变量与基本数据类型"></a>变量与基本数据类型</h3><pre><code class="Python"># Python 无需手动指定数据类型，会根据给定值进行自动指定int_a = 5float_b = 6.3str_c = &quot;Hello&quot;print(int_a, float_b, str_c)print(int_a, type(int_a))print(float_b, type(float_b))print(str_c, type(str_c))# 复数complex_a = 1 + 2j # 实部 + 虚部complex_b = complex(3.14, 5.12) # complex(实部, 虚部)print(complex_a, type(complex_a))print(complex_b, type(complex_b))# 布尔bool_T = Truebool_F = Falseprint(bool_T, type(bool_T))print(bool_F, type(bool_F))# 逻辑运算# and，or，not - 与，或，非print(True or False)print(False and False)not False == True #do not use ! to refrence not15 == True</code></pre><hr><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><ul><li><code>and</code></li><li><code>exec</code></li><li><code>not</code></li><li><code>assert</code></li><li><code>finally</code></li><li><code>or</code></li><li><code>break</code></li><li><code>for</code></li><li><code>pass</code></li><li><code>class</code></li><li><code>from</code></li><li><code>print</code></li><li><code>continue</code></li><li><code>global</code></li><li><code>raise</code></li><li><code>def</code></li><li><code>if</code></li><li><code>return</code></li><li><code>del</code></li><li><code>import</code></li><li><code>try</code></li><li><code>elif</code></li><li><code>in</code></li><li><code>while</code></li><li><code>else</code></li><li><code>is</code></li><li><code>with</code></li><li><code>except</code></li><li><code>lambda</code></li><li><code>yield</code></li></ul><hr><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><pre><code class="Python"># 转义字符是“\”print(&quot;This is the first line...\nThis is the second line...&quot;)# 若不想让转义符生效，则可在字符串前添加“r”，表示原始字符串print(r&quot;This is the fitst lint...\nThis is the second line...&quot;)</code></pre><hr><h3 id="输出段落"><a href="#输出段落" class="headerlink" title="输出段落"></a>输出段落</h3><p>三个连续单引号或双引号进行标识</p><pre><code class="Python">print(&#39;&#39;&#39;Hello WorldHello PythonHello Anaconda&#39;&#39;&#39;)</code></pre><hr><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><pre><code class="Python"># 字符串拼接&quot;Hello&quot; + &quot; String&quot;# 输出 20 次 Hello&quot;Hello &quot; * 20 </code></pre><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code class="Python">list1 = [1,2,3,4]print(list1)print(list1[1])print(list1[-1]) # 从右向左输出第一个元素（倒序输出）</code></pre><pre><code class="Python"># 列表截取/切片list2 = [1,2,3,4,5,6]print(list2[0:3]) # 不包含尾/结束下标的元素，即4print(list2[-3:-1]) # 不包含倒数第一个下标元素，即6</code></pre><pre><code class="Python"># 切片步长list3 = [1,2,3,4,5,6]print(list3[::2]) # 不限制起点与终点下标，每隔2个步长进行打印print(list3[1::2]) # 从起点下标1开始，每隔2个步长进行打印</code></pre><hr><h3 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h3><ul><li>元组与列表类似，但元组<code>一旦定义即不能对数据进行修改</code>。</li><li>元组写在小括号里，元素之间用逗号隔开。</li><li>元组中元素的类型可以不相同，与列表类似。也支持嵌套。</li></ul><pre><code class="Python">tuple1 = (1,2,3,4,5,&quot;Hello World&quot;,[6,7,8,9],(10,11))print(tuple1,type(tuple1))print(tuple1[0])print(tuple1[-1])print(tuple1[5:-1])print(tuple1[-1][-1])</code></pre><hr><h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><ul><li>集合是一个<strong>无序的、且不含重复元素</strong>的序列</li><li>集合主要用来进行成员关系测试和删除重复元素</li><li>可以使用大括号{}或set()函数创建集合</li><li><strong>自动去重</strong></li></ul><pre><code class="Python">set1 = &#123;1,2,2,3,3,1&#125;print(set1)print(1 in set1) # 判断1是否存在于set1集合中，存在返回True，否则返回Flaseprint(5 in set1)set2 = &#123;1,2,3,4&#125;set3 = &#123;4,5,6&#125;</code></pre><hr><blockquote><p>集合操作</p></blockquote><pre><code class="Python"># 集合的并print(set2 | set3)# 集合的交print(set2 &amp; set3)# 集合的差print(set2 - set3)# 集合的补，在两个集合中不同时存在的元素集合print(set2 ^ set3)# 等同于 == （集合的并 - 集合的补）print((set2 | set3) - (set2 &amp; set3))</code></pre><hr><h3 id="字典（Dict）"><a href="#字典（Dict）" class="headerlink" title="字典（Dict）"></a>字典（Dict）</h3><ul><li>字典是一种映射，用{}标识，是一个无序的键(key)值(value)对的集合，<strong>键必须使用不可变的类型</strong></li><li>在同一个字典中，<strong>键的值是唯一</strong>的</li><li><code>在字典中的元素都是通过键来存取</code></li></ul><pre><code class="Python">dict1 = &#123;&quot;name&quot; : &quot;zhangsan&quot;,&quot;height&quot; : 175, &quot;weight&quot; : 72&#125;print(dict1[&quot;height&quot;]) # 通过键取值dict1[&quot;weight&quot;] = 73 # 修改字典数据。若字典中无该数据，则新增；反之覆盖.print(dict1)# 内置函数: clear(), keys(), values()print(dict1.keys()) # 输出键print(dict1.values()) # 输出值print(dict1.clear()) # 清空字典dict2 = &#123;&#125; # 构建空字典</code></pre><hr><h3 id="Print-格式化输出"><a href="#Print-格式化输出" class="headerlink" title="Print 格式化输出"></a>Print 格式化输出</h3><ul><li><code>%c</code> 格式化字符及其ASCII码</li><li><code>%s</code> 格式化字符串</li><li><code>%d</code> 格式化整数</li><li><code>%u</code> 格式化无符号整型</li><li><code>%o</code> 格式化无符号八进制数</li><li><code>%x</code> 格式化无符号十六进制数</li><li><code>%X</code> 格式化无符号十六进制数（大写）</li><li><code>%f</code> 格式化浮点数字，可指定小数点后的精度</li><li><code>%e</code> 用科学计数法格式化浮点数</li><li><code>%E</code> 作用同 <strong>%e</strong>，用科学计数法格式化浮点数</li><li><code>%g</code>  <strong>%f</strong> 和 <strong>%e</strong> 的简写</li><li><code>%G</code>  <strong>%f</strong> 和 <strong>%E</strong> 的简写</li></ul><pre><code class="Python"># `%c` 格式化字符及其ASCII码print(&quot;%c&quot; % &quot;A&quot;)print(&quot;%c&quot; % 65)# `%s` 格式化字符串print(&quot;%s&quot; % &quot;Hello World&quot;)# `%d` 格式化整数print(&quot;%d&quot; % 10)# `%o` 格式化无符号八进制数print(&quot;%o&quot; % 10)print(&quot;%#o&quot; % 10)# `%x` 格式化无符号十六进制数print(&quot;%x&quot; % 20)print(&quot;%#x&quot; % 20)print(&quot;%X&quot; % 20)# `%f` 格式化浮点数字，可指定小数点后的精度print(&quot;%f&quot; % 3.14)# `%e` 用科学计数法格式化浮点数# `%E` 作用同 %e，用科学计数法格式化浮点数print(&quot;%e&quot; % 31400000)# `%g`  %f 和 %e 的简写# `%G`  %f 和 %E 的简写print(&quot;%g&quot; % 3140000)print(&quot;%g&quot; % 31400000955)</code></pre><hr><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><pre><code class="Python">strNum = &quot;1&quot;print(int(strNum))strFloat = &quot;3.14159&quot;print(float(strFloat))print(str(456))print(ord(&quot;A&quot;)) # 转换ASII码print(chr(65)) # 识别ASII码对应的值print(chr(9999))</code></pre><pre><code class="Python">tuple1 = (1,2,3,4,5,5,6,6)print(tuple1)list1 = list(tuple1) # 元组转listprint(list1)set1 = set(list1) # list转集合(可起到去重的作用)print(set1)tuple2 = ((&quot;name&quot;,&quot;zhangsan&quot;),(&quot;height&quot;,172))print(tuple2)dict1 = dict(tuple2) # 元组转字典(当元组以键值对的形式存储时，可杯解析成字典)print(dict1)</code></pre><hr><h3 id="超级表达式"><a href="#超级表达式" class="headerlink" title="超级表达式"></a>超级表达式</h3><pre><code class="Python"># 方程式计算(超级表达式计算)x = 8calc = &quot;5*x+1&quot;print(eval(calc))</code></pre><hr><h3 id="条件（if）控制"><a href="#条件（if）控制" class="headerlink" title="条件（if）控制"></a>条件（if）控制</h3><pre><code class="Python"># 流程控制print(&quot;Please input your weight(kg)&quot;)weight = float(input()) # input() - 接收用户输入数据print(&quot;Please input your height(M)&quot;)height = float(input())# if weight &gt; 90:#     print(weight)    # if else# if weight &gt; 90:#     print(weight)# else:#     print(&quot;Bye&quot;)# if else ifBMI = weight / height**2if BMI &lt; 20:    print(&quot;Your BMI is %.2f, To thin&quot; %BMI)elif BMI &gt; 25:    print(&quot;Your BMI is %.2f, To fat&quot; %BMI)else:    print(&quot;Your BMI is %.2f, Well Done&quot; %BMI)</code></pre><hr><h3 id="条件（while）控制"><a href="#条件（while）控制" class="headerlink" title="条件（while）控制"></a>条件（while）控制</h3><pre><code class="Python"># 流程控制i = 0while i &lt; 5:    print(&quot;Hello World&quot;)    i += 1</code></pre><hr><h3 id="条件（for）控制"><a href="#条件（for）控制" class="headerlink" title="条件（for）控制"></a>条件（for）控制</h3><pre><code class="Python"># 流程控制# 遍历列表fruits = [&#39;banana&#39;, &#39;apple&#39;,&#39;mango&#39;]for fruit in fruits:    print(&#39;Current:&#39;,fruit)print(&quot;----------&quot;)    # for rangefor i in range(10):    print(&quot;Hello World&quot;)</code></pre><hr><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><pre><code class="Python">list1 = [1,2,3]list2 = [3,4,5]# 此处为双层循环# 分别从list1中取出1，2，3，并与ist2的值进行相乘(类似笛卡尔乘积？)[x * y for x in list1 for y in list2]# 数值判断的使用场景，从list1中取出大于1小于4的x值的值[x for x in list1 if 1 &lt; x &lt; 4]</code></pre><hr><h3 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h3><pre><code class="Python"># 流程控制# 多重循环# 九九乘法表for i in range(1,10):    for j in range(1, i+1):        result = j * i;        print(&quot;%s x %s = %-5s&quot; % (j, i , result),end=&#39;&#39;)    print() # 每次循环结束后换行</code></pre><hr><h3 id="Break"><a href="#Break" class="headerlink" title="Break"></a>Break</h3><pre><code class="Python"># 流程控制# 提前结束整个循环i = 0while i &lt; 10:    i += 1    if i == 3:        print(&quot;i == 3&quot;)        break    print(&quot;Next&quot;)print(&quot;End&quot;)</code></pre><hr><h3 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h3><pre><code class="Python"># 流程控制# 跳过当前循环中剩余语句，进入下一循环i = 0while i &lt; 10:    i += 1    if i == 3:        print(&quot;i == 3&quot;)    continue    print(&quot;Next&quot;)print(&quot;End&quot;)</code></pre><hr><h3 id="Pass"><a href="#Pass" class="headerlink" title="Pass"></a>Pass</h3><pre><code class="Python"># 流程控制# pass# 占位，不起实际作用i = 0while i &lt; 10:    i += 1    if i == 3:        pass # pass起到空语句的作用    elif i == 5:        print(&quot;i == 5&quot;)    print(&quot;Next&quot;)print(&quot;End&quot;)</code></pre><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre><code class="Python">&#39;&#39;&#39;    def functinoName(parameters):        &quot;函数帮助信息&quot;        functino_suite # 函数体        return [expression] # 返回值&#39;&#39;&#39;# Python的函数无需定义返回值类型# 此处定一个求阶乘!的函数def fact(n):    &quot;basic_use&quot;    result = 1    for i in range(1, n+1):        result *= i    return result# 调用上述fact函数result = fact(5)print(result)# 打印函数帮助信息fact.__doc__</code></pre><h3 id="函数返回多个值（即返回一个元组）"><a href="#函数返回多个值（即返回一个元组）" class="headerlink" title="函数返回多个值（即返回一个元组）"></a>函数返回多个值（即返回一个元组）</h3><pre><code class="Python">def fun_test(mList,mint=0,mString=&quot;Default String&quot;):    mList.append(&quot;New Item&quot;)    mint += 1    return mList, mint, mString</code></pre><pre><code class="Python">mTestList = [1,2,3]mTestInt = 10print(fun_test(mTestList,mTestInt))print(mTestList)print(&quot;----------&quot;)# 对返回的元组进行拆包，取出相应值returnV1, rerutnV2, returnV3 = fun_test(mTestList,mTestInt)print(returnV1)print(rerutnV2)print(returnV3)</code></pre><hr><h3 id="局部-全局变量"><a href="#局部-全局变量" class="headerlink" title="局部/全局变量"></a>局部/全局变量</h3><pre><code class="Python">number = 123def fun():    number = 321    print(number)fun()print(number)</code></pre><pre><code class="Python">number = 456def funGlobal():    global number # global 局部变量全局化，以达修改全局变量    number = 654    print(number)    funGlobal()print(number)</code></pre><hr><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><pre><code class="Python"># 类&#39;&#39;&#39;    class className:        &#39;类帮助信息&#39; # 类文档        class_suite # 类体&#39;&#39;&#39;# object 表示mFirstClass继承自object类class mFirstClass(object):    &#39;这是mFirstClass类的帮助文档&#39;        # classCount是类的一个属性，值在类中共享，可使用mFirstClass.classCount进行访问    # 即共有属性    classCount = 0        # self表示类的实例，self在定义类方法时是必要的，但在调用时为不必传入的参数    # __init__为类的构造函数    def __init__(self,name,schoolName):        self.name = name        self.schoolName = schoolName        mFirstClass.classCount += 1        def getName(self):        return self.name        def getSchoolName(self):        return self.schoolName        def showCount(self):        print(&quot;Total count % s&quot; % (mFirstClass.classCount))        def showMassage(self):        print(&quot;Name: %s, School: %s&quot; % (self.name,self.schoolName))</code></pre><hr><h3 id="类帮助文档"><a href="#类帮助文档" class="headerlink" title="类帮助文档"></a>类帮助文档</h3><pre><code class="Python"># 类帮助文档的使用print(mFirstClass.__doc__)</code></pre><hr><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><pre><code class="Python"># 类的实例化mClass1 = mFirstClass(&quot;name1&quot;,&quot;school1&quot;)mClass2 = mFirstClass(&quot;name2&quot;,&quot;school2&quot;)</code></pre><hr><h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><pre><code class="Python"># 访问类的属性print(mFirstClass.classCount)</code></pre><hr><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><pre><code class="Python"># 调用类方法mClass1.showCount()mClass2.showCount()mClass1.showMassage()mClass2.showMassage()</code></pre><hr><h3 id="获取类帮助信息"><a href="#获取类帮助信息" class="headerlink" title="获取类帮助信息"></a>获取类帮助信息</h3><pre><code class="Python"># Python 获取帮助信息# dir(instance)# 可调用dir来显示对象的所有方法dir(mClass1)</code></pre><hr><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><pre><code class="Python"># Python 文件操作# 文件写入# 第一个参数为待写入文件的地址，若文件存在即写入文件，不存在则新建文件后写入# &quot;wt&quot;为写入模式，write typewith open (&quot;testFiles/test.txt&quot;, &quot;wt&quot;) as out_file:    out_file.write(&quot;This is a new text&quot;)</code></pre><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><pre><code class="Python"># Python 文件操作# 文件读取# 第一个参数为读取文件地址，若文件存在即读取文件内容，若文件不存在则报错# &quot;rt&quot;为读取模式，read type# 调用read方法对文件进行读取with open(&quot;testFiles/test.txt&quot;, &quot;rt&quot;) as in_file:    text = in_file.read()print(text)</code></pre><hr><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><pre><code class="Python"># 异常# try catch在Python中为try exceptdef except_funtion():    try:        # 1.故意产生异常        10 / 0        # 2.正常操作        # 10 / 1    except ZeroDivisionError:        # Python有许多异常，但无法一一进行处理，若可以预先判定异常则最好，或使用通用异常反馈结果        print(&quot;Zero Division Error&quot;)    except :        # 通用异常反馈        print(&quot;System Error&quot;)    else:        # 正常情况        print(&quot;System all green&quot;)        pass    finally:        # 无论是否发生异常都会执行finally中的代码        print(&quot;We got finally&quot;)except_function()</code></pre><hr><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><blockquote><p>调用dir()来显示该对象的所有方法</p></blockquote><pre><code class="Python">dir(1)</code></pre><hr><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><blockquote><p>调用help()来查看该对象的详细信息</p></blockquote><pre><code class="Python">help(int)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAID -&gt; AHCI</title>
      <link href="Share-Convert-Windows-from-RAID-mode-to-AHCI-mode/"/>
      <url>Share-Convert-Windows-from-RAID-mode-to-AHCI-mode/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇整理了一些我在近期对笔记本<code>RAID模式与AHCI模式转换</code>的经验分享。</p></blockquote><blockquote><p>所使用配置清单：</p><ul><li>型号：<code>ASUS</code> ZenBook X2 Duo</li><li>系统：<code>Windows 10</code> Professional Workstation<br>由于家里的这台 Zenbook X2 Duo 只有一个硬盘位，且鉴于华硕出厂时对 BIOS 的奇葩配置，导致<code>硬盘设置（Advanced -&gt; SATA Configuration）</code>直接就是<code>RAID</code>（一个硬盘无法组成<a href="https://baike.baidu.com/item/RAID%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/10588130">磁盘阵列</a>，此时RAID于事无补），造成后期安装双系统时难以避免的<code>硬盘模式冲突</code>问题。</li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/RAID%20to%20AHCI/my_asus_disassemble.jpg"><hr><h2 id="RAID-to-AHCI"><a href="#RAID-to-AHCI" class="headerlink" title="RAID to AHCI"></a>RAID to AHCI</h2><p>由于出厂就设置的RAID导致Windows中缺少对AHCI的驱动支持，直接对BIOS中的硬盘设置进行修改也将导致Windows无法正常启动。</p><p>因此建议先保留RAID设置，在系统能正常运行的时候对引导进行修改，进入Windows的安全模式中让系统自动修复缺失的AHCI驱动。</p><p>操作过程如下：</p><ol><li><p><code>保持RAID模式</code>，正常开机</p></li><li><p>Win + R 运行 msconfig，在<code>引导标签页</code>下选择<code>安全引导</code>，让系统默认以安全模式重新启动。</p></li><li><p>重启电脑，进入BIOS，<code>修改硬盘模式为AHCI</code></p></li><li><p>系统将会自动以安全模式启动，并在启动期间尝试<code>自动修复AHCI驱动</code>。</p></li><li><p>在安全模式启动后，再次运行 Win + R 运行 msconfig，<code>取消安全引导</code>，让系统恢复正常启动。</p></li><li><p>重启电脑，系统将在AHCI模式下正常运行。</p></li></ol><hr><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/RAID%20to%20AHCI/windows_login.png">]]></content>
      
      
      <categories>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git • Github</title>
      <link href="Git-Manual/"/>
      <url>Git-Manual/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇将介绍我在学习<code>Git 与 Github 使用</code>的一些笔记分享。</p></blockquote><blockquote><p>Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。<br>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper 。</p></blockquote><hr><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><blockquote><p>配置 Github 用户名与邮箱。</p></blockquote><pre><code class="bash">git config --global user.name &quot;你的 Github 用户名&quot;git config --global user.email &quot;你的 Github 邮箱&quot;</code></pre><blockquote><p>检查 git 配置</p></blockquote><pre><code class="bash">git config --list</code></pre><blockquote><p>配置远端 SSH 公钥。</p></blockquote><pre><code class="bash"># 进入 ~/.ssh，若没有则创建（mkdir ~/.ssh）cd ~/.ssh# 生成公钥ssh-keygen -t rsa -C &quot;你的 Github 邮箱&quot;# 查看公钥文件cat id_rsa.pub</code></pre><blockquote><p>上传密钥</p></blockquote><p>访问Github并登录，点击右上角头像，进入 Settings - SSH and GPG keys,点击右上角的 New SSH key。</p><p>在 Key 输入框内填入 id_rsa.pub 中的全部内容。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Git/git_ssh_1.png"><hr><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Git/git_ssh_2.png"><blockquote><p>测试与 GitHub 的远端链接是否成功</p></blockquote><pre><code class="bash">ssh git@github.com</code></pre><hr><h2 id="Github-访问加速"><a href="#Github-访问加速" class="headerlink" title="Github 访问加速"></a>Github 访问加速</h2><blockquote><p>对于<code>Windows系统</code>，在日常使用过程中经常会出现访问速度慢的情况，此处将介绍通过修改 host 文件对 Github 进行加速的笔记。</p><p><code>Windows 环境</code>下的host文件位于：<strong>C:\Windows\System32\drivers\etc</strong>下<br>修改时需要管理员权限</p></blockquote><p>在尾部追加以下ip，有关 Github 的 IP 信息可到<a href="https://www.ipaddress.com/">ipaddress</a>上查询并<code>修改为自己所查询到的准确地址</code>。</p><p>如：</p><pre><code class="text">140.82.112.3    github.com199.232.69.194  github.global.ssl.fastly.net199.232.96.133  avatars.githubusercontent.com199.232.96.133  raw.githubusercontent.com199.232.96.133  user-images.githubusercontent.com199.232.96.133  camo.githubusercontent.com</code></pre><pre><code class="bash"># 刷新 DNS 缓存ipconfig /flushdns</code></pre><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Git/ipaddress.png" alt="ipaddress"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Git/hosts.png" alt="修改后的 host 文件"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理</title>
      <link href="School-Computer-Network-Technology/"/>
      <url>School-Computer-Network-Technology/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇整理了我学习<code>计算机网络原理</code>时的一些笔记。<br>所用教学平台：<a href="%22https://cn.netacad.com/%22">Cisco Networking Academy</a></p></blockquote><hr><h2 id="当今网络"><a href="#当今网络" class="headerlink" title="当今网络"></a>当今网络</h2><h3 id="网络影响着我们的生活"><a href="#网络影响着我们的生活" class="headerlink" title="网络影响着我们的生活"></a>网络影响着我们的生活</h3><p>当今世界有了网络，人与人的联系达到空前状态。当人们想到某个创意时，可以即时与其他人沟通，使创意变为现实。用来交流思想和信息的网上社区的形成可能会提高全球的生产力。云的创建让我们可以存储文档和图片，并随时随地访问它们。</p><hr><h3 id="网络组件"><a href="#网络组件" class="headerlink" title="网络组件"></a>网络组件</h3><blockquote><p>连接到网络并直接参与网络通信的所有计算机都属于主机。</p></blockquote><ul><li>主机可以被称为终端设备。某些主机也称为客户端。许多计算机在网络中既是服务器又是客户端。这种网络称为对等网络。</li><li>终端设备是指通过网络传输的消息的来源或目的地。中间设备将每台终端设备连接到网络，并且可以将多个独立的网络连接成网际网络。中间设备使用目的终端设备地址以及有关网络互连的信息来决定消息在网络中应该采用的路径。</li><li>介质为消息从源设备传送到目的设备提供了通道。</li></ul><hr><h3 id="网络表示方式和网络拓扑"><a href="#网络表示方式和网络拓扑" class="headerlink" title="网络表示方式和网络拓扑"></a>网络表示方式和网络拓扑</h3><blockquote><p>网络图通常使用图标来表示构成网络的不同设备和连接。图可以让人们轻松了解大型网络中的设备连接方式。这种网络“图”被称为“拓扑图”。</p></blockquote><ul><li><code>物理拓扑图</code>说明了中间设备和线缆安装的物理位置。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/1_3_1.png" alt="物理拓补图"></p><ul><li><code>逻辑拓扑图</code>说明了设备、端口和网络的编址方案。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/1_3_2.png" alt="逻辑拓扑图"></p><hr><h3 id="常见网络类型"><a href="#常见网络类型" class="headerlink" title="常见网络类型"></a>常见网络类型</h3><ul><li><p><code>小型家庭网络</code>将少量的几台计算机互联并将它们连接到互联网。</p></li><li><p><code>小型办公室/家庭办公室（SOHO）网络</code>可让一个家庭办公室或远程办公室内的计算机连接到企业网络或访问集中的共享资源。</p></li><li><p><code>中大型网络</code>（例如大型企业和学校使用的网络）可能有许多站点，包含成百上千台相互连接的主机。</p></li><li><p><code>互联网</code>是由网络组成的网络，连接全球亿万台计算机。</p></li></ul><hr><blockquote><p>两种最常见的网络基础设施类型是局域网（LAN）和广域网（WAN）。</p></blockquote><ul><li><p>LAN是<code>覆盖较小地理区域</code>的网络基础设施。</p><p>局域网具有如下特点：</p><ul><li><p>LAN 在有限区域（如家庭、学校、办公大楼或园区）内互连终端设备。</p></li><li><p>LAN <code>通常由一个组织或个人管理</code>。实行网络级管控、安全控制并制定访问控制策略。</p></li><li><p>LAN 为内部终端设备和中间设备<code>提供高速带宽</code>。</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/1_4_1.png" alt="LAN"></p><hr><ul><li><p>WAN是<code>覆盖广泛地理区域</code>的网络基础设施。WAN 通常由服务提供商（SP）或互联网服务提供商（ISP）管理。</p><p>WAN 具有如下特点:</p><ul><li><p>WAN 互连广泛地理区域（例如各大城市、州、省、国家/地区或大陆之间）内的 LAN。</p></li><li><p>WAN <code>通常由多个服务提供商管理</code>。</p></li><li><p>WAN 通常<code>提供 LAN 之间的较慢链路</code>。</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/1_4_2.png" alt="WAN"></p><hr><ul><li>互联网是一个<code>遍及全球的互相连接</code>的网络（简称互联网络或互联网）的集合。</li></ul><p>互联网<code>不属于任何个人或团体</code>。要确保通过这种多元化基础设施有效通信，需要<code>采用统一的公认技术和标准</code>，也需要众多网络管理机构相互协作。</p><p>为了维护互联网协议和进程的结构和标准化，人们建立了许多组织。这些组织包括<code>互联网工程任务组（IETF）</code>、<code>互联网名称与数字地址分配机构（ICANN）</code>和<code>互联网架构委员会（IAB）</code>，以及许多其他组织。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/1_4_3.png" alt="互联网"></p><hr><ul><li><p>内部网和外联网</p><blockquote><p>与术语“互联网”类似的另外两个术语是内部网和外联网。</p></blockquote><p><code>内部网</code>这个术语<code>用于表示一个组织的私有局域网和广域网连接</code>。内部网的<code>设计旨在仅允许该组织的成员、员工或其他获得授权的人员进行访问</code>。</p><p><code>组织可以使用外联网为在其他组织工作</code>，但需要本组织数据的人提供安全访问。如：</p><ul><li><p>公司为外部供应商和承包商提供访问。</p></li><li><p>医院为医生提供预约系统，以便医生为患者安排预约。</p></li><li><p>当地教育局为其管辖区的学校提供预算和人员信息。</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/1_4_4.png" alt="内部网和外联网"></p><hr><h3 id="Internet-连接"><a href="#Internet-连接" class="headerlink" title="Internet 连接"></a>Internet 连接</h3><ul><li><p>小型办公室/家庭办公室（SOHO）网络互联网连接方式：有线电视、DSL、蜂窝网络、卫星和拨号电话。</p></li><li><p>商务互联网（企业）连接方式：专用租用线路、地铁以太网、商务 DSL 和卫星。</p></li></ul><blockquote><p>选择哪种连接方式取决于地理位置和可供选择的运营商。</p><p>传统的独立网络使用不同的技术、规则和标准。</p></blockquote><ul><li>融合网络<code>通过相同的网络基础设施，在许多不同类型的设备之间传输数据、语音和视频</code>。这个网络的基础设施<code>采用一组相同的规则、协议和实施标准</code>。</li></ul><hr><h3 id="可靠网络"><a href="#可靠网络" class="headerlink" title="可靠网络"></a>可靠网络</h3><blockquote><p>“网络架构”是<code>指支持基础设施的技术以及通过该网络传输数据的编程服务及规则或协议</code>。</p></blockquote><p>随着网络的发展，我们了解到网络架构师必须解决<code>四个基本特征</code>，以满足用户的期望：</p><p>容错能力、可扩展性、服务质量（QoS）、安全性。</p><ul><li><p><code>容错</code>网络是在发生故障时限制受影响设备数量的网络。有多条路径到达目的地被称为冗余。</p></li><li><p><code>可扩展</code>的网络可以快速扩展，以支持新用户和应用程序。网络具有扩展能力，因为设计人员遵循广为接受的标准和协议。</p></li><li><p><code>QoS</code>是管理拥塞和确保向所有用户可靠传输内容的主要机制。网络管理员必须解决两种网络安全问题：网络基础设施安全和信息安全。</p></li><li><p>为了实现网络<code>安全</code>的目标，有三个主要要求：保密性、完整性和可用性。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/1_6_1.png" alt="容错性"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/1_6_2.png" alt="可拓展性"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/1_6_3.png" alt="服务质量(QoS)"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/1_6_4.png" alt="网络安全性"></p><hr><h3 id="网络趋势"><a href="#网络趋势" class="headerlink" title="网络趋势"></a>网络趋势</h3><blockquote><p>最近有几种网络趋势影响着组织和消费者：自带设备（BYOD）、在preview: 192线协作、视频通信和云计算。</p></blockquote><ul><li><p>BYOD 意味着设备由任何使用者在任意地点使用，包括笔记本电脑、上网本、平板电脑、智能手机和电子阅读器。</p></li><li><p>在线协作工具，如：Cisco Webex、腾讯会议、钉钉，为员工、学生、教师、客户和合作伙伴即时连接、交互和实现其目标提供了一种方法。</p></li><li><p>视频可用于通信、协作和娱乐。无论身处何地，只要能上网，任何人都可以接打视频电话。</p></li><li><p>云计算使我们可以在互联网上存储个人文件，甚至可以在服务器上备份整个硬盘驱动器。使用云可以访问文字处理和图片编辑等应用程序。</p></li></ul><hr><blockquote><p>云类型主要有四种：公有云、私有云、混合云和定制云。</p></blockquote><table><thead><tr><th align="center">云类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><strong>公有云</strong></td><td align="left">在公有云中提供的云应用和云服务， 可供大众使用。服务可能免费，也可能按 即用即付模式提供，比如按在线存储付费。公有 云利用互联网提供服务。</td></tr><tr><td align="center"><strong>私有云</strong></td><td align="left">私有云提供的基于云的应用和服务专供 特定组织或实体（例如政府）使用。私有 云可以使用组织的私有网络来搭建， 虽然构建和维护私有云的成本很高。私有 云也可以由具有严格访问安全控制的外部组织 管理。</td></tr><tr><td align="center"><strong>混合云</strong></td><td align="left">混合云由两个或多个云组成（例如：部分私有， 部分公共），其中每个部分仍然是一个不同的对象，但两者都 使用单一架构进行连接。混合云中的个人 将能够根据用户访问权限对各种服务进行 不同程度的访问。</td></tr><tr><td align="center"><strong>社区云</strong></td><td align="left">社区云是专为特定实体或组织使用而创建的。公共云和社区云之间的区别在于为团体定制的功能需求。例如，医疗机构必须遵从要求特殊身份验证和保密性的政策与法律（比如 HIPAA）。社区云由具有类似需求和关注的多个组织使用。社区云类似于公共云环境，但是具有一定级别的安全性、隐私性，甚至具有私有云的法规合规性。</td></tr></tbody></table><p>人们正在开发<code>可用于家里所有房间的智能家庭技术</code>。随着家庭网络和高速互联网技术的普及，智能家庭技术将变得越来越普遍。通过使用供电的同一线路，电力线网络通过按一定频率发送数据来发送信息。<code>无线互联网服务提供商（WISP）是使用类似家庭无线局域网（WLAN）的无线技术，将用户连接到专用的接入点或热点的ISP</code>。</p><hr><h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><blockquote><p>不论是小到只有单个互联网连接的家庭网络，还是大到拥有数以千计用户的企业网络，<code>网络安全都是计算机网络中不可或缺的一部分</code>。网络安全必须考虑环境以及网络的工具和需求。它必须能够保护数据安全，同时仍要满足网络的服务质量要求。</p></blockquote><p>保护网络涉及使用各种协议、技术、设备和工具来保护数据和防御威胁。<code>威胁因素可能来自外部，也可能来自内部</code>。当今许多外部网络安全威胁都来自互联网。</p><p><strong>网络有几种常见的<code>外部</code>威胁：</strong></p><ul><li><p><strong>病毒、蠕虫和特洛伊木马</strong> - 这些包括在用户设备上运行的恶意软件或代码。</p></li><li><p><strong>间谍软件和广告软件</strong> - 这些是安装在用户设备上的软件类型。这些软件会秘密收集有关用户的信息。</p></li><li><p><strong>零日攻击（0day）</strong> - 在出现漏洞的第一天发起的攻击。</p></li><li><p><strong>威胁参与者攻击</strong> - 恶意人员攻击用户设备或网络资源。</p></li><li><p><strong>拒绝服务攻击</strong> - 使网络设备上的应用和进程减缓或崩溃的攻击。</p></li><li><p><strong>数据拦截和窃取</strong> - 通过公司网络捕获私人信息的攻击。</p></li><li><p><strong>身份盗窃</strong> - 窃取用户的登录凭证来访问私人数据的攻击。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/1_8_1.png" alt="网络威胁"></p><hr><h3 id="安全解决方案"><a href="#安全解决方案" class="headerlink" title="安全解决方案"></a>安全解决方案</h3><blockquote><p>没有哪个单一的解决方案能保护网络不受到各式各样的现有威胁。因此，应使用多个安全解决方案在多个层上实施安全。当一个安全组件无法识别和保护网络时，其他组件可以保护网络。</p></blockquote><p><strong>这些是家庭或小型办公室网络的基本安全组件：</strong></p><ul><li><p><strong>防病毒和反间谍软件</strong> - 这些应用帮助防止终端设备感染恶意软件。</p></li><li><p><strong>防火墙过滤</strong> - 防火墙过滤阻止未经授权的进出网络访问。这可以是基于主机的防火墙系统，用于阻止未经授权访问终端设备，也可以是家用路由器上的基本过滤服务，用于阻止外部人员未经授权访问网络。</p></li></ul><hr><blockquote><p>企业网络的安全实施通常包含内嵌在网络中的许多组件来监控和过滤流量。理想情况下，所有组件配合工作，从而最大程度地减少维护并提高安全性。大型网络和公司网络使用防病毒、反间谍软件和防火墙过滤，但它们也有其他安全要求:</p></blockquote><p><strong>大型网络和公司网络使用防病毒、反间谍软件和防火墙过滤，但它们也有其他安全要求:</strong></p><ul><li><p><strong>专用防火墙系统</strong> - 提供更高级的防火墙功能，更详细地过滤大量数据流。</p></li><li><p><strong>访问控制列表（ACL）</strong> - 基于IP地址和应用程序，进一步过滤访问和流量转发。</p></li><li><p><strong>入侵防御系统（IPS）</strong> - 识别快速扩散的威胁，例如零日攻击或零小时攻击。</p></li><li><p><strong>虚拟专用网络（VPN）</strong> - 为远程工作人员提供对组织机构的安全访问。</p></li></ul><p>网络环境必须考虑网络安全要求以及各种应用和计算要求。家庭环境和企业必须能够保护他们的数据，同时满足每种技术的预期服务质量。此外，实施的安全解决方案必须适应不断发展变化的网络趋势。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/1_8_2.png" alt="安全解决方案"></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>网络影响着我的生活</li></ul><blockquote><p>当今世界有了网络，人与人的联系达到空前状态。当人们想到某个创意时，可以即时与其他人沟通，使创意变为现实。用来交流思想和信息的网上社区的形成可能会提高全球的生产力。云的创建让我们可以存储文档和图片，并随时随地访问它们。</p></blockquote><ul><li>网络组件</li></ul><blockquote><p>连接到网络并直接参与网络通信的所有计算机都属于主机。主机可以被称为终端设备。某些主机也称为客户端。许多计算机在网络中既是服务器又是客户端。这种网络称为对等网络。终端设备是指通过网络传输的消息的来源或目的地。中间设备将每台终端设备连接到网络，并且可以将多个独立的网络连接成网际网络。中间设备使用目的终端设备地址以及有关网络互连的信息来决定消息在网络中应该采用的路径。介质为消息从源设备传送到目的设备提供了通道。</p></blockquote><ul><li>网络表示方式和网络拓扑</li></ul><blockquote><p>网络图通常使用图标来表示构成网络的不同设备和连接。图可以让人们轻松了解大型网络中的设备连接方式。这种网络“图”被称为“拓扑图”。物理拓扑图说明了中间设备和线缆安装的物理位置。逻辑拓扑图说明了设备、端口和网络的编址方案。</p></blockquote><ul><li>常见网络类型</li></ul><blockquote><p>小型家庭网络将少量的几台计算机互联并将它们连接到互联网。小型办公室/家庭办公室 (SOHO) 网络可让一个家庭办公室或远程办公室内的计算机连接到企业网络或访问集中的共享资源。中大型网络（例如大型企业和学校使用的网络）可能有许多站点，包含成百上千台相互连接的主机。互联网是由网络组成的网络，连接全球亿万台计算机。两种最常见的网络基础设施类型是局域网 (LAN) 和广域网 (WAN)。LAN 是覆盖较小地理区域的网络基础设施。WAN 是覆盖广泛地理区域的网络基础设施。内部网表示一个组织的私有局域网和广域网连接。组织可以使用外联网为在其他组织工作，但需要本组织数据的人提供安全访问。</p></blockquote><ul><li>Internet 连接</li></ul><blockquote><p>SOHO互联网连接方式包括有线电视、DSL、蜂窝网络、卫星和拨号电话。商务互联网连接方式包括专用租用线路、地铁以太网、商务 DSL 和卫星。选择哪种连接方式取决于地理位置和可供选择的运营商。传统的独立网络使用不同的技术、规则和标准。融合网络通过相同的网络基础设施，在许多不同类型的设备之间传输数据、语音和视频。这个网络的基础设施采用一组相同的规则、协议和实施标准。Packet Tracer是一个灵活的软件程序，它让您有机会使用网络表示方式和理论来构建网络模型，并探索相对复杂的局域网和广域网。</p></blockquote><ul><li>可靠网络</li></ul><blockquote><p>术语“网络架构”是指支持基础设施的技术以及通过该网络传输数据的编程服务及规则或协议。随着网络的发展，我们了解到网络架构师必须解决四个基本特征，以满足用户的期望：容错能力、可扩展性、服务质量 (QoS) 和安全性。容错网络是在发生故障时限制受影响设备数量的网络。有多条路径到达目的地被称为冗余。可扩展的网络可以快速扩展，以支持新用户和应用程序。网络具有扩展能力，因为设计人员遵循广为接受的标准和协议。Qos是管理拥塞和确保向所有用户可靠传输内容的主要机制。网络管理员必须解决两种网络安全问题：网络基础设施安全和信息安全。为了实现网络安全的目标，有三个主要要求：保密性、完整性和可用性。</p></blockquote><ul><li>网络趋势</li></ul><blockquote><p>最近有几种网络趋势影响着组织和消费者：自带设备 (BYOD)、在线协作、视频通信和云计算。BYOD 意味着设备由任何使用者在任意地点使用。协作工具，如Cisco Webex，为员工、学生、教师、客户和合作伙伴即时连接、交互和实现其目标提供了一种方法。视频可用于通信、协作和娱乐。无论身处何地，只要能上网，任何人都可以接打视频电话。云计算使我们可以在互联网上存储个人文件，甚至可以在服务器上备份整个硬盘驱动器。使用云可以访问文字处理和图片编辑等应用程序。云类型主要有四种：公有云、私有云、混合云和定制云。人们正在开发可用于家里所有房间的智能家庭技术。随着家庭网络和高速互联网技术的普及，智能家庭技术将变得越来越普遍。通过使用供电的同一线路，电力线网络通过按一定频率发送数据来发送信息。无线互联网服务提供商 (WISP) 是使用类似家庭无线局域网 (WLAN) 的无线技术，将用户连接到专用的接入点或热点的 ISP。</p></blockquote><ul><li>网络安全</li></ul><blockquote><p>网络有几种常见的外部威胁：</p></blockquote><ol><li><strong>病毒、蠕虫和特洛伊木马</strong></li><li><strong>间谍软件和广告软件</strong></li><li><strong>零日攻击</strong></li><li><strong>威胁参与者攻击</strong></li><li><strong>拒绝服务攻击</strong></li><li><strong>数据拦截和窃取</strong></li><li><strong>身份盗窃</strong></li></ol><blockquote><p>这些是家庭或小型办公室网络的基本安全组件：</p></blockquote><ol><li><strong>防病毒和反间谍软件</strong></li><li><strong>防火墙过滤</strong></li></ol><blockquote><p>大型网络和公司网络使用防病毒、反间谍软件和防火墙过滤，但它们也有其他安全要求:</p></blockquote><ol><li><strong>专用防火墙系统</strong></li><li><strong>访问控制列表 (ACL)</strong></li><li><strong>入侵防御系统 (IPS)</strong></li><li><strong>虚拟专用网络 (VPN)</strong></li></ol><hr><h2 id="协议和模型"><a href="#协议和模型" class="headerlink" title="协议和模型"></a>协议和模型</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><blockquote><p>所有通信方法都有三个共同元素：消息源（发送方）、消息目的地（接收方）和信道。</p></blockquote><ul><li><p><strong>消息源（发送方）</strong> - 是需要向其他人或设备发送消息的人或电子设备。</p></li><li><p><strong>消息目的地（接收方）</strong> - 目的地接收并解释消息。</p></li><li><p><strong>信道</strong> - 这由为消息从源传送到目的地提供路径的介质组成。</p></li></ul><hr><blockquote><p>发送的消息由称为“协议”的规则管理。</p><p>协议必须包括：已识别的发送方和接收方、通用语言和语法、传输的速率和时序以及确认或确认要求。常用的计算机协议包括这些要求：消息编码、格式、封装、大小、时序、传输方式。</p></blockquote><ul><li><p><strong>编码</strong> - 是为了便于传输信息，将信息转换为另一种广为接受的形式。</p></li><li><p><strong>解码</strong> - 是编码的逆向过程，用来解释信息。</p></li><li><p><strong>消息格式和封装</strong> - 当消息从源发送到目的地时，必须使用特定的格式或结构，取决于消息的类型和传输信道。</p></li><li><p><strong>消息大小</strong></p></li><li><p><strong>消息时序</strong> - 流量控制、响应超时、访问方法。</p></li></ul><hr><p><strong>流量控制</strong>：定义了可以发送多少信息以及传递信息的速率。例如，如果一个人讲话太快，对方就难以听清和理解。在网络通信中，源设备和目的设备使用网络协议来协商和管理信息流。</p><p><strong>响应超时</strong>：如果一个人提问之后在合理的时间内没有得到回答，就会认为没有获得回答并作出相应的反应。此人可能会重复这个问题，也可能继续谈话。网络上的主机会使用网络协议来指定等待响应的时长，以及在响应超时的情况下执行什么操作</p><p><strong>访问方法</strong>：这决定人们可以发送消息的时间。</p><hr><p><code>消息传输方式</code>：单播（1：1）、组播（1：n - 1）和广播（1：n）。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_1.png" alt="消息传输方式"></p><hr><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><blockquote><p>网络协议定义了用于设备之间交换消息的通用格式和规则集。<code>协议由软件、硬件或两者中的终端设备和中间设备实现</code>。</p><p>通过计算机网络发送的消息通常需要使用多种协议，<code>每个网络协议都有自己的功能、格式和通信规则</code>。</p></blockquote><table><thead><tr><th align="center">协议类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><strong>网络<code>通信</code>协议</strong></td><td align="left">这类协议使两个或多个设备能够在一个或多个网络上通信。以太网技术家族涉及多种协议，例如：IP、TCP、HTTP等。</td></tr><tr><td align="center"><strong>网络<code>安全</code>协议</strong></td><td align="left">这类协议保护数据以提供身份验证、数据完整性和数据加密。安全协议的示例包括安全外壳协议（SSH）、安全套接字层协议（SSL）和传输层安全协议（TLS）。</td></tr><tr><td align="center"><strong><code>路由</code>协议</strong></td><td align="left">这类协议使路由器能够交换路由信息，比较路径 信息，然后选择到达目标网络的 最佳路径。路由协议的示例包括开放最短路径优先协议（OSPF）和边界网关协议（BGP）。</td></tr><tr><td align="center"><strong><code>服务发现</code>协议（设备或服务自动检测协议）</strong></td><td align="left">这类协议用于设备或服务的自动检测。 服务发现协议的示例包括发现用于IP地址分配 服务的动态主机配置协议（DHCP），和用于执行域名到IP地址转换的域名系统（DNS）。</td></tr></tbody></table><hr><h3 id="协议功能"><a href="#协议功能" class="headerlink" title="协议功能"></a>协议功能</h3><blockquote><p>计算机和网络设备使用商定的协议，这些协议提供以下功能：编址，可靠性，流量控制，排序，错误检测和应用程序接口。</p></blockquote><table><thead><tr><th align="center">功能</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><strong>编址</strong></td><td align="left">这使用已定义的编址方案来标识消息的发送者和预期的接收者。提供编址的协议示例，包括以太网，IPv4和IPv6。</td></tr><tr><td align="center"><strong>可靠性</strong></td><td align="left">此功能提供了有保证的传输机制，以防消息在传输过程中丢失或损坏。TCP提供可靠的传输。</td></tr><tr><td align="center"><strong>流量控制</strong></td><td align="left">此功能可确保数据在两个通信设备之间高效传输。TCP提供流量控制服务。</td></tr><tr><td align="center"><strong>排序</strong></td><td align="left">此功能唯一地标记每个传输的数据段。接收设备使用排序信息正确地重组信息。如果数据段丢失，延迟或未按顺序接收，这将很有用。TCP提供排序服务。</td></tr><tr><td align="center"><strong>差错检测</strong></td><td align="left">此功能用于确定传输过程中数据是否已损坏。提供差错检测的各种协议包括以太网，IPv4，IPv6和TCP。</td></tr><tr><td align="center"><strong>应用接口</strong></td><td align="left">此功能包含用于网络应用程序之间的进程间通信的信息。例如，访问网页时， 使用HTTP或HTTPS协议在客户端和服务器Web进程 之间进行通信。</td></tr></tbody></table><hr><h3 id="协议簇"><a href="#协议簇" class="headerlink" title="协议簇"></a>协议簇</h3><blockquote><p>在许多情况下，<code>协议必须能够与其他协议配合使用</code>，以便让在线体验为您提供网络通信所需的一切。<code>协议簇旨在相互无缝协作</code>。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_3_1.png" alt="协议簇"></p><p>执行某种通信功能所需的一组内在相关协议称为协议簇。</p><p>协议栈展示了协议簇中的单个协议是如何实施的。协议显示为分层结构，每种上层服务都依赖于其余下层协议所定义的功能。协议栈的下层负责通过网络传输数据和向上层提供服务，而上层则负责处理发送的消息内容。</p><hr><p>自20世纪70年代以来，出现了几种不同的协议簇，<code>有些是由一个标准组织开发的，有些是由不同的供应商开发的</code>。</p><p>在网络通信和互联网的发展过程中，出现了几个<code>相互竞争的协议簇</code>，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_3_2.png" alt="相互竞争的协议簇"></p><hr><h3 id="TCP-IP-协议示例"><a href="#TCP-IP-协议示例" class="headerlink" title="TCP/IP 协议示例"></a>TCP/IP 协议示例</h3><ul><li><p>TCP/IP 协议可用于应用层、传输层和互联网层。网络接入层中没有 TCP/IP 协议。最常见的网络接入层LAN协议是以太网和WLAN(无线LAN)协议。网络接入层协议负责通过物理介质传输 IP 数据包。</p></li><li><p>TCP/IP 是当今网络和互联网使用的协议簇。</p></li><li><p>TCP/IP 为供应商和制造商提供了两个重要的方面:开放标准协议簇和基于标准的协议簇。</p></li><li><p>TCP/IP 协议簇通信过程支持这样的过程：web 服务器封装 web 页面并将其发送到客户端，以及客户端解封 web 页面以便在 web 浏览器中显示。</p></li></ul><blockquote><p>图中显示了用于在主机的 web 浏览器和 web 服务器之间发送数据包的三种 TCP/IP 协议的示例。HTTP、TCP 和 IP 是所使用的 TCP/IP 协议。在网络接入层，示例中使用了以太网。然而，这里也可以使用一种无线标准，如WLAN或蜂窝服务。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_3_3.png" alt="示例"></p><h3 id="TCP-IP-协议簇"><a href="#TCP-IP-协议簇" class="headerlink" title="TCP/IP 协议簇"></a>TCP/IP 协议簇</h3><p>如今，TCP/IP 协议簇包含许多协议，并且不断发展以支持新服务。图中显示一些较为常用的协议。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_4.png" alt="TCP/IP 协议簇"></p><hr><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><blockquote><p>域名系统</p></blockquote><ul><li><strong>DNS</strong> - 域名系统。将域名转换为 IP 地址。</li></ul><blockquote><p>主机配置</p></blockquote><ul><li><p><strong>DHCPv4</strong> - IPv4动态主机配置协议。DHCPv4 服务器在启动时动态地将 IPv4 编址信息分配给 DHCPv4 客户端，并允许在不再需要时重新使用这些地址。</p></li><li><p><strong>DHCPv6</strong> - IPv6动态主机配置协议。DHCPv6类似于DHCPv4。DHCPv6服务器在启动时动态地将IPv6编址信息分配给DHCPv6客户端。</p></li><li><p><strong>SLAAC</strong> - 无状态地址自动配置。一种允许设备在不使用DHCPv6服务器的情况下获得其IPv6编址信息的方法。</p></li></ul><blockquote><p>邮件</p></blockquote><ul><li><p><strong>SMTP</strong> - 简单邮件传输协议。使客户端能够将邮件发送到邮件服务器，并使服务器能够将邮件发送到其他服务器。</p></li><li><p><strong>POP3</strong> - 邮局协议第 3 版。使客户端能够从邮件服务器检索电子邮件并将电子邮件下载到客户端本地邮件应用程序。</p></li><li><p><strong>IMAP</strong> - 互联网消息访问协议。使客户端能够访问存储在邮件服务器上的电子邮件，并在服务器上维护电子邮件。</p></li></ul><blockquote><p>文件传输</p></blockquote><ul><li><p><strong>FTP</strong> - 文件传输协议。它设置规则，使得一台主机上的用户能够通过网络访问另一台主机或向其传输文件。FTP是一种可靠、面向连接且进行确认的文件传输协议。</p></li><li><p><strong>SFTP</strong> - SSH文件传输协议。作为安全外壳 (SSH)协议的扩展，SFTP可用于建立安全的文件传输会话，在该会话中对文件传输进行加密。SSH 是一种安全远程登录的方法，通常用于访问设备的命令行。</p></li><li><p><strong>TFTP</strong> - 简单文件传输协议。这是一个简单的，无连接的文件传输协议，使用尽最大努力、无需确认的文件传输方式。它使用的开销比FTP少。</p></li></ul><blockquote><p>Web和Web服务</p></blockquote><ul><li><p><strong>HTTP</strong> - 超文本传输协议。这是有关在万维网上交换文本、图形图像、音频、视频以及其他多媒体文件的一组规则集。</p></li><li><p><strong>HTTPS</strong> - 安全HTTP。这是一种安全的HTTP形式，它对在万维网上交换的数据进行加密。</p></li><li><p><strong>REST</strong> - 具象状态传输协议。它使用应用程序编程接口 (API) 和 HTTP 请求创建 Web 应用程序的 Web 服务。</p></li></ul><hr><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><blockquote><p>面向连接</p></blockquote><ul><li><strong>TCP</strong> - 传输控制协议。它使运行在不同主机上的进程之间能够进行可靠的通信，并提供可靠的、需要确认的传输，以确保传输成功。</li></ul><blockquote><p>无连接</p></blockquote><ul><li><strong>UDP</strong> - 用户数据报协议。它允许一台主机上运行的进程向另一台主机上运行的进程发送数据包。但是，UDP不会确认数据报传输是否成功。</li></ul><hr><h3 id="互联网层"><a href="#互联网层" class="headerlink" title="互联网层"></a>互联网层</h3><blockquote><p>Internet 协议</p></blockquote><ul><li><p><strong>IPv4</strong> - 互联网协议第 4 版。它接收来自传输层的消息段，将消息打包成数据包，并为通过网络进行端到端传递的数据包进行地址分配。IPv4 使用 32 位地址。</p></li><li><p><strong>IPv6</strong> - 互联网协议第 6 版。与 IPv4 类似，但使用 128 位地址。</p></li><li><p><strong>NAT</strong> - 网络地址转换。将私有网络 IPv4 地址转换为全球唯一的公有 IPv4 地址。</p></li></ul><blockquote><p>消息传送</p></blockquote><ul><li><p><strong>ICMPv4</strong> - IPv4 互联网控制消息协议。目的主机针对数据包传输中出现的错误，向源主机提供反馈。</p></li><li><p><strong>ICMPv6</strong> - 用于 IPv6 的ICMP。与 ICMPv4 类似的功能，但用于 IPv6 数据包。</p></li><li><p><strong>ICMPv6 ND</strong> - IPv6 邻居发现。包括用于地址解析和重复地址检测的四个协议消息。</p></li></ul><blockquote><p>路由协议</p></blockquote><ul><li><p><strong>OSPF</strong> - 开放最短路径优先协议。它使用基于区域的分层设计的链路状态路由协议。OSPF是一种开放式标准内部路由协议。</p></li><li><p><strong>EIGRP</strong> — 增强型内部网关路由协议这是一种思科开发的开放标准路由协议，使用基于带宽、延迟、负载和可靠性的复合度量。</p></li><li><p><strong>BGP</strong> - 边界网关协议。这是一种开放标准的外部网关路由协议，用于互联网服务提供商(ISP)之间。BGP 还通常用于 ISP 与其大型私有客户端之间来交换路由信息。</p></li></ul><h3 id="网络接入层"><a href="#网络接入层" class="headerlink" title="网络接入层"></a>网络接入层</h3><blockquote><p>地址解析</p></blockquote><ul><li><strong>ARP</strong> - 地址解析协议。提供 IPv4 地址与硬件地址之间的动态地址映射。</li></ul><blockquote><p>数据链路协议</p></blockquote><ul><li><strong>以太网</strong> - 为网络接入层的布线和信令标准定义规则。</li><li><strong>WLAN</strong> - 无线局域网。定义 2.4 GHz 和 5 GHz 无线电频率的无线信号规则。</li></ul><hr><h3 id="开放标准"><a href="#开放标准" class="headerlink" title="开放标准"></a>开放标准</h3><p>开放标准<code>鼓励互操作性、竞争和创新</code>。</p><p>关于这一点有个不错的例子，您需要购买一个家用无线路由器。有出自众多供应商的许多不同路由器供您选择。这些路由器都融合了标准协议，例如 IPv4、IPv6、DHCP、SLAAC、以太网和 802.11无线局域网。这些开放标准还能够使运行 Apple 的 OS X 操作系统的客户端从运行 Linux 操作系统的 Web 服务器上下载网页。这是因为两种操作系统都实施开放标准协议，例如 TCP/IP 协议簇中的协议。</p><p><code>标准组织通常是中立于厂商的非营利性组织</code>。它的建立是为了发展和推广开放标准的概念。这些组织对维护一个开放的互联网，允许自由访问规范和协议并允许所有供应商实施这些规范和协议起着至关重要的作用。</p><p><code>标准组织可能会独立起草规则集，也可能在其他情况下将某个专有协议作为一个标准的基础</code>。如果要使用专有协议，通常就会涉及到创建了该协议的供应商。</p><hr><h3 id="互联网标准组织"><a href="#互联网标准组织" class="headerlink" title="互联网标准组织"></a>互联网标准组织</h3><p>各个组织在互联网和 TCP/IP 协议标准的推广和建立方面具有不同的责任。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_5_1.png" alt="互联网标准组织"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_5_2.png" alt="参与互联网开发和支持的标准组织"></p><hr><h3 id="电子和通信标准组织"><a href="#电子和通信标准组织" class="headerlink" title="电子和通信标准组织"></a>电子和通信标准组织</h3><ul><li><p><strong>电气电子工程师协会</strong>（IEEE，读作“I-triple-E”）– 是为致力于推动诸多行业领域的技术创新和标准创建的工程师设立的组织，涉及的领域包括电力与能源、医疗保健、电信和网络。重要的IEEE网络标准包括802.3以太网和802.11无线局域网标准。可在互联网上搜索其他IEEE网络标准。</p></li><li><p><strong>美国电子工业协会</strong>（EIA）- 该组织因其在用于安装网络设备的电线、连接器和19英寸机架方面的标准而知名。</p></li><li><p><strong>电信工业协会</strong>（TIA） - 该组织负责开发各种领域的通信标准，包括无线电设备、手机信号塔、IP 语音（VoIP）设备和卫星通信等。</p></li><li><p><strong>国际电信联盟电信标准局</strong>（ITU-T）- 是最大最早的通信标准组织之一。ITU-T定义视频压缩、Internet协议电视（IPTV）和宽带通信的标准，例如数字用户线路（DSL）。</p></li></ul><hr><h3 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h3><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_6.png" alt="开放式系统互联(OSI)参考模型 TCP/IP 参考模型"></p><p><code>OSI 模型有七层</code>：</p><blockquote><p>OSI 参考模型详细罗列了每一层可以实现的功能和服务。 这种类型的模型通过描述特定层必须完成什么但不规定如何完成来保持各类网络协议和服务中的一致性。</p></blockquote><table><thead><tr><th align="center">Num.</th><th align="center">Layer.</th><th align="center">数据单元</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">7</td><td align="center">应用层</td><td align="center">APDU</td><td align="left">应用层包含用于进程间通信的协议。</td></tr><tr><td align="center">6</td><td align="center">表示层</td><td align="center">PPDU</td><td align="left">表示层用常用方式表示数据在应用层服务之间的传输。</td></tr><tr><td align="center">5</td><td align="center">会话层</td><td align="center">SPDU</td><td align="left">会话层向表示层提供服务，组织对话并管理数据交换。</td></tr><tr><td align="center">4</td><td align="center">传输层</td><td align="center">TPDU</td><td align="left">传输层定义服务以对数据进行分段，传输和重组，以进行终端设备之间的单独通信。</td></tr><tr><td align="center">3</td><td align="center">网络层</td><td align="center">报文</td><td align="left">网络层为所标识的终端设备之间通过网络交换独立的数据的片段提供服务。</td></tr><tr><td align="center">2</td><td align="center">数据链路层</td><td align="center">帧</td><td align="left">数据链路层协议描述了设备之间通过公共介质交换数据帧的方法。</td></tr><tr><td align="center">1</td><td align="center">物理层</td><td align="center">比特</td><td align="left">物理层协议描述了机械的、电气的、功能的和程序化的方法，以激活，维护和解除物理连接， 实现与网络设备之间的位设备。</td></tr></tbody></table><hr><p><code>TCP/IP 模型包括四层</code>：</p><blockquote><p>用于网际通信的 TCP/IP 协议模型建立于二十世纪七十年代早期，<code>有时称为互联网模型</code>。 这种类型的模型与特定的协议簇结构紧密配合。TCP/IP 模型描述了 TCP/IP 协议簇中每个协议层实现的功能，因此属于协议模型。TCP/IP 也用作参考模型。下表显示了TCP/IP模型每一层的详细信息。</p></blockquote><table><thead><tr><th align="center">Num.</th><th align="center">Layer.</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">4</td><td align="center">应用层</td><td align="left">向用户提供数据，以及编码和对话控制。</td></tr><tr><td align="center">3</td><td align="center">传输层</td><td align="left">支持各种设备之间通过不同网络通信。</td></tr><tr><td align="center">2</td><td align="center">互联网层</td><td align="left">确定通过网络的最佳路径。</td></tr><tr><td align="center">1</td><td align="center">网络接入层</td><td align="left">控制组成网络的硬件设备和介质。</td></tr></tbody></table><hr><h3 id="OSI-模型与-TCP-IP-模型的比较"><a href="#OSI-模型与-TCP-IP-模型的比较" class="headerlink" title="OSI 模型与 TCP/IP 模型的比较"></a>OSI 模型与 TCP/IP 模型的比较</h3><blockquote><p>还可以根据 OSI 参考模型描述构成 TCP/IP 协议簇的协议。在 OSI 模型中，TCP/IP 模型的网络接入层和应用层被进一步划分，用于描述这些协议层需要实现的不同功能。</p></blockquote><p>TCP/IP 协议簇在网络接入层并没有指定通过物理介质传输时使用的协议，而只是描述了从互联网层到物理网络协议的传递。而 OSI 模型第 1 层和第 2 层则论述了接入介质所需的步骤以及通过网络发送数据的物理手段。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_7.png" alt="对比图"></p><hr><h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><blockquote><p>消息分段 -&gt; 排序 -&gt; 封装 -&gt; 解封</p></blockquote><ul><li><p><code>消息分段</code>主要有两个优点：</p><ul><li>通过从源设备向目的地<code>发送</code>一个个<code>小片段</code>，就可以在网络上交替发送许多不同会话。这称为<code>“多路复用”</code>。</li><li>分段可以<code>增强网络通信的效率</code>。如果有部分消息未能传送到目的，则<code>只需重新传输丢失的部分</code>。</li></ul></li><li><p>TCP负责对单独的数据段进行 <code>排序</code>。一段数据在任意协议层的表示形式称为协议数据单元（PDU）。</p></li><li><p>在 <code>封装</code>过程中，后续的每一层都根据使用的协议封装其从上一层接收的PDU。在网络中发送消息时，封装过程自上而下工作。</p></li><li><p>接收主机上的过程称为“解封”。<code>解封</code>是接收设备用来删除一个或多个协议报头的过程。数据在朝着最终用户应用程序沿协议栈向上移动的过程中被解封。</p></li></ul><hr><h3 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h3><blockquote><p>网络层（第3层）和数据链路层（第2层）负责将数据从源设备传输到目的设备。两层中的协议都包含源地址和目的地址，但它们的地址具有不同的用途。</p></blockquote><ul><li><p><strong>网络层源地址和目的地址</strong> - 负责将IP数据包从始源设备传输到可能处于同一网络或远程网络中的最终目的设备。</p></li><li><p><strong>数据链路层源地址和目的地址</strong> – 负责将数据链路层帧从一个网络接口卡（NIC）传输到同一网络上的另一个NIC。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_8.png" alt="地址的不同用途"></p><hr><h3 id="网络层（第3层）逻辑地址"><a href="#网络层（第3层）逻辑地址" class="headerlink" title="网络层（第3层）逻辑地址"></a>网络层（第3层）逻辑地址</h3><blockquote><p>IP 地址是网络层（或第 3 层）逻辑地址，用于将 IP 数据包从原始源设备传输到最终目的设备，如图所示。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_9.png" alt="IP数据包传输过程"></p><p><code>IP 数据包</code>包含两个IP地址：</p><ul><li><p><strong>源IP地址</strong> - <code>发送</code>设备（数据包的<code>始源设备</code>）的IP地址。</p></li><li><p><strong>目的IP地址</strong> - <code>接收</code>设备（数据包的<code>最终目的设备</code>）的IP地址。</p></li></ul><p>IP地址表示始源IP地址和最终目的IP地址。<code>无论源和目的地在同一IP网络上还是在不同的IP网络上，都是如此</code>。</p><hr><p><code>IP 地址</code>包含两部分：</p><ul><li><p><strong>网络部分（IPv4）或前缀（IPv6）</strong> – 地址<code>最左边的部分</code>，<code>表示</code>IP地址是哪个<code>网络</code>的<code>成员</code>。同一网络中所有设备的地址都有相同的网络部分。</p></li><li><p><strong>主机部分（IPv4）或接口ID（IPv6）</strong> - 地址的<code>其余部分</code>，用于<code>识别</code>网络上的<code>特定设备</code>。这部分对于网络中的每个设备或接口都是唯一的。</p></li></ul><hr><h3 id="同一网络（局域网）中的设备"><a href="#同一网络（局域网）中的设备" class="headerlink" title="同一网络（局域网）中的设备"></a>同一网络（局域网）中的设备</h3><p>在本示例中，客户端计算机 PC1 与<strong>同一 IP 网络</strong>中的 FTP 服务器进行通信。</p><ul><li><p><strong>源IPv4地址</strong> - 发送设备的IPv4地址，即客户端计算机PC1：192.168.1.110。</p></li><li><p><strong>目的IPv4地址</strong> - 接收设备的IPv4地址，即服务器，Web服务器：172.16.1.99。</p></li></ul><p>注意图中，源IPv4地址的网络部分和目的IPv4地址的网络部分是相同的，因此，源和目的地在同一个网络上。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_10.png" alt="同一网络"></p><hr><h3 id="数据链路层（第2层）地址的作用：相同的-IP-网络（局域网）"><a href="#数据链路层（第2层）地址的作用：相同的-IP-网络（局域网）" class="headerlink" title="数据链路层（第2层）地址的作用：相同的 IP 网络（局域网）"></a>数据链路层（第2层）地址的作用：相同的 IP 网络（局域网）</h3><blockquote><p>当IP数据包的发送方和接收方处于 **<code>同一网络</code>**中时，数据链路层帧将直接将其发送到接收设备。在以太网中，数据链路层地址称为以太网介质访问控制（MAC）地址。</p></blockquote><p><code>MAC 地址</code>是以太网网卡的物理内嵌地址。</p><ul><li><p><strong>源MAC地址</strong> - 这是发送封装有IP数据包的数据链路帧的设备的数据链路地址，或以太网 MAC 地址。以太网网卡的MAC地址为：AA-AA-AA-AA-AA-AA，以十六进制表示法表示。</p></li><li><p><strong>目的MAC地址</strong> - 当接收设备与发送设备在同一网络中时，这就是接收设备的数据链路层地址。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_11.png" alt="同一网络"></p><hr><h3 id="网络层地址的作用"><a href="#网络层地址的作用" class="headerlink" title="网络层地址的作用"></a>网络层地址的作用</h3><blockquote><p>当数据包的发送方与接收方位于 **<code>不同网络</code>**时，源 IP 地址和目的 IP 地址将代表位于不同网络的主机。这将由目的主机 IP 地址的网络部分来表明。</p></blockquote><ul><li><p><strong>源IPv4地址</strong> – 发送设备的IPv4地址，即客户端计算机PC1：192.168.1.110。</p></li><li><p><strong>目的IPv4地址</strong> – 接收设备的IPv4地址，即服务器，Web服务器：172.16.1.99。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_12.png" alt="不同网络"></p><hr><h3 id="数据链路层地址的作用：不同的IP网络"><a href="#数据链路层地址的作用：不同的IP网络" class="headerlink" title="数据链路层地址的作用：不同的IP网络"></a>数据链路层地址的作用：不同的IP网络</h3><blockquote><p>当 IP 数据包的发送方和接收方位于不同网络时，以太网数据链路帧不能直接发送到目的主机，因为在发送方的网络中无法直接到达该主机。必须将以太网帧发送到称为路由器或默认网关的另一设备。在我们的示例中，默认网关是 R1。R1 有一个以太网数据链路地址与 PC1 位于同一网络中。这使 PC1 能够直接到达路由器。</p></blockquote><ul><li><p>源 MAC 地址 - 发送设备 PC1 的以太网 MAC 地址。PC1 以太网接口的 MAC 地址是 AA-AA-AA-AA-AA-AA。</p></li><li><p>目的 MAC 地址 - 当接收设备（目的 IP 地址）与发送设备位于不同网络时，发送设备使用默认网关或路由器的以太网 MAC 地址。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_13.png" alt="不同网络"></p><hr><h3 id="数据链路层（第2层）地址"><a href="#数据链路层（第2层）地址" class="headerlink" title="数据链路层（第2层）地址"></a>数据链路层（第2层）地址</h3><p>数据链路层地址的作用是<code>将数据链路层帧从一个网络接口传输到同一网络中的另一个网络接口</code>。</p><p>在IP数据包可以通过有线或无线网络<code>发送之前</code>，必须将其<code>封装成数据链路层帧</code>，以便通过物理介质传输。</p><blockquote><p>当IP数据包从主机到路由器、从路由器到路由器和最终从路由器到主机传输时，沿途中的每个点上都会将IP数据包封装到新的数据链路层帧中。每个数据链路层帧包含发送帧的NIC卡的源数据链路层地址和接收帧的NIC卡的目的数据链路层地址。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_13_1.png" alt="主机到路由器"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_13_2.png" alt="路由器到路由器"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/2_13_3.png" alt="路由器到服务器"></p><blockquote><p>第2层，数据链路层协议仅用于在同一网络中的NIC之间传输数据包。路由器会将其NIC上收到的第2层信息删除，添加新的数据链路层信息，然后将数据包从通往最终目的地路径的出口NIC上转发出去。</p></blockquote><p>IP数据包会封装到包含以下数据链路层信息的数据链路层帧中：</p><ul><li><strong>源数据链路层地址</strong> - 发送数据链路层帧的网卡的物理地址。</li><li><strong>目的数据链路层地址</strong> - 接收数据链路层帧的NIC的物理地址。该地址为下一跳路由器，或最终目的设备的地址。</li></ul><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>规则</li></ul><blockquote><p>所有通信方法都有三个共同元素：消息源（发送方）、消息目的地（接收方）和信道。发送的消息由称为“协议”的规则管理。协议必须包括：已识别的发送方和接收方、通用语言和语法、传输的速率和时序以及确认或确认要求。常用的计算机协议包括这些要求：消息编码、格式、封装、大小、时序和传输方式。编码是为了便于传输信息，将信息转换为另一种广为接受的形式。解码是编码的逆向过程，用来解释信息。消息格式取决于消息的类型和传输信道。消息时序包括流量控制、响应超时和访问方法。消息传输方式包括单播、组播和广播。</p></blockquote><ul><li>协议</li></ul><blockquote><p>协议由终端设备和中间设备以软件、硬件或两者都有的方式实现。通过计算机网络发送的消息通常需要使用多种协议，每种协议都有自己的功能和格式。每个网络协议都有自己的功能、 格式和通信规则。以太网协议家族包括IP、TCP、HTTP等。安全协议保护数据以提供身份验证、数据完整性和数据加密：SSH、SSL 和 TLS。路由协议使路由器能够交换路由信息，比较路径信息，然后选择到目的网络的最佳路径：OSPF和BGP。用于设备或服务自动检测的协议有：DHCP 和 DNS。计算机和网络设备使用商定的协议，这些协议提供以下功能：编址，可靠性，流量控制，排序，错误检测和应用程序接口。</p></blockquote><ul><li>协议簇</li></ul><blockquote><p>执行某种通信功能所需的一组内在相关协议称为协议簇。协议栈展示了协议簇中的单个协议是如何实施的。自20世纪70年代以来，出现了几种不同的协议簇，有些是由一个标准组织开发的，有些是由不同的供应商开发的。TCP/IP协议可用于应用层、传输层和互联网层。TCP/IP 是当今网络和互联网使用的协议簇。TCP/IP为供应商和制造商提供了两个重要的方面:开放标准协议簇和基于标准的协议簇。TCP/IP协议簇通信过程支持这样的过程：web服务器封装web页面并将其发送到客户端，以及客户端解封web页面以便在web浏览器中显示。</p></blockquote><ul><li>标准组织</li></ul><blockquote><p>开放标准鼓励互操作性、竞争和创新。标准组织通常是中立于厂商的非营利性组织。它的建立是为了发展和推广开放标准的概念。各个组织在互联网标准的推广和建立方面具有不同的责任，包括：ISOC, IAB, IETF, 和IRTF。开发和支持TCP/IP的标准组织包括:：CANN和IANA。电子和通信标准组织包括：IEEE、EIA、TIA和ITU-T。</p></blockquote><ul><li>参考模型</li></ul><blockquote><p>用于描述网络运行的两个参考模型是OSI和TCP/IP。OSI 模型有七层：</p></blockquote><p>7 - 应用层</p><p>6 - 表示层</p><p>5 - 会话层</p><p>4 - 传输层</p><p>3 - 网络层</p><p>2 - 数据链路层</p><p>1 - 物理层</p><blockquote><p>TCP/IP 模型包括四层：</p></blockquote><p>4 - 应用层</p><p>3 - 传输层</p><p>2 - 互联网层</p><p>1 - 网络接入层</p><ul><li>数据封装</li></ul><blockquote><p>消息分段主要有两个优点：</p></blockquote><ol><li>通过从源设备向目的地发送一个个小片段，就可以在网络上交替发送许多不同会话。这称为“多路复用”。</li><li>分段可以增强网络通信的效率。如果有部分消息未能传送到目的，则只需重新传输丢失的部分。</li></ol><blockquote><p>TCP 负责对单独的数据段进行排序。一段数据在任意协议层的表示形式称为协议数据单元 (PDU)。在封装过程中，后续的每一层都根据使用的协议封装其从上一层接收的 PDU。在网络中发送消息时，封装过程自上而下工作。接收主机上的过程与之相反，称为“解封”。解封是接收设备用来删除一个或多个协议报头的过程。数据在朝着最终用户应用程序沿协议栈向上移动的过程中被解封。</p></blockquote><ul><li>数据访问</li></ul><p>网络层和数据链路层负责将数据从源设备传输到目的设备。两层中的协议都包含源地址和目的地址，但它们的地址具有不同的用途。</p><ol><li><strong>网络层源地址和目的地址</strong> - 负责将 IP 数据包从始源设备传输到可能处于同一网络或远程网络中的最终目的设备。</li><li><strong>数据链路层源地址和目的地址</strong> – 负责将数据链路层帧从一个网络接口卡 (NIC) 传输到同一网络上的另一个 NIC。</li></ol><blockquote><p>IP 地址表示始源IP地址和最终目的IP地址。一个IP地址包含两部分：网络部分(IPv4)或前缀(IPv6)和主机部分(IPv4)或接口ID (IPv6)。当 IP 数据包的发送方和接收方处于同一网络中时，数据链路层帧将直接将其发送到接收设备。在以太网中，数据链路层地址称为以太网介质访问控制（MAC）地址。当数据包的发送方与接收方位于不同网络时，源 IP 地址和目的 IP 地址将代表位于不同网络的主机。必须将以太网帧发送到称为路由器或默认网关的另一设备。</p></blockquote><hr><h2 id="物理层（第-1-层）"><a href="#物理层（第-1-层）" class="headerlink" title="物理层（第 1 层）"></a><a href="https://phoenixnest.github.io/School-Computer-Network-Technology-1-Physical-Layer/">物理层（第 1 层）</a></h2><hr><h2 id="数据链路层（第-2-层）"><a href="#数据链路层（第-2-层）" class="headerlink" title="数据链路层（第 2 层）"></a><a href="https://phoenixnest.github.io/School-Computer-Network-Technology-2-Data-Link-Layer/">数据链路层（第 2 层）</a></h2><hr><h2 id="以太网交换"><a href="#以太网交换" class="headerlink" title="以太网交换"></a>以太网交换</h2><h3 id="以太网封装"><a href="#以太网封装" class="headerlink" title="以太网封装"></a>以太网封装</h3><blockquote><p><code>以太网是如今广泛使用的两种局域网技术之一，另一种是无线局域网（WLAN）</code>。它使用有线通信，包括双绞线、光纤链路和同轴电缆。</p></blockquote><p><code>以太网在数据链路层和物理层运行</code>，是 IEEE 802.2 和 802.3 标准中定义的一系列网络技术。以太网支持的数据带宽为：</p><ul><li><p><strong>10 Mbps</strong></p></li><li><p><strong>100 Mbps</strong></p></li><li><p><strong>1000 Mbps (1 Gbps)</strong></p></li><li><p><strong>10,000 Mbps (10 Gbps)</strong></p></li><li><p><strong>40,000 Mbps (40 Gbps)</strong></p></li><li><p><strong>100,000 Mbps (100 Gbps)</strong></p></li></ul><p>如图所示，<code>以太网标准同时定义第 2 层协议和第 1 层技术</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_1.png" alt="以太网和 OSI 模型"></p><hr><h3 id="数据链路子层"><a href="#数据链路子层" class="headerlink" title="数据链路子层"></a>数据链路子层</h3><blockquote><p>IEEE 802 LAN/MAN 协议，包括以太网，使用以下两个单独的数据链路层子层进行操作。它们是逻辑链路控制（LLC）和介质访问控制（MAC），如图所示。</p></blockquote><p>回想一下，LLC 和 MAC 在数据链接层中具有以下角色：</p><ul><li><p><strong>LLC 子层</strong> - 此 IEEE 802.2 子层<code>在上层的网络软件与下层的设备硬件之间进行通信</code>。它放入帧中的信息用于确定帧所使用的网络层协议。此信息允许多个第 3 层协议（如 IPv4 和 IPv6）使用相同的网络接口和介质。</p></li><li><p><strong>MAC 子层</strong> -此子层（例如 IEEE 802.3、802.11 或 802.15）<code>在硬件中实现</code>，负责数据封装和介质访问控制。它<code>提供数据链路层寻址，并与各种物理层技术集成</code>。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_2.png" alt="数据链路子层"></p><hr><h3 id="MAC-子层"><a href="#MAC-子层" class="headerlink" title="MAC 子层"></a>MAC 子层</h3><blockquote><p>MAC 子层负责数据封装和访问介质。</p></blockquote><p>数据封装</p><p>IEEE 802.3 数据封装包括以下内容：</p><ul><li><p><strong>以太网帧</strong> - 这是以太网帧的内部结构。</p></li><li><p><strong>以太网寻址</strong> - 以太网帧中包含源和目的MAC 地址，用于将该以太网帧从以太网网卡传送到同一LAN上的以太网网卡。</p></li><li><p><strong>以太网错误检测</strong> - 以太网帧中包含用于错误检测的帧校验序列 (FCS) 帧尾。<br>访问介质</p></li></ul><p>如图所示，IEEE 802.3 MAC 子层包含了在各种介质(包括铜和光纤)上不同类型的以太网通信标准的规格。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_3.png" alt="MAC 子层"></p><blockquote><p>回想一下，使用总线拓扑或集线器的传统以太网是一种共享的半双工介质。<strong>半双工介质上的以太网使用争用访问方法，即载波侦听多路访问/冲突检测 (CSMA/CD)，这确保一次只有一个设备进行传输。</strong>CSMA/CD 允许多个设备共享相同的半双工介质，如果多台设备同时传输，则会发生冲突。它还提供了一种回退重传算法。</p></blockquote><p><code>如今的以太网 LANs 使用的交换机是全双工的</code>。在全双工模式下运行的以太网交换机不需要通过 CSMA/CD 进行访问控制。</p><hr><h3 id="以太网帧字段"><a href="#以太网帧字段" class="headerlink" title="以太网帧字段"></a>以太网帧字段</h3><p>以太网帧大小的最小值为 64 个字节，最大值为 1518 个字节。这包括从“目的 MAC 地址”字段到“帧校验序列 (FCS)”字段的所有字节。在描述帧的大小时，不包含“前导码”字段。</p><p>任何长度小于 64 个字节的帧都被接收站点视为“冲突碎片”或“残帧”而自动丢弃。超过 1500 个字节的数据帧被视为“巨帧”或“小型巨型帧”。</p><p>如果发送的帧小于最小值或者大于最大值，接收设备将会丢弃该帧。帧之所以被丢弃，可能是因为冲突或其他多余信号。它们被视为无效。大多数快速以太网和千兆以太网交换机和网卡通常都支持巨帧。</p><p>这张图显示了以太网帧中的每个字段。有关每个字段功能的详细信息，请参阅表格。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_4.png" alt="以太网帧字段"></p><hr><blockquote><p>以太网帧字段细节</p></blockquote><table><thead><tr><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>前导码和帧首定界符字段</strong></td><td align="left"><code>前导码</code>（<strong>7 字节</strong>）和<code>帧首定界符</code>（SFD），也称为 <code>帧首</code>（<strong>1 字节</strong>），该字段<code>用于发送设备与接收设备之间的同步</code>。帧开头的<strong>8 个字节</strong> 用于引起接收节点的注意。**<code>基本上，前几个字节的作用是告诉接收方准备接收新帧。</code>**</td></tr><tr><td align="left"><strong>目的 MAC 地址字段</strong></td><td align="left">该 <strong>6 字节</strong>字段是<code>预期接收方的标识符</code>。读者应该还记得， <code>此地址被第2层用来协助设备 确定帧是否发送到目的地</code>。帧中的地址将会与设备中的 MAC 地址进行比对。如果匹配， 设备就接受该帧。可以是单播、组播或广播 地址。</td></tr><tr><td align="left"><strong>源 MAC 地址字段</strong></td><td align="left">该 <strong>6 字节</strong>字段<code>标识发出帧的网卡 或接口</code>。</td></tr><tr><td align="left"><strong>类型/长度</strong></td><td align="left">该字段包含<strong>2 字节</strong>，<code>标识封装于以太网帧中的上层协议</code>。常见值为十六进制，<code>0x800 用于 IPv4</code>， <code>0x86DD 用于 IPv6</code>，<code>0x806 用于 ARP</code>。<strong>注意：您也可能会看到此字段称为 EtherType、类型或长度。</strong></td></tr><tr><td align="left"><strong>数据字段</strong></td><td align="left">该字段（<strong>46-1500 字节</strong>）包含来自较高层的封装数据，<code>一般是第3层PDU或更常见的IPv4 数据包</code>。**<code>所有帧至少必须有 64 个字节。如果封装的是小数据包， 则使用填充位将帧 增大到最小值</code>**。</td></tr><tr><td align="left"><strong>帧校验序列字段</strong></td><td align="left">“帧校验序列 (FCS)”字段（<strong>4 个字节</strong>）用于检测帧中 的错误。它使用循环冗余校验（CRC）。<code>发送设备</code>在帧的 FCS 字段中包含 CRC 的结果。<code>接收设备</code>接收帧并生成 CRC 以查找 错误。**<code>如果计算匹配，就不会发生错误</code>**。 **<code>计算不匹配则表明数据已经改变。因此， 帧会被丢弃</code>**。数据的变化可能是由于代表比特位的电信号受到干扰所致。</td></tr></tbody></table><hr><h3 id="MAC-地址和十六进制"><a href="#MAC-地址和十六进制" class="headerlink" title="MAC 地址和十六进制"></a>MAC 地址和十六进制</h3><p>在网络中，<code>IPv4 地址使用十进制以10为基数的数制系统和二进制以2为基数的数制系统来表示</code>。<code>IPv6 地址和以太网地址使用十六进制以16为基数的数制系统表示</code>。</p><blockquote><p>十六进制是以 16 为基数的数制系统，使用数字 0 到 9 和字母 A 到 F。</p><p>以太网 MAC 地址由48位二进制值组成。十六进制用于标识以太网地址，因为单个十六进制数字表示四个二进制位。因此，一个48位以太网MAC地址只用12个十六进制值就可以表示。</p></blockquote><p>该图显示了 0000 (0) ~ 1111 (15) 这些二进制数的十进制和十六进制值。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_5_1.png" alt="MAC 地址和十六进制"></p><hr><blockquote><p>8 位（1 字节）是一种常用的二进制组，从 00000000 到 11111111 的二进制可表示为从 00 到 FF 的十六进制。</p></blockquote><p>如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_5_2.png" alt="选定的十进制、二进制和十六进制等值数字"></p><blockquote><p>当使用十六进制时，前导零始终都会显示，以完整的 8 位表示。例如，在表中，二进制值 0000 1010 以十六进制显示为 0A。</p></blockquote><p><code>十六进制通常以0x为前导的值</code>（例如 0x73）表示，以区分文档中的十进制值和十六进制值。</p><p><code>十六进制也可以用以16为下标的值或十六进制数字后跟 H</code>（例如 73H）来表示。</p><blockquote><p>如果需要在十进制值和十六进制值之间进行转换，先将十进制或十六进制值转换为二进制值，然后将二进制值转换为适当的十进制或十六进制值。</p></blockquote><hr><h3 id="以太网-MAC-地址"><a href="#以太网-MAC-地址" class="headerlink" title="以太网 MAC 地址"></a>以太网 MAC 地址</h3><p><code>在以太网中，每台网络设备都连接到同一个共享介质</code>。<code>MAC 地址用于标识本地网段上的物理源和目的设备</code>。MAC 编址为 OSI 模型的数据链路层提供了设备识别方法。</p><blockquote><p>以太网 MAC 地址是使用 <strong>12</strong> 个<strong>十六进制数字</strong>表示的 <strong>48</strong> 位地址，如图所示。<strong>因为一个字节等于 8 位，我们也可以说 一个MAC 地址长度为 6 个字节</strong>。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_5_3.png"><hr><p><code>所有 MAC 地址对于以太网设备或以太网接口必须是唯一的</code>。为了确保这一点，所有销售以太网设备的供应商必须向 IEEE 注册才能获得唯一的 6个十六进制（即 24 位或 3 字节）代码，称为组织唯一标识符 (OUI)。</p><p>当供应商为设备或以太网接口分配 MAC 地址时，供应商必须执行以下操作：</p><ul><li><p>使用其分配的 OUI 作为前 6 个十六进制数字。</p></li><li><p>为后 6 个十六进制数字分配唯一值。</p></li></ul><p>因此，以太网 MAC 地址由6个十六进制供应商 OUI 代码和6个十六进制供应商分配的值组成，如图所示。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_5_4.png"><p>例如，假设思科需要为新设备分配唯一的 MAC 地址。IEEE 已经给思科分配了一个OUI 00-60-2F. 然后思科将唯一的供应商代码配置给设备，如 3A-07-BC。因此，该设备的以太网 MAC 地址将是 00-60-2F-3A-07-BC.</p><blockquote><p>供应商有责任确保其设备不被分配相同的 MAC 地址。但是，由于制造过程中出现的错误、某些虚拟机部署方式中的错误或使用多种软件工具之一进行的修改，可能存在重复的 MAC 地址。若出现以上任一情况，必须在新网卡或软件中修改 MAC 地址。</p></blockquote><hr><h3 id="帧处理"><a href="#帧处理" class="headerlink" title="帧处理"></a>帧处理</h3><p><code>MAC 地址通常称为烧录地址（BIA）</code>，因为传统上该地址被烧录到网卡的只读存储器（ROM）中。这意味着该地址会永久编码到 ROM 芯片中。</p><blockquote><p>注意: 在现代 PC 操作系统和网卡中，可以在软件中更改MAC 地址。当试图访问基于 BIA 进行过滤的网络时，这一点非常有用。因此，根据 MAC 地址来过滤或控制流量就不再安全了。</p></blockquote><p>当计算机启动时，网卡将 MAC 地址从 ROM 复制到 RAM 中。设备在向以太网络转发消息时，以太网报头包含这些：</p><ul><li><p><strong>源 MAC 地址</strong> – 这是源设备网卡的 MAC 地址。</p></li><li><p><strong>目的 MAC 地址</strong> -这是目标设备网卡的 MAC 地址。</p></li></ul><hr><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_5_5.png" alt="H1向H3发送以太网帧，当帧到达中继器时将转发至H2、H3、H4，转发结束后由各终端进行判断，若为帧的目的接收设备，则进行接受，反之终端不予理会。"></p><blockquote><p>收到以太网帧时，网卡会查看帧中的目的 MAC 地址是否与设备 RAM 中存储的物理 MAC 地址匹配。如果不匹配，设备就会丢弃帧。如果与帧中的目的 MAC 匹配，则网卡会将帧向上传送到 OSI 层进行解封处理。</p><p>注意:如果目的 MAC 地址是主机为其成员的广播或组播组时，以太网网卡也会接收帧。</p></blockquote><p><code>任何</code>作为以太网帧的源或目的设备都有一个以太网网卡，因此也有一个MAC地址。这些设备包括工作站、服务器、打印机、移动设备和路由器。</p><hr><h3 id="单播-MAC-地址"><a href="#单播-MAC-地址" class="headerlink" title="单播 MAC 地址"></a>单播 MAC 地址</h3><p>在以太网中，第 2 层单播、组播和广播通信会使用不同的 MAC 地址。</p><p>单播 MAC 地址是帧从一台发送设备去往一台目的设备时使用的唯一地址。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_5_6.png" alt="IPv4 地址为 192.168.1.5 的主机（源）向 IPv4 单播地址为 192.168.1.200 的服务器请求网页，目的 MAC 地址和目的 IP 地址均为单播。"></p><blockquote><p>要传送和接收单播数据包，目的 IP 地址必须包含于 IP 包报头中。相应的目的 MAC 地址也必须出现于以太网帧报头中。只有 IP 地址和 MAC 地址相结合才能将数据传送到特定的目的主机。</p></blockquote><blockquote><p>源主机用来确定目的IPv4地址所对应的目的 MAC 地址的流程称为地址解析协议 (ARP)。源主机用来确定目的IPv6地址所对应的目的 MAC 地址的流程称为邻居发现 (ND)。</p></blockquote><blockquote><p><strong>注意: 源 MAC 地址必须始终为单播地址</strong>。</p></blockquote><hr><h3 id="广播-MAC-地址"><a href="#广播-MAC-地址" class="headerlink" title="广播 MAC 地址"></a>广播 MAC 地址</h3><p>以太网广播帧由以太网LAN上的每个设备接收和处理。以太网广播的功能如下：</p><ul><li><p>它有一个十六进制（在二进制中是 48 个 1）FF-FF-FF-FF-FF-FF的目的 MAC 地址。</p></li><li><p>它向除输入端口以外的所有以太网交换机端口泛洪。</p></li><li><p>路由器不会转发该帧。</p></li></ul><blockquote><p>如果封装的数据是IPv4广播包，这意味着该数据包包含一个目的IPv4地址，该地址的主机部分全部为1。这种地址值表示本地网络（广播域）中的所有主机都将接收和处理该数据包。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_5_7.png" alt="源主机向其网络中的所有设备发送 IPv4 广播数据包。IPv4 目的地址为广播地址 192.168.1.255。如果 IPv4 广播数据包被封装在以太网帧内，则目的 MAC 地址为十六进制（在二进制中是 48 个 1）的 FF-FF-FF-FF-FF-FF 广播 MAC 地址。"></p><p>IPv4 的 DHCP 是使用以太网和 IPv4 广播地址的一个协议示例。</p><blockquote><p>但是，<strong>并非所有以太网广播都带有 IPv4 广播数据包</strong>。例如，ARP 请求不使用 IPv4，但 ARP 消息却作为以太网广播发送。</p></blockquote><hr><h3 id="组播-MAC-地址"><a href="#组播-MAC-地址" class="headerlink" title="组播 MAC 地址"></a>组播 MAC 地址</h3><p>以太网组播帧由属于同一组多播组的以太网LAN上的一组设备接收和处理。以太网组播的功能如下：</p><ul><li><p><strong>当封装数据为IPv4组播包时，目的 MAC 地址为 01-00-5E；当封装数据为 IPv6 组播包时，目的 MAC 地址为 33-33。</strong></p></li><li><p><strong>当封装的数据不是IP时，还有其他预留的组播目的 MAC 地址，如生成树协议（STP）和链路层发现协议(LLDP)。</strong></p></li><li><p><strong>除非交换机被配置为用于组播窥探，否则它将向除传入端口之外的所有以太网交换机端口泛洪。</strong></p></li><li><p><strong>它不会由路由器转发，除非路由器配置为路由组播数据包。</strong></p></li></ul><blockquote><p>如果封装的数据是一个 IP 组播包，则属于组播组的设备都分配有该组播组 IP 地址。IPv4 组播地址的范围为 224.0.0.0 到 239.255.255.255。IPv6 组播地址的范围以 ff00::/8 开头。由于组播地址代表一组地址（有时称为主机组），因此只能用作数据包的目的地址。源地址始终应为单播地址。</p></blockquote><p>如同单播和广播地址一样，组播 IP 地址也需要相应的组播 MAC 地址才能在本地网络中传送帧。组播 MAC 地址与 IPv4 或 IPv6 组播地址相关联，并使用来自 IPv4 或 IPv6 的编址信息。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_5_8.png" alt="目的 MAC 地址和目的 IP 地址都是广播。"></p><p>路由协议和其他网络协议会使用组播地址。视频和图像软件等应用程序也可能使用组播地址，尽管组播应用程序并不常见。</p><hr><h3 id="MAC-地址表-交换机"><a href="#MAC-地址表-交换机" class="headerlink" title="MAC 地址表 - 交换机"></a>MAC 地址表 - 交换机</h3><p>既然您已经了解了所有关于以太网MAC地址的知识，现在就该讨论交换机如何使用这些地址将帧转发(或丢弃)到网络上的其他设备。如果交换机只是转发出它接收到的每一帧到所有端口，您的网络将会非常拥挤，以至于它可能会完全停止工作。</p><p>第 2 层以太网交换机使用 MAC 地址做出转发决策。它完全忽视帧的数据部分的协议，例如 IPv4 数据包，一个ARP消息或一个IPv6 ND数据包。交换机仅根据第 2 层以太网 MAC 地址做出转发决策。</p><p>一个以太网交换机检查它的MAC地址表，为每个帧做出一个转发决策，不像传统的以太网集线器，向除了传入端口以外的所有端口重复发出比特位。如图所示，四端口交换机已启动。如表所示，MAC地址表还未获知四台连接的 PC 的 MAC 地址。</p><p>注意: 缩短 MAC 地址是为了便于演示。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_6_1.png" alt="交换机"></p><p>注意: MAC 地址表有时也称为内容可寻址内存 (CAM) 表。虽然 CAM 表这一术语相当常见，但在本课程中，我们将称其为 MAC 地址表。</p><hr><h3 id="交换机学习和转发"><a href="#交换机学习和转发" class="headerlink" title="交换机学习和转发"></a>交换机学习和转发</h3><blockquote><p>交换机通过检查端口传入帧的源 MAC 地址来动态构建 MAC 地址表。交换机通过匹配帧中的目的 MAC 地址与 MAC 地址表中的条目来转发帧。</p></blockquote><p><strong>检查源MAC地址</strong></p><blockquote><p>进入交换机的每个帧被检查，以确定其中是否有可被学习的新信息。它是通过检查帧的源 MAC 地址和帧进入交换机的端口号来完成这一步的。如果源 MAC 地址不存在，会将其和传入端口号一并添加到表中。如果源 MAC 地址已存在于表中，则交换机会更新该条目的刷新计时器。默认情况下，大多数以太网交换机将条目在表中保留 5 分钟。</p></blockquote><p>如图所示，PC-A 正在向 PC-D 发送以太网帧。如表所示该交换机将 PC-A 的 MAC 地址添加到MAC地址表中。</p><p>注意: 如果源 MAC 地址已经保存在表中，但是对应的是不同的端口，那么交换机会将其视为一个新的条目。使用相同的 MAC 地址和最新的端口号来替换该条目。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_6_2.png" alt="学习"></p><hr><p><strong>查找目的MAC地址</strong></p><blockquote><p>如果目的 MAC 地址为单播地址，该交换机会看帧中的目的 MAC 地址与 MAC 地址表中的条目是否匹配。如果表中存在该目的MAC地址，交换机会从指定端口转发帧。如果表中不存在该目的MAC地址，交换机会从除传入端口外的所有端口转发帧。这称为未知单播。</p></blockquote><p>如图所示，交换机的表中没有目的主机 PC-D 的 MAC 地址，因此交换机会从除端口 1 外的所有端口转发帧。</p><p>注意: 如果目的 MAC 地址为广播或组播，该帧也将被泛洪到除传入端口外的所有端口。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_6_3.png" alt="转发"></p><hr><h3 id="过滤帧"><a href="#过滤帧" class="headerlink" title="过滤帧"></a>过滤帧</h3><p>交换机是从不同的设备接收帧，因此它可以通过检查每个帧的源 MAC 地址来填充它的 MAC 地址表。如果MAC 地址表包含目的MAC 地址，则交换机将“滤过”该帧并将其从单个端口转发出去。</p><p><strong>在图中，PC-D 正在回复 PC-A。 交换机在端口 4 上的传入帧中看到 PC-D 的 MAC 地址。然后，交换机将 PC-D 的 MAC 地址放入与端口 4 关联的 MAC 地址表中。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_6_4.png" alt="PC - D 到转换机"></p><p><strong>下一步，因为该交换机的MAC地址表中存在 PC-A 的目的 MAC 地址，它将仅从端口 1 将该帧发出去，如rt676图所示。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_6_5.png" alt="交换到 PC - A"></p><p><strong>下一步，PC-A 向 PC-D 发送另一帧，如图所示。MAC 地址表中已包含 PC-A 的 MAC 地址，因此该条目的五分钟刷新计时器被重置。下一步，因为该交换机的表中存在 PC-D 的目的 MAC 地址，它将仅从端口 4 将该帧发出去。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_6_6.png" alt="PC - A 到交换机再到PC - D"></p><hr><h3 id="相连交换机上的-MAC-地址表"><a href="#相连交换机上的-MAC-地址表" class="headerlink" title="相连交换机上的 MAC 地址表"></a>相连交换机上的 MAC 地址表</h3><blockquote><p>交换机的单个端口可以与多个 MAC 地址关联。这种情况在交换机与另一个交换机连接时很常见。交换机为每个收到的帧中的源 MAC 地址创建一条有单独的 MAC 地址表条目。</p></blockquote><hr><h3 id="将帧发送到默认网关"><a href="#将帧发送到默认网关" class="headerlink" title="将帧发送到默认网关"></a>将帧发送到默认网关</h3><blockquote><p>如果一台设备的 IP 地址在远程网络上，则不能将以太网帧直接发送到目的设备。而是将以太网帧发送到默认网关（路由器）的 MAC 地址。</p></blockquote><hr><h3 id="思科交换机上的帧转发方法"><a href="#思科交换机上的帧转发方法" class="headerlink" title="思科交换机上的帧转发方法"></a>思科交换机上的帧转发方法</h3><blockquote><p><code>交换机使用其 MAC 地址表来确定用于转发帧的端口</code>。对于思科交换机，实际上有两种帧转发的方法，根据具体情况，有充分的理由使用其中一种来代替另一种。</p></blockquote><p>在过去，交换机使用下面的两种转发方法之一来进行<code>网络端口间的数据交换</code>：</p><ul><li><p><strong>存储转发交换</strong> - 这个帧转发的方法接收整个帧并计算CRC <strong>(Cyclic Redundancy Check，循环冗余校验)</strong> 根据帧中的比特位为 1 的位数量，使用数学公式来确定收到的帧是否有错。如果 CRC 有效，则交换机查找目的地址，目的地址决定了转发接口。帧然后从正确的端口转发出去。</p></li><li><p><strong>直通交换</strong> - 这种帧转发的方法在收到整个帧之前即转发帧。在可以转发帧之前，至少必须读取帧的目的地址。</p></li></ul><p>存储转发交换的一大<code>优点</code>是，它<code>可以在传播帧之前确定帧是否有错误</code>。</p><blockquote><p>当在帧中检测到错误时，交换机丢弃该帧。丢弃有错的帧可减少损坏的数据所耗用的带宽量。<strong>存储转发交换对于融合网络中的服务质量（QoS）分析是必需的</strong>，在融合网络中，必须对帧进行分类以划分流量优先级。例如，IP 语音数据流的优先级需要高于 Web 浏览流量。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_9_1.png" alt="源数据帧"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_9_2.png" alt="交换机帧校验"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_9_3.png" alt="交换机校验通过"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_9_4.png" alt="交换机检查交换表"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_9_5.png" alt="交换机发送源数据帧到目的地"></p><hr><h3 id="直通交换"><a href="#直通交换" class="headerlink" title="直通交换"></a>直通交换</h3><blockquote><p>在直通交换中，交换机在收到数据时立即处理数据，<strong>即使传输尚未完成。交换机只缓冲帧的一部分，缓冲的量仅足以读取目的 MAC 地址，以便确定转发数据时应使用的端口</strong>。目的 MAC 地址位于帧中前导码后面的前 6 个字节。交换机在其交换表中查找目的 MAC 地址，确定转发端口，然后通过指定的交换机端口将帧转发到其目的地。交换机对该帧不执行任何错误检查。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_10_1.png" alt="交换机发送源数据帧到目的地"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_10_2.png" alt="交换机发送源数据帧到目的地"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_10_3.png" alt="交换机发送源数据帧到目的地"></p><hr><p>直通交换有两种变体：</p><ul><li><p><strong>快速转发交换</strong> - 快速转发交换<code>提供最低程度的延时</code>。快速转发交换在读取目的地址之后立即转发数据包。由于快速转发交换在收到整个数据包之前就开始转发，因此有时候中继数据包时会出错。这种情况并不经常发生，而且目的网络适配器在收到含错数据包时会将其丢弃。在快速转发模式下，延时是指从收到第一个位到传出第一个位之间的时间差。快速转发交换是典型的直通交换方法。</p></li><li><p><strong>免分片交换</strong> - 在免分片交换中，交换机在转发之前存储帧的前 64 个字节。<code>可以将免分片交换视为存储转发交换和直通交换之间的折衷</code>。免分片交换只存储帧的前 64 个字节的原因是，大部分网络错误和冲突都发生在前 64 个字节。免分片交换在转发帧之前对帧的前 64 个字节执行小错误检查以确保没有发生过冲突，并且尝试通过这种方法来增强快速转发交换功能。免分片交换是存储转发交换的高延时和高完整性与快速转发交换的低延时和弱完整性之间的折衷。</p></li></ul><blockquote><p><code>某些交换机可配置为按端口执行直通交换</code>，<strong>当达到用户定义的错误阈值时，这些端口自动切换为存储转发。当错误率低于该阈值时，端口自动恢复到直通切换</strong>。</p></blockquote><hr><h3 id="交换机上的内存缓冲"><a href="#交换机上的内存缓冲" class="headerlink" title="交换机上的内存缓冲"></a>交换机上的内存缓冲</h3><blockquote><p><code>以太网交换机在转发帧之前</code>，可以使用缓冲技术存储帧。<code>当目的端口由于拥塞而繁忙时</code>，也可以使用缓冲。<strong>交换机将帧存储起来，直到可以传输</strong>。</p></blockquote><p>如表所示，有两种内存缓冲方法：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>基于端口的内存</strong></td><td align="left"><strong>1.</strong> 帧存储在链接到特定传入端口和传出 端口的队列中。<strong>2.</strong> 只有当队列前面的所有帧都成功传输后， 才会将帧传输到传出端口。<strong>3.</strong> 由于目地端口繁忙， 单个帧可能会造成内存中所有帧的传输延迟。<strong>4.</strong> 即使其他帧可以传送到开放的目的端口， 这种延迟仍然会发生。</td></tr><tr><td align="left"><strong>共享内存</strong></td><td align="left"><strong>1.</strong> 将所有帧存储到由所有交换端口共享的公共内存缓冲区中， 并且动态分配一个端口所需的 缓冲区内存量。 <strong>2.</strong> 缓冲区中的帧动态地链接到目的端口， 允许在一个端口上接收数据包，然后 在另一个端口上发送，而无需移动到另一个队列。</td></tr></tbody></table><p>而且<strong>共享内存缓冲也意味着存储较大帧的能力，丢弃的帧可能较少</strong>。这对于非对称交换非常重要，因为它允许在不同端口上使用不同的数据速率，比如将服务器连接到 10 Gbps 的交换机端口，而pc连接到 1 Gbps 的端口。</p><hr><h3 id="双工和速率设置"><a href="#双工和速率设置" class="headerlink" title="双工和速率设置"></a>双工和速率设置</h3><blockquote><p>交换机上<code>最基本的两个设置是带宽（有时称为“速率”）和每个交换机端口的双工设置</code>。交换机端口和连接的设备（例如计算机或另一台交换机）的双工设置和带宽设置必须匹配。</p></blockquote><p>用于以太网通信的双工设置有两种：</p><ul><li><p><strong>全双工</strong> – 连接的两端均可同时收发信息。</p></li><li><p><strong>半双工</strong> – 一次只能是连接的两端中其中一端发送信息。</p></li></ul><blockquote><p><strong>自动协商是大多数以太网交换机和网卡的一项可选功能</strong>。它使两个设备自动协商最佳速率和双工性能。如果两台设备具有最高常见带宽的功能，则会选择全双工。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_12_1.png" alt="PC-A 的以太网网卡可在全双工或半双工模式下，以及以 10 Mbps 或 100 Mb速率运行。"></p><p>注意: 大多数思科交换机和以太网网卡默认采用自动协商功能，以提高速率和实现双工。<code>千兆以太网端口仅以全双工模式运行</code>。</p><blockquote><p><strong>双工不匹配是以太网链路出现性能问题的常见原因之一</strong>。当链路上的一个端口在半双工模式下运行，而另一个端口在全双工模式下运行时，就会发生双工不匹配，如图所示。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_12_2.png"><blockquote><p><strong>当链路上的一个或两个端口被重置时，会发生双工不匹配</strong>，自动协调过程并不会使链路上的两个端口的配置相同。当用户重新配置链路的一端而忘记重新配置另一端时，也会出现这样的情况。链路的两端均应都使用或都不使用自动协商。最佳实践是将两个以太网交换端口都配置为全双工。</p></blockquote><hr><h3 id="Auto-MDIX"><a href="#Auto-MDIX" class="headerlink" title="Auto-MDIX"></a>Auto-MDIX</h3><blockquote><p>设备之间的连接曾经要求使用交叉线或直通线。所需的线缆类型取决于互连设备的类型。</p></blockquote><p>例如，该图标识了互连<code>交换机到交换机</code>、<code>交换机到路由器</code>、<code>交换机到主机</code>或<code>路由器到主机</code>设备所需的正确线缆类型。交叉线用于连接相似的设备，而直通电缆主要用于连接不同的设备。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/5_13.png" alt="连线规则"></p><p>现在，<strong>大多数交换机设备都支持自动介质相关接口交叉 (auto-MDIX) 功能</strong>。当该功能启用时，交换机可检测连接到端口的线缆类型，并相应地配置接口。因此，如果要连接到交换机上的铜缆 10/100/1000 端口，您既可以使用交叉线，也可以使用直通线，而无需考虑连接另一端的设备类型。</p><hr><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>以太网帧</li></ul><blockquote><p>以太网在数据链路层和物理层运行。以太网标准定义第 2 层协议和第 1 层技术。以太网使用数据链路层的 LLC 和 MAC 子层进行操作。数据封装包括以下内容：以太网帧、以太网编址和以太网错误检测。以太网LANs使用的交换机是全双工的。以太网帧字段包括：前导码和帧起始定界符、目的 MAC 地址、源 MAC 地址、EtherType、数据和 FCS。</p></blockquote><ul><li>以太网MAC地址</li></ul><blockquote><p>二进制系统仅使用数字 0 和 1。十进制使用 0 到 9。十六进制使用 0 到 9，字母 A 到 F。MAC 地址用于标识本地网段上的物理源和目的设备 (NIC)。MAC 编址为 OSI 模型的数据链路层提供了设备识别方法。以太网 MAC 地址是48 位，使用 12个十六进制数字，或 6 字节表示。以太网 MAC 地址由6个十六进制供应商 OUI 代码和6个十六进制供应商分配的值组成。当设备将消息转发到以太网网络时，以太网报头包括源 MAC 地址和目的 MAC 地址。在以太网中，第 2 层单播、组播和广播通信会使用不同的 MAC 地址。</p></blockquote><ul><li>MAC地址表</li></ul><blockquote><p>第 2 层以太网交换机仅根据第 2 层以太网 MAC 地址做出转发决策。交换机通过检查端口传入帧的源 MAC 地址来动态构建 MAC 地址表。交换机通过匹配帧中的目的 MAC 地址与 MAC 地址表中的条目来转发帧。交换机是从不同的设备接收帧，因此它可以通过检查每个帧的源 MAC 地址来填充它的 MAC 地址表。如果MAC 地址表包含目的MAC 地址，则交换机将滤过该帧并将其从单个端口转发出去。</p></blockquote><ul><li>交换机速率和转发方法</li></ul><blockquote><p>交换机使用下面的两种转发方法之一来进行网络端口间的数据交换：存储转发交换或直通交换。有两种类型的直通交换方法：快速转发和免分片。内存缓冲的两种方法是基于端口的内存和共享内存。以太网络上的通信使用两种双工设置：全双工和半双工。自动协商是大多数以太网交换机和网卡的一项可选功能。它使两个设备自动协商最佳速率和双工性能。如果两台设备具有最高常见带宽的功能，则会选择全双工。现在，大多数交换机设备都支持自动介质相关接口交叉 (auto-MDIX) 功能。当该功能启用时，交换机可检测连接到端口的线缆类型，并相应地配置接口。</p></blockquote><hr><h2 id="网络层（第-3-层）"><a href="#网络层（第-3-层）" class="headerlink" title="网络层（第 3 层）"></a><a href="https://phoenixnest.github.io/School-Computer-Network-Technology-3-Network-Layer/">网络层（第 3 层）</a></h2><hr><h2 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h2><h3 id="同一网络中的目的地"><a href="#同一网络中的目的地" class="headerlink" title="同一网络中的目的地"></a>同一网络中的目的地</h3><p>有时，主机必须发送消息，但它只知道目的设备的 IP 地址。主机需要知道该设备的MAC地址，但是如何才能发现它呢? 这就是地址解析变得至关重要的地方。</p><p>以太网 LAN 上的设备都配有两个主要地址：</p><ul><li><p><strong>物理地址（MAC 地址）</strong> – <code>用于同一网络上的以太网网卡之间的通信</code>。</p></li><li><p><strong>逻辑地址（IP地址）</strong> – <code>用于将数据包从源设备发送到目的设备</code>。<strong>目的IP地址可能与源地址在同一个IP网络上，也可能在远程网络上</strong>。</p></li></ul><p>第二层物理地址（即以太网 MAC 地址）用于将数据链路层帧从同一网络中一个网卡发送到另一个网卡， IP 数据包就封装在帧中。如果目的IP地址在同一网络上，则目的MAC地址将是目的设备的MAC地址。</p><p>考虑下面使用简化的MAC地址表示的示例。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_1.png" alt="同一网络中的目的地"></p><p>在本示例中，PC1 想要向 PC2 发送一个数据包。该图显示了从 PC1 发送的数据包中包含：第2层目的和源 MAC 地址以及第 3 层 IPv4 地址。</p><p><code>第 2 层以太网帧</code>包含以下内容：</p><ul><li><p><strong>目的MAC地址</strong> – 这是简化的 PC2 MAC 地址，55-55-55。</p></li><li><p><strong>源MAC地址</strong> – 这是 PC1 上以太网网卡的简化 MAC 地址，aa-aa-aa。</p></li></ul><p><code>第 3 层 IP 数据包</code>包含以下内容：</p><ul><li><p><strong>源 IPv4 地址</strong> – 这是 PC1 的 IPv4 地址，192.168.10.10。</p></li><li><p><strong>目的 IPv4 地址</strong> – 这是 PC2 的 IPv4 地址, 192.168.10.11。</p></li></ul><hr><h3 id="远程网络中的目的地"><a href="#远程网络中的目的地" class="headerlink" title="远程网络中的目的地"></a>远程网络中的目的地</h3><p>当目的 IP 地址(IPv4或IPv6)处于远程网络中时，则目的 MAC 地址为主机的默认网关的地址(即路由器接口)。</p><p>考虑下面使用简化的MAC地址表示的示例。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_2_1.png"><p>在本示例中，PC1想要向PC2发送一个数据包。PC2 位于远程网络上。因为目的IPv4地址与PC1不在同一个本地网络上，所以目的MAC地址是路由器上的本地默认网关地址。</p><p>路由器通过检查目的 IPv4 地址来确定转发 IPv4 数据包的最佳路径。路由器收到以太网帧后，将解封第 2 层信息。它可借助目的 IPv4 地址确定下一跳设备，然后将 IPv4 数据包封装在发送接口的新数据链路帧中。</p><p>在我们的示例中, R1现在用新的第2层地址信息封装数据包，如图所示。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_2_2.png"><p>新的目的MAC地址将是R2 G0/0/1接口的地址，新的源MAC地址将是R1 G0/0/1接口的地址。</p><p>沿着路径中的每个链路，IP数据包都被封装在一个帧中。这个帧由该链路的数据链路层技术指定，如以太网。如果下一跳设备为最终目的地，则目的 MAC 地址将是该设备的以太网网卡的 MAC 地址，如图所示。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_2_3.png"><p>数据流中 IP 数据包的 IP 地址如何与通往目的地路径中每条链路上的 MAC 地址相关联？对于IPv4数据包，这可以通过地址解析协议 (ARP) 过程来完成。对于IPv6数据包，这个过程是ICMPv6邻居发现(ND)。</p><hr><h3 id="ARP概述"><a href="#ARP概述" class="headerlink" title="ARP概述"></a>ARP概述</h3><blockquote><p>如果您的网络使用IPv4通信协议，则需要使用 <strong>地址解析协议（ARP，Address Resolution Protocol）</strong> 将IPv4地址映射到MAC地址。</p></blockquote><p><code>以太网网络上的每个IP设备都有一个唯一的以太网MAC地址</code>。当设备发送以太网第2层帧时，将包含以下两个地址：</p><ul><li><p><strong>目的 MAC 地址</strong>  - 目的设备位于同一本地网络上，则为其以太网 MAC 地址。如果目的主机位于另一个网络上，则帧中的目的地址将是默认网关（即路由器）的地址。</p></li><li><p><strong>源 MAC 地址</strong> - 源主机以太网网卡的 MAC 地址。</p></li></ul><p>该图说明了将帧发送到 IPv4 网络上同一段中的另一个主机时出现的问题。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_3.png"><blockquote><p>要向同一本地IPv4网络上的另一个主机发送数据包，主机必须知道目的设备的IPv4地址和MAC地址。设备目的IPv4地址可以是已知的，也可以通过设备名称解析。然而，MAC地址必须被发现。</p></blockquote><p>设备使用地址解析协议（ARP）来确定一个已知 IPv4 地址的本地设备的目的 MAC 地址。</p><p>ARP 提供两个基本功能：</p><ul><li><p><strong>将 IPv4 地址解析为 MAC 地址</strong></p></li><li><p><strong>维护IPv4到MAC地址映射表</strong></p></li></ul><hr><h3 id="ARP-功能"><a href="#ARP-功能" class="headerlink" title="ARP 功能"></a>ARP 功能</h3><blockquote><p>当数据包发送到要封装入以太网帧的数据链路层时，<strong>设备将参照其内存中的表来查找映射至 IPv4 地址的 MAC 地址。此表临时存储在 RAM 内存中，称为 ARP 表或 ARP 缓存</strong>。</p></blockquote><p>发送设备会在自己的 ARP 表中搜索目的 IPv4 地址和相应的 MAC 地址。</p><ul><li><p>如果数据包的目的 IPv4 地址与源 IPv4 地址处于同一个网络，则设备会在 ARP 表中搜索目的 IPv4 地址。</p></li><li><p>如果目的 IPv4 地址与源 IPv4 地址不在同一个网络中，则设备会在 ARP 表中搜索默认网关的 IPv4 地址。</p></li></ul><p>这两种情况都是搜索设备的 IPv4 地址和与其相对应的 MAC 地址。</p><blockquote><p>ARP 表中的每一条（或每行）将一个 IPv4 地址与一个 MAC 地址绑定。我们把两个值之间的关系称为映射。这意味着您可以在表中查找 IPv4 地址并发现相应的 MAC 地址。ARP 表暂时保存（缓存）LAN 上设备的映射。</p><blockquote><p>如果设备找到 IPv4 地址，其相应的 MAC 地址将作为帧中的目的 MAC 地址。如果找不到该条目，设备会发送一个 ARP 请求。</p></blockquote></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_4_1.png" alt="源设备发送 ARP 请求"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_4_2.png" alt="交换机转发请求报文"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_4_3.png" alt="终端报文校验"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_4_4.png" alt="目标机回传信息"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_4_5.png" alt="源设备向目标机发送信息"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_4_6.png" alt="目标机接收信息"></p><hr><h3 id="ARP-请求"><a href="#ARP-请求" class="headerlink" title="ARP 请求"></a>ARP 请求</h3><blockquote><p>当设备需要确定与 IPv4 地址关联的 MAC 地址，而它的 ARP 表中没有该 IPv4 地址条目时，会发送一个 ARP 请求。</p></blockquote><p><code>ARP 消息直接封装到以太网帧中。没有 IPv4 报头</code>。ARP 请求使用以下<strong>帧头信息</strong>封装在以太网帧中：</p><ul><li><p><strong>目的 MAC 地址</strong> – 这是一种要求 LAN 上的所有以太网网卡接受并处理 ARP 请求的广播地址FF-FF-FF-FF-FF-FF。</p></li><li><p><strong>源 MAC 地址</strong> – 这是ARP请求发送方的MAC地址。</p></li><li><p><strong>类型</strong> - ARP 消息的类型字段为 0x806。该类型字段会通知接收网卡需要将帧的数据部分传递给 ARP 进程处理。</p></li></ul><blockquote><p>因为 <strong>ARP 请求属于广播</strong>，交换机会将其泛洪到除接收端口外的其他所有端口。<code>局域网上的所有以太网网卡都会处理广播，并且必须将ARP请求发送到其操作系统进行处理</code>。<strong>每台设备必须处理 ARP 请求，以检查目的 IPv4 地址是否与其自己的地址相匹配</strong>。路由器不会将广播转发到其他接口。</p></blockquote><p>LAN 上只有一台设备的 IPv4 地址与 ARP 请求中的目的 IPv4 地址相匹配。所有其他设备将不应<br>答。</p><hr><h3 id="ARP-操作-ARP-应答"><a href="#ARP-操作-ARP-应答" class="headerlink" title="ARP 操作 - ARP 应答"></a>ARP 操作 - ARP 应答</h3><p>只有具有与ARP请求相应的目的IPv4地址的设备才会以ARP应答做出响应。ARP 应答使用以下帧头信息封装在以太网帧中：</p><ul><li><p><strong>目的 MAC 地址</strong> – 这是ARP请求发送方的MAC地址。</p></li><li><p><strong>源 MAC 地址</strong> – 这是ARP应答发送方的MAC地址。</p></li><li><p><strong>类型</strong> – ARP 消息的类型字段为 0x806。该类型字段会通知接收网卡需要将帧的数据部分传递给 ARP 进程处理。</p></li></ul><blockquote><p><strong>只有原始发送 ARP 请求的设备会收到单播 ARP 应答</strong>。收到该 ARP 应答后，设备会将 IPv4 地址及相应的 MAC 地址添加到自身的 ARP 表中。该 IPv4 地址的数据包现在便可使用其相应的 MAC 地址封装在帧中。</p><blockquote><p>如果没有设备响应 ARP 请求，就无法创建帧，那么这个数据包会被丢弃。</p></blockquote></blockquote><p><code>ARP 表中的条目具有时间戳</code>。<strong>如果设备在时间戳到期前没有从特定设备收到帧</strong>，<strong>此设备的条目将会从 ARP 表中删除</strong>。</p><p>此外，也<strong>可以在 ARP 表中输入静态映射条目</strong>，但<code>这种情况很少见</code>。<strong>静态 ARP 表条目没有到期时间，必须手动删除</strong>。</p><blockquote><p>注意: IPv6 使用与 IPv4 类似的 ARP 流程，称为 ICMPv6 邻居发现(ND)。与 IPv4 的 ARP 请求和 ARP 应答类似，Pv6 使用邻居请求和邻居通告消息。</p></blockquote><hr><h3 id="ARP-在远程通信中的作用"><a href="#ARP-在远程通信中的作用" class="headerlink" title="ARP 在远程通信中的作用"></a>ARP 在远程通信中的作用</h3><p>当目的 IPv4 地址与源 IPv4 地址位于不同网络时，源设备需要将帧发送到其默认网关。这是本地路由器的接口。每当源设备具有 IPv4 地址在其他网络中的数据包时，它会使用路由器的目的 MAC 地址将该数据包封装在帧中。</p><blockquote><p>默认网关的 IPv4 地址存储在主机的 IPv4 配置中。当主机创建通往某台目的主机的数据包时，会将目的 IPv4 地址与其自己的 IPv4 地址进行比较，以确定两个 IPv4 地址是否位于相同的第 3 层网络上。如果目的主机不在同一网络上，源主机将从 ARP 表中查找默认网关的 IPv4 地址条目。如果没有该条目，源主机将使用 ARP 流程来确定默认网关的 MAC 地址。</p></blockquote><hr><h3 id="从-ARP-表中删除条目"><a href="#从-ARP-表中删除条目" class="headerlink" title="从 ARP 表中删除条目"></a>从 ARP 表中删除条目</h3><p>对于每台设备，<code>ARP 缓存定时器将会删除在指定时间内未使用的 ARP 条目</code>。时间根据设备的操作系统不同而不同。例如，较新的 Windows 操作系统将 ARP 表条目存储 15 秒到 45 秒之间，如图所示。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_8.png"><p><code>也可以使用命令来手动删除 ARP 表中的部分或全部条目</code>。<strong>当条目被删除之后，要想在 ARP 表中输入映射，必须重复一次发送 ARP 请求和接收 ARP 回复的过程</strong>。</p><hr><h3 id="网络设备上的-ARP-表"><a href="#网络设备上的-ARP-表" class="headerlink" title="网络设备上的 ARP 表"></a>网络设备上的 ARP 表</h3><blockquote><p>在<code>思科路由器</code>上，<strong>show ip arp</strong>命令用于显示 ARP 表。</p></blockquote><pre><code class="CISCO">R1# show ip arp Protocol  Address          Age (min)  Hardware Addr   Type   InterfaceInternet  192.168.10.1            -   a0e0.af0d.e140  ARPA   GigabitEthernet0/0/0Internet  209.165.200.225         -   a0e0.af0d.e141  ARPA   GigabitEthernet0/0/1Internet  209.165.200.226         1   a03d.6fe1.9d91  ARPA   GigabitEthernet0/0/1R1#</code></pre><blockquote><p>在 <code>Windows 10</code> PC 上，<strong>arp –a</strong>命令用于显示 ARP 表。</p></blockquote><pre><code class="bash">C:\Users\PC&gt; arp -aInterface: 192.168.1.124 --- 0x10  Internet Address      Physical Address      Type  192.168.1.1           c8-d7-19-cc-a0-86     dynamic  192.168.1.101         08-3e-0c-f5-f7-77     dynamic  192.168.1.110         08-3e-0c-f5-f7-56     dynamic  192.168.1.112         ac-b3-13-4a-bd-d0     dynamic  192.168.1.117         08-3e-0c-f5-f7-5c     dynamic  192.168.1.126         24-77-03-45-5d-c4     dynamic  192.168.1.146         94-57-a5-0c-5b-02     dynamic  192.168.1.255         ff-ff-ff-ff-ff-ff     static  224.0.0.22            01-00-5e-00-00-16     static  224.0.0.251           01-00-5e-00-00-fb     static  239.255.255.250       01-00-5e-7f-ff-fa     static  255.255.255.255       ff-ff-ff-ff-ff-ff     staticC:\Users\PC&gt;</code></pre><hr><h3 id="ARP-问题-ARP广播和ARP-欺骗"><a href="#ARP-问题-ARP广播和ARP-欺骗" class="headerlink" title="ARP 问题 - ARP广播和ARP 欺骗"></a>ARP 问题 - ARP广播和ARP 欺骗</h3><p><code>作为广播帧，本地网络上的每台设备都会收到并处理 ARP 请求</code>。在一般的商业网络中，这些广播对网络性能的影响可能微不足道。但是，如图所示，<code>如果大量设备都已启动，并且同时开始使用网络服务，网络性能可能会有短时间的下降</code>。<strong>在设备发出初始 ARP 广播并获取必要的 MAC 地址之后，网络受到的影响将会降至最小</strong>。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_10_1.png"><p>有时，<code>使用 ARP 可能会造成潜在的安全风险</code>。</p><blockquote><p>威胁发起者可以使用 ARP 欺骗来执行 ARP 毒化攻击。</p></blockquote><p>如图所示，威胁发起者使用这种技术来应答属于另一台设备（例如默认网关）的 IPv4 地址的 ARP 请求。威胁发起者会发送一个带有自己 MAC 地址的 ARP 应答。ARP 应答的接收方会将错误的 MAC 地址添加到其 ARP 表中，并将这些数据包发送给威胁发起者。 <code>企业级的交换机包含称为动态 ARP 检查（DAI，Dynamic ARP Inspection，动态 ARP 检测）的缓解技术</code>。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_10_2.png"><hr><h3 id="IPv6-邻居发现"><a href="#IPv6-邻居发现" class="headerlink" title="IPv6 邻居发现"></a>IPv6 邻居发现</h3><blockquote><p>如果您的网络使用IPv6通信协议，则需要使用邻居发现协议(ND)将 IPv6 地址与 MAC 地址进行匹配。</p></blockquote><hr><h3 id="IPv6-邻居发现消息"><a href="#IPv6-邻居发现消息" class="headerlink" title="IPv6 邻居发现消息"></a>IPv6 邻居发现消息</h3><blockquote><p><strong>IPv6 邻居发现协议有时被称为 ND 或 NDP</strong>。在本课程中，我们称它为 ND。ND使用ICMPv6为IPv6提供地址解析、路由器发现和重定向服务。<strong>ICMPv6 ND 使用五种 ICMPv6 消息来执行这些服务</strong>：</p></blockquote><ul><li><p><strong>邻居请求消息</strong></p></li><li><p><strong>邻居通告消息</strong></p></li><li><p><strong>路由器请求消息</strong></p></li><li><p><strong>路由器通告消息</strong></p></li><li><p><strong>重定向消息</strong></p></li></ul><p>邻居请求和邻居通告消息用于设备到设备的消息传递，例如地址解析（类似于 IPv4 的 ARP）。设备包括主机计算机和路由器。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_12_1.png"><blockquote><p>路由器请求和路由器通告消息用于设备和路由器之间的消息传递。通常，路由器发现用于<strong>动态地址分配（DHCP,Dynamic Host Configuration Protocol）</strong>和无状态地址自动配置 <strong>（SLAAC，Stateless address auto configuration）</strong>。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_12_2.png"><p>注意: 第五个 ICMPv6 ND 消息是一个重定向消息，用于更好的下一跳选择。这不在本课程的讨论范围之内。</p><blockquote><p>IPv6 ND 是在 IETF RFC 4861 中定义的。</p></blockquote><hr><h3 id="IPv6-邻居发现-地址解析"><a href="#IPv6-邻居发现-地址解析" class="headerlink" title="IPv6 邻居发现 - 地址解析"></a>IPv6 邻居发现 - 地址解析</h3><p>与 IPv4 的 ARP 非常相似，IPv6 设备使用 IPv6 ND 来确定一个已知 IPv6 地址的设备的 MAC 地址。</p><blockquote><p>ICMPv6 邻居请求和邻居通告消息用于MAC地址解析。这类似于ARP用于IPv4的ARP请求和ARP应答。例如，假设 PC1 想要ping PC2的Ipv6地址2001:db8:acad::11。为了确定已知IPv6地址的MAC地址，PC1发送一个ICMPv6邻居请求消息，如图所示。</p></blockquote><p>该图显示了 PC1 和 PC2 连接到网络 2001:db8:acad:1::/64 上的同一交换机。PC1 的 IPv6 地址是2001:db8:acad:1::10，PC2 的 IPv6 地址是 2001:db8:acad:1::11。</p><ul><li><p>PC1 正在发送一条 ICMPv6 邻居请求消息，显示为：嘿，谁有2001:db8:acad:1::11，把你的 MAC 地址发给我？</p></li><li><p>PC2 正在回应一条 ICMPv6 邻居通告消息，显示为：嘿，2001:db8:acad:1::10，我是 2001:db8:acad:1::11，我的 MAC 地址是 f8-94-c3-e4-c5-0A。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/7_13.png"><blockquote><p>ICMPv6 邻居请求消息使用特定的以太网和 IPv6 组播地址发送。这允许接收设备的以太网卡确定邻居请求消息是否属于它自己，而不必将它发送到操作系统进行处理。</p></blockquote><p>PC2 使用包含其 MAC 地址的 ICMPv6 邻居通告消息来应答请求。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li>MAC和IP</li></ul><blockquote><p>第2层物理地址(即，以太网MAC地址)用于通过封装 IP 数据包将数据链路层帧从同一网络中一个网卡发送到另一个网卡。如果目的 IP 地址处于本地网络中，则目的 MAC 地址是目的设备的 MAC 地址。当目的 IP 地址(IPv4或IPv6)处于远程网络中时，则目的 MAC 地址为主机的默认网关的地址(即路由器接口)。沿着路径中的每个链路，IP数据包都被封装在一个帧中。这个帧由该链路的数据链路层技术指定，如以太网。如果下一跳设备为最终目的地，则目的 MAC 地址将是该设备的以太网网卡的 MAC 地址。数据流中 IP 数据包的 IP 地址如何与通往目的地路径中每条链路上的 MAC 地址相关联？对于IPv4数据包，这可以通过ARP 过程来完成。对于IPv6数据包，这个过程是ICMPv6 ND。</p></blockquote><ul><li>ARP</li></ul><blockquote><p>以太网网络上的每个IP设备都有一个唯一的以太网MAC地址。当设备发送以太网帧时，它包含这两个地址：目的 MAC 地址和源 MAC 地址。当已知一个本地设备的IPv4地址时，使用ARP来确定该设备的目的MAC地址。ARP提供了两个基本功能：将IPv4地址解析为MAC地址和维护IPv4到MAC地址的映射表。ARP 请求使用以下报头信息封装在以太网帧中：源和目的 MAC 地址和类型。LAN 上只有一台设备的 IPv4 地址与 ARP 请求中的目的 IPv4 地址相匹配。所有其他设备将不应答。ARP应答包含与请求相同的报头字段。只有原始发送 ARP 请求的设备会收到单播 ARP 应答。收到该 ARP 应答后，设备会将 IPv4 地址及相应的 MAC 地址添加到自身的 ARP 表中。当目的 IPv4 地址与源 IPv4 地址位于不同网络时，源设备需要将帧发送到其默认网关。这是本地路由器的接口。对于每台设备，ARP 缓存定时器将会删除在指定时间内未使用的 ARP 条目。也可以使用命令来手动删除 ARP 表中的部分或全部条目。作为广播帧，本地网络上的每台设备都会收到并处理 ARP 请求，这可能导致网络变慢。威胁发起者可以使用 ARP 欺骗来执行 ARP 毒化攻击。</p></blockquote><ul><li>邻居发现</li></ul><blockquote><p>IPv6不使用ARP，它使用ND协议来解析MAC地址。ND使用ICMPv6为IPv6提供地址解析、路由器发现和重定向服务。ICMPv6 ND 使用五种 ICMPv6 消息来执行这些服务：邻居请求、邻居通告、路由器请求、路由器通告和重定向。与IPv4的ARP非常相似，IPv6设备使用IPv6 ND将设备的MAC地址解析为已知的IPv6地址。</p></blockquote><hr><h2 id="CISCO路由器基本配置"><a href="#CISCO路由器基本配置" class="headerlink" title="CISCO路由器基本配置"></a>CISCO路由器基本配置</h2><h3 id="基本路由器配置步骤"><a href="#基本路由器配置步骤" class="headerlink" title="基本路由器配置步骤"></a>基本路由器配置步骤</h3><p>在路由器上配置初始设置时，应完成以下任务。</p><ul><li>配置设备名称。</li></ul><pre><code class="CISCO">Router(config)# hostname hostname</code></pre><ul><li>保护特权模式。</li></ul><pre><code class="CISCO">Router(config)# enable secret password</code></pre><ul><li>保护用户模式</li></ul><pre><code class="CISCO">Router(config)# line console 0Router(config-line)# password passwordRouter(config-line)# login</code></pre><ul><li>保护远程 Telnet / SSH 访问</li></ul><pre><code class="CISCO">Router(config-line)# line vty 0 4Router(config-line)# password passwordRouter(config-line)# loginRouter(config-line)# transport input &#123;ssh | telnet&#125;</code></pre><ul><li>保护配置文件中的所有密码。</li></ul><pre><code class="CISCO">Router(config-line)# exitRouter(config)# service password-encryption</code></pre><ul><li>提供法律通知。</li></ul><pre><code class="CISCO">Router(config)# banner motd delimiter message delimiter</code></pre><ul><li>保存配置。</li></ul><pre><code class="CISCO">Router(config)# endRouter# copy running-config startup-config</code></pre><h3 id="路由器基本配置示例"><a href="#路由器基本配置示例" class="headerlink" title="路由器基本配置示例"></a>路由器基本配置示例</h3><p>在此示例中，拓扑图中的路由器 R1 将使用初始设置进行配置。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/8_1.png"><p>要配置 R1 的设备名称，请使用以下命令。</p><pre><code class="CISCO">Router&gt; enable Router# configure terminal Enter configuration commands, one per line.End with CNTL/Z.Router(config)# hostname R1 R1(config)#</code></pre><p>注意: 注意路由器提示符现在如何显示路由器主机名。</p><p>所有路由器访问都应得到保护。特权 EXEC 模式为用户提供对设备及其配置的完全访问权限。因此，它是要去保护的最重要的模式。</p><p>以下命令保护特权 EXEC 模式和用户 EXEC 模式，启用 Telnet 和 SSH 远程访问，并加密所有明文（即用户 EXEC 和 VTY 线路）密码。</p><pre><code class="CISCO">R1(config)# enable secret class R1(config)#R1(config)# line console 0 R1(config-line)# password cisco R1(config-line)# login R1(config-line)# exit R1(config)#R1(config)# line vty 0 4 R1(config-line)# password cisco R1(config-line)# login R1(config-line)# transport input ssh telnet R1(config-line)# exit R1(config)#R1(config)# service password-encryption R1(config)#</code></pre><p>法律通知警告用户只能由允许用户访问该设备。法律通知配置如下。</p><pre><code class="CISCO">R1(config)# banner motd #Enter TEXT message. End with a new line and the #*********************************************** WARNING: Unauthorized access is prohibited!***********************************************#R1(config)#</code></pre><p>如果前面的命令已配置，路由器意外断电，则所有已配置的命令都将丢失。因此，在实施变更时保存配置非常重要。以下命令将配置保存到 NVRAM。</p><pre><code class="CISCO">R1# copy running-config startup-configDestination filename [startup-config]? Building configuration...[OK]R1#</code></pre><hr><h3 id="配置路由器接口"><a href="#配置路由器接口" class="headerlink" title="配置路由器接口"></a>配置路由器接口</h3><p>此时，您的路由器已经有了基本配置。下一步将配置它们的接口。这是因为在配置接口之前，终端设备无法访问路由器。思科路由器上有许多不同类型的接口。例如，思科 ISR 4321 路由器配备了两个千兆以太网接口：</p><ul><li><p><strong>GigabitEthernet 0/0/0 (G0/0/0)</strong></p></li><li><p><strong>GigabitEthernet 0/0/1 (G0/0/1)</strong></p></li></ul><p>配置路由器接口的任务与交换机上管理 SVI 非常相似。具体来说，它包括发出以下命令：</p><pre><code class="CISCO">Router(config)# interface type-and-numberRouter(config-if)# description description-textRouter(config-if)# ip address ipv4-address subnet-maskRouter(config-if)# ipv6 address ipv6-address/prefix-lengthRouter(config-if)# no shutdown</code></pre><p>注意: 当路由器接口启用时，应显示确认已启用链接的信息。</p><p>虽然不需要 description 命令来启用接口，但使用它是一个很好的习惯。通过提供有关所连接的网络类型的信息，可以帮助解决生产网络上的故障。例如，如果接口连接到ISP或服务供应商，则使用description命令输入“第三方连接和联系信息”将会有帮助。</p><p>注意: 说明文字最长不能超过 240 个字符。</p><p>使用no shutdown 命令可激活接口，类似于在接口上启动电源。接口还必须连接到另一台设备（交换机或路由器），才能使物理层处于活动状态。</p><p>注意: 在没有以太网交换机的路由器间连接，必须配置和启用两个互连接口。</p><hr><h3 id="配置路由器接口示例"><a href="#配置路由器接口示例" class="headerlink" title="配置路由器接口示例"></a>配置路由器接口示例</h3><p>在此示例中，将启用拓扑图中的 R1 直连接口。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/8_3.png"><p>要在 R1 上配置接口，请使用以下命令。</p><pre><code class="CISCO">R1&gt; enableR1# configure terminalEnter configuration commands, one per line.End with CNTL/Z.R1(config)# interface gigabitEthernet 0/0/0R1(config-if)# description Link to LANR1(config-if)# ip address 192.168.10.1 255.255.255.0R1(config-if)# ipv6 address 2001:db8:acad:10::1/64R1(config-if)# no shutdownR1(config-if)# exitR1(config)#*Aug  1 01:43:53.435: %LINK-3-UPDOWN: Interface GigabitEthernet0/0/0, changed state to down*Aug  1 01:43:56.447: %LINK-3-UPDOWN: Interface GigabitEthernet0/0/0, changed state to up*Aug  1 01:43:57.447: %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/0/0, changed state to upR1(config)#R1(config)#R1(config)# interface gigabitEthernet 0/0/1R1(config-if)# description Link to R2R1(config-if)# ip address 209.165.200.225 255.255.255.252R1(config-if)# ipv6 address 2001:db8:feed:224::1/64R1(config-if)# no shutdownR1(config-if)# exitR1(config)#*Aug  1 01:46:29.170: %LINK-3-UPDOWN: Interface GigabitEthernet0/0/1, changed state to down*Aug  1 01:46:32.171: %LINK-3-UPDOWN: Interface GigabitEthernet0/0/1, changed state to up*Aug  1 01:46:33.171: %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/0/1, changed state to upR1(config)#</code></pre><p>注意: 注意那些通知我们G0/0/0 和 G0/0/1已启用了的信息。</p><hr><h3 id="检验接口配置"><a href="#检验接口配置" class="headerlink" title="检验接口配置"></a>检验接口配置</h3><p>有多条命令可用于检验接口配置。其中最有用的是 show ip interface brief 和 show ipv6 interface brief 命令，如示例所示。</p><pre><code class="CISCO">R1#  show ip interface briefInterface IP-Address OK? Method Status Protocol GigabitEthernet0/0/0 192.168.10.1 YES manual up up GigabitEthernet0/0/1 209.165.200.225 YES manual up up Vlan1 unassigned YES unset administratively down down R1#  show ipv6 interface briefGigabitEthernet0/0/0 [up/up]FE80::201:C9FF:FE89:45012001:DB8:ACAD:10::1GigabitEthernet0/0/1 [up/up]FE80::201:C9FF:FE89:45022001:DB8:FEED:224::1Vlan1 [administratively down/down]unassigned R1#</code></pre><hr><h3 id="配置验证命令"><a href="#配置验证命令" class="headerlink" title="配置验证命令"></a>配置验证命令</h3><p>此表总结了用于验证接口配置的更常用 show 命令。</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>show ip interface brief</strong> / <strong>show ipv6 interface brief</strong></td><td align="left">所有接口的输出显示,它们的IP地址和 当前的状态已配置和连接的接口的 状态和协议均会显示“up”; 显示任何其他内容都可能表示配置或 布线出现了问题。</td></tr><tr><td align="left"><strong>show ip route</strong> / <strong>show ipv6 route</strong></td><td align="left">显示存储在 RAM 中的 IP 路由表的内容。</td></tr><tr><td align="left"><strong>show interfaces</strong></td><td align="left">显示设备上所有接口的统计信息。然而,这个命令将只显示 IPv4 编址信息。</td></tr><tr><td align="left"><strong>show ip interface</strong></td><td align="left">显示路由器上所有接口的 IPv4 统计信息。</td></tr><tr><td align="left"><strong>show ipv6 interface</strong></td><td align="left">显示路由器上所有接口的 IPv6 统计信息。</td></tr></tbody></table><hr><h3 id="配置默认网关-主机的默认网关"><a href="#配置默认网关-主机的默认网关" class="headerlink" title="配置默认网关 - 主机的默认网关"></a>配置默认网关 - 主机的默认网关</h3><p>如果您的本地网络只有一个路由器，它就将是网关路由器，并且必须使用此信息配置网络上的所有主机和交换机。如果您的本地网络有多个路由器，则必须选择其中一个作为默认网关路由器。本主题介绍如何在主机和交换机上配置默认网关。</p><p>对于通过网络通信的终端设备，必须配置正确的 IP 地址信息，包括默认网关地址。当主机要将数据包发送到另一个网络设备时，才会使用默认网关。默认网关地址通常是连接主机本地网络的路由器接口地址。主机设备的 IP 地址和路由器接口地址必须位于同一网络。</p><p>例如，假设 IPv4 网络拓扑由一个路由器连接两个不同的 LAN 组成。G0/0/0 连接到网络 192.168.10.0，G0/0/1 连接到网络 192.168.11.0。每台主机设备均配置有相应的默认网关地址。</p><p>在此示例中，如果 PC1 向 PC2 发送数据包，则不使用默认网关。相反，PC1 将 PC2 的 IP 地址指定给数据包，然后通过交换机将该数据包直接转发给 PC2。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/8_3_1.png"><p>如果 PC1 向 PC3 发送数据包，该怎么办？PC1 将 PC3 的 IPv4 地址指定给数据包，但会将数据包转发到其默认网关，即 R1 的 G0/0/0 接口。路由器接受数据包，访问其路由表，以确定G0/0/1是基于目标地址的适当出口接口。然后 R1 将数据包转发出相应的接口以达到 PC3。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/8_3_2.png"><p>IPv6 网络上也会发生相同的过程，尽管拓扑中未显示此过程。设备将使用本地路由器的 IPv6 地址作为其默认网关。</p><hr><h3 id="配置默认网关-交换机的默认网关"><a href="#配置默认网关-交换机的默认网关" class="headerlink" title="配置默认网关 - 交换机的默认网关"></a>配置默认网关 - 交换机的默认网关</h3><p>连接客户端计算机的交换机通常是第 2 层设备。因此，第 2 层交换机不需要使用 IP 地址就能正常工作。但是，可以在交换机上配置 IP 配置，以便管理员能够远程访问交换机。</p><p>要通过本地 IP 网络连接和管理交换机，必须配置交换机虚拟接口 (SVI)。SVI 配置了本地局域网上的 IPv4 地址和子网掩码。要从远端网络管理交换机，必须给交换机配置一个默认网关。</p><p>在会通过本地网络之外的方式通信的所有设备上，一般都会配置默认网关地址。</p><p>要为交换机配置默认网关，请使用ip default-gateway ip-address 全局配置命令。配置的 IP 地址是连接到交换机的本地路由器接口的 IP 地址。</p><p>图中显示了管理员正在建立到另一个网络上的交换机 S1 的远程连接。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/8_4.png"><p>在此示例中，管理员主机将使用其默认网关将数据包发送到 R1 的 G0/0/1 接口。R1 会将数据包从其 G0/0/0 接口转发到 S1。由于数据包源 IPv4 地址来自另一个网络，因此 S1 需要默认网关才能将数据包转发到 R1 的 G0/0/0 接口。因此，S1必须配置默认网关才能够应答并建立与管理主机的 SSH 连接。</p><p>注意: 来自与交换机相连的主机计算机的数据包必须在主机计算机操作系统上配置默认网关地址。</p><p>也可以使用 SVI 上的 IPv6 地址配置工作组交换机。但是，交换机不需要手动配置默认网关的 IPv6 地址。交换机将自动接收来自路由器的 ICMPv6 路由器公告消息的默认网关。</p><hr><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li>配置初始路由器设置</li></ul><blockquote><p>在路由器上配置初始设置时，应完成以下任务。</p></blockquote><ol><li>配置设备名称。</li><li>保护特权模式。</li><li>保护用户模式。</li><li>保护远程 Telnet / SSH 访问。</li><li>保护配置文件中的所有密码。</li><li>提供法律通知。</li><li>保存配置。</li></ol><ul><li>配置接口</li></ul><blockquote><p>要使路由器可访问，必须配置路由器接口。思科 ISR 4321 路由器配备了两个千兆以太网接口：千兆以太网 0/0/0（G0/0/0）和千兆以太网 0/0/1（G0/0/1）。配置路由器接口的任务与交换机上管理 SVI 非常相似。使用 no shutdown 命令会激活界面。接口还必须连接到另一台设备（交换机或路由器），才能使物理层处于活动状态。有多条命令可用于检验接口配置，包括了show ip interface brief和show ipv6 interface brief，show ip route和show ipv6 route，以及show interfaces、show ip interface和show ipv6 interface.。</p></blockquote><ul><li>配置默认网关</li></ul><blockquote><p>对于通过网络通信的终端设备，必须配置正确的 IP 地址信息，包括默认网关地址。默认网关地址通常是连接主机本地网络的路由器接口地址。主机设备的 IP 地址和路由器接口地址必须位于同一网络。要通过本地 IP 网络连接和管理交换机，必须配置交换机虚拟接口 (SVI)。SVI 配置了本地局域网上的 IPv4 地址和子网掩码。要从远端网络管理交换机，必须给交换机配置一个默认网关。要为交换机配置默认网关，请使用ip default-gateway ip-addressIP地址全局配置命令。使用连接到交换机的本地路由器接口的IPv4地址。</p></blockquote><hr><h2 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a><a href="https://phoenixnest.github.io/School-Computer-Network-Technology-IPv4/">IPv4编址</a></h2><hr><h2 id="IPv6编址"><a href="#IPv6编址" class="headerlink" title="IPv6编址"></a><a href="https://phoenixnest.github.io/School-Computer-Network-Technology-IPv6/">IPv6编址</a></h2><hr><h2 id="ICMP-消息"><a href="#ICMP-消息" class="headerlink" title="ICMP 消息"></a>ICMP 消息</h2><h3 id="主机可接通性"><a href="#主机可接通性" class="headerlink" title="主机可接通性"></a>主机可接通性</h3><p>ICMP Echo消息可用于测试 IP 网络上主机的可达性。本地主机向一台主机发送 ICMP Echo请求。如果主机可用，目的主机会回应以Echo应答。<code>使用 ICMP Echo消息是ping实用程序的基础</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_1_1.png" alt="H1 向 H2 发送 Echo 请求，询问 H2 是否可达"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_1_2.png" alt="Echo 请求消息转发"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_1_3.png" alt="H2 接收到 H1 发送的 Echo 请求，并发送 Echo 应答消息"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_1_4.png" alt="Echo 应答消息转发"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_1_5.png" alt="H1 收到 H2 的 Echo 应答"></p><hr><h3 id="目的地或服务不可达"><a href="#目的地或服务不可达" class="headerlink" title="目的地或服务不可达"></a>目的地或服务不可达</h3><p>当主机或网关收到无法传送的数据包时，它会使用 ICMP 目的地不可达消息通知源主机，目的地或服务无法到达。消息包括指示数据包为何无法传送的代码。</p><blockquote><p>ICMPv4 的目的地不可达代码示例有：</p></blockquote><ul><li><p><strong>0</strong> - <strong>网络</strong>不可达。</p></li><li><p><strong>1</strong> - <strong>主机</strong>不可达。</p></li><li><p><strong>2</strong> - <strong>协议</strong>不可达。</p></li><li><p><strong>3</strong> - <strong>端口</strong>不可达。</p></li></ul><blockquote><p>ICMPv6 的目的地不可达代码示例有：</p></blockquote><ul><li><p><strong>0</strong> - 没有通往目标的路由。</p></li><li><p><strong>1</strong> - 管理上禁止与目的地通信（例如防火墙）。</p></li><li><p><strong>2</strong> - 超出源地址的范围。</p></li><li><p><strong>3</strong> - 地址无法访问。</p></li><li><p><strong>4</strong> - 端口不可达。</p></li></ul><p>注意: ICMPv6 的目的地不可达消息代码与此类似，但稍有不同。</p><hr><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><blockquote><p>路由器使用 <strong>ICMPv4</strong> 超时消息表明，因为数据包的生存时间（TTL，Time To Live）字段递减到 0 而不能转发该数据包。<strong>如果路由器接收数据包并且将 IPv4 数据包的 TTL 字段的值递减为零，则它会丢弃数据包并向源主机发送超时消息</strong>。</p></blockquote><blockquote><p>如果路由器因数据包过期而无法转发 IPv6 数据包，<strong>ICMPv6</strong> 也会发送超时消息。<strong>ICMPv6使用IPv6跳数限制字段来确定数据包是否已过期，而不是IPv4 TTL字段</strong>。</p></blockquote><p>注意: <code>traceroute 跟踪路由工具使用超时消息</code>。</p><hr><h3 id="ICMPv6-消息"><a href="#ICMPv6-消息" class="headerlink" title="ICMPv6 消息"></a>ICMPv6 消息</h3><p>在 ICMPv6 中发现的信息和错误消息非常类似于 ICMPv4 的控制和错误消息。但是，ICMPv6 拥有 ICMPv4 中所没有的新特性和功能提升。ICMPv6 消息封装在 IPv6 中。</p><p>ICMPv6 在邻居发现协议（ND 或 NDP）中包括四个新协议。</p><p>IPv6 路由器和 IPv6 设备之间的消息传递，包括动态地址分配如下所示：</p><ul><li><p><strong>路由器请求 (RS) 消息</strong></p></li><li><p><strong>路由器通告 (RA) 消息</strong></p></li></ul><p>IPv6 设备之间的消息传递，包括重复的地址检测和地址解析如下所示：</p><ul><li><p><strong>邻居请求 (NS) 消息</strong></p></li><li><p><strong>邻居通告 (NA) 消息</strong></p></li></ul><p>注意: ICMPv6 ND 还包括重定向消息，与 ICMPv4 中使用的重定向消息功能相似。</p><hr><p><strong>RA 消息</strong></p><blockquote><p>启用IPv6的路由器每200秒发送RA消息，向启用IPv6的主机提供编址信息。RA 消息中可以包含主机的编址信息，例如前缀、前缀长度、DNS 地址和域名。使用 SLAAC 的主机会将其默认网关设置为发送 RA 的路由器的本地链路地址。</p></blockquote><p>R1 向 FF02 发送 RA 路由器广告消息：1 将达到 PC1 的全节点组播地址。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_4_1.png"><hr><p><strong>RS 消息</strong></p><blockquote><p>启用IPv6 的路由器还会发送 RA 消息以响应 RS 消息。在图中，PC1 发送 RS 消息以确定如何动态接收其 IPv6 地址信息。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_4_2.png"><hr><p><strong>NS 消息</strong></p><p>当设备分配有全局IPv6单播或本地链路单播地址时，则建议对地址执行 重复检测（DAD） 来确保IPv6地址的唯一性。</p><blockquote><p>如图所示，要检查地址的唯一性，设备将发送 NS 信息，其中使用自身 IPv6 地址作为目标 IPv6 地址。</p></blockquote><p>如果网络中的其他设备具有该地址，则会使用 NA 消息进行响应。此 NA 消息通知发送方设备地址已在使用。如果回应的 NA 消息未在固定的一段时间返回，则单播地址是唯一的，可以使用。</p><p>注意: DAD 不是必需的，但是 RFC 4861 建议对单播地址执行 DAD。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_4_3.png"><hr><p><strong>NA 消息</strong></p><p>当 LAN 上的设备知道目的 IPv6 单播地址，但不知道其以太网 MAC 地址时，会使用地址解析。</p><blockquote><p>要确定目的 MAC 地址，设备会将 NS 消息发送到请求节点地址。该消息包括已知（目标）IPv6 地址。具有目标 IPv6 地址的设备会使用包含其以太网 MAC 地址的 NA 消息进行回应。</p></blockquote><p>在图中，R1向2001:db8:acad:1::10发送一条NS消息，询问它的MAC地址。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_4_4.png"><hr><h3 id="Ping-测试连接性"><a href="#Ping-测试连接性" class="headerlink" title="Ping 测试连接性"></a>Ping 测试连接性</h3><p>Ping 是一种测试程序，它使用 ICMP Echo请求和Echo应答消息来测试主机之间的连接。</p><p>为了测试与网络上的另一台主机的连接，可使用 ping 命令将回应请求发送给该主机地址。若指定地址处的主机收到回应请求，便会使用Echo应答进行响应。每收到一个Echo应答，ping都会提供发出请求与收到应答的时间反馈。这可以作为网络性能的度量。</p><p>Ping 对响应规定了超时值。如果在超时前没有收到应答，ping 会提供一条消息，表示未收到响应。这可能表示存在问题，但是，还可能表示在网络上启用了阻止 ping 消息的安全功能。如果在发送ICMP Echo请求之前需要执行地址解析(ARP或ND)，那么第一次ping通常会超时。</p><p>所有请求发送完毕后，ping实用程序会提供摘要，包括成功率和到达目的地的平均往返时间。</p><p>使用ping进行的连通性测试的类型包括:</p><ul><li><p><strong>Ping 本地环回</strong></p></li><li><p><strong>向默认网关发出 ping 命令</strong></p></li><li><p><strong>Ping 远程主机</strong></p></li></ul><hr><h3 id="对环回执行-ping-命令"><a href="#对环回执行-ping-命令" class="headerlink" title="对环回执行 ping 命令"></a>对环回执行 ping 命令</h3><p>Ping可用于测试本地主机上IPv4或IPv6的内部配置。要执行此测试，对于 IPv4，我们ping本地环回地址 127.0.0.1，对于 IPv6，则是 ::1。</p><p>从 127.0.0.1 接收的 IPv4 响应或从 ::1 接收的 IPv6 响应，表示主机上的 IP 安装正确。此响应来自网络层。但是，此响应并不代表地址、掩码或网关配置正确。它也不能说明有关网络协议栈下层的任何状态。它只测试 IP 网络层的 IP 连接。如果收到错误消息，则表示该主机上的 TCP/IP 无法正常运行。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_6.png"><hr><h3 id="向默认网关发出-ping-命令"><a href="#向默认网关发出-ping-命令" class="headerlink" title="向默认网关发出 ping 命令"></a>向默认网关发出 ping 命令</h3><p>您也可以使用ping 测试主机在本地网络中通信的能力。这通常是通过 ping 主机网关 IP 地址完成的。成功 ping通网关表示主机和充当网关的路由器接口在本地网络中均运行正常。</p><p>对于此测试，最常用的是网关地址，因为路由器在一般情况下始终都能正常运行。如果网关地址不响应，可以将ping发送到本地网络上已知能够正常运行的另一台主机的 IP 地址。</p><p>如果网关或另一台主机做出响应，则说明本地主机可以通过本地网络成功通信。如果网关不响应但其另一台主机响应，可能说明充当网关的路由器接口存在问题。</p><p>一种可能性是在主机上配置了错误的网关地址。另一种可能原因是路由器接口完全正常，但对其采取了阻止其处理或响应 ping 请求的安全限制。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_7.png"><hr><h3 id="Ping-远程主机"><a href="#Ping-远程主机" class="headerlink" title="Ping 远程主机"></a>Ping 远程主机</h3><blockquote><p>Ping 也可用于测试本地主机跨互联网通信的能力。本地主机可以 ping 远程网络中运行正常的 IPv4 主机。路由器使用其 IP 路由表转发数据包。</p><blockquote><p>如果 ping 成功，则说明网际网络大部分运行正常。在互联网络上成功 ping通即确认本地网络上的通信正常，充当网关的路由器运行正常，且可能位于本地网络和远程主机网络之间路径上的所有其他路由器运行正常。</p></blockquote></blockquote><p>此外，还可以验证远程主机的功能。如果远程主机无法在其本地网络外通信，则它不会响应。</p><p>注意:<code>许多网络管理员限制或禁止 ICMP 消息进入企业网络；因此，没有收到ping响应可能是由于安全限制</code>。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_8.gif"><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_8_1.png" alt="本地主机向另一远程主机发送 ping 请求"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_8_2.png" alt="交换机检查 IPv4 数据包，转发远程请求数据包"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_8_3.png" alt="远程路由器检查 IPv4 数据包，转发远程请求数据包"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_8_4.png" alt="远程交换机检查 IPv4 数据包，转发远程请求数据包"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_8_5.png" alt="远程主机接收 ping 请求，并做出应答"></p><blockquote><p>应答顺序与请求顺序一致，但方向相反。例：顺着网线来打你</p></blockquote><hr><h3 id="Traceroute-测试路径"><a href="#Traceroute-测试路径" class="headerlink" title="Traceroute - 测试路径"></a>Traceroute - 测试路径</h3><p>Ping 用于测试两台主机之间的连接，但是不提供关于主机之间设备的详细信息。</p><blockquote><p>Traceroute tracert实用程序可以生成通信路径上成功到达的设备列表。此列表可以提供重要的验证和故障排除信息。如果数据到达目的地，则 Trace 就会列出主机之间的路径中每台路由器上的接口。如果数据在沿途的某一跳上失败，则回应 Trace 的最后一个路由器的地址可以提供指示，说明发现问题或有安全限制的地方。</p></blockquote><ul><li>往返时间</li></ul><blockquote><p>Traceroute 可提供沿路径每一跳的往返时间并指示是否有某一跳未响应。往返时间是数据包到达远程主机以及从该主机返回响应所花费的时间。星号 (*) 用于表示丢失的或无应答的数据包。</p><blockquote><p>此信息可用于在路径中定位有问题的路由器，或表示路由器配置为不应答。如果显示器显示特定的某一跳响应时间长或数据丢失，这表示该路由器的资源或其连接可能压力过大。</p></blockquote></blockquote><ul><li>IPv4 TTL 和 IPv6 跳数限制</li></ul><blockquote><p>Traceroute 使用第 3 层报头中的 IPv4 TTL 字段功能和 IPv6 跳数限制字段功能以及 ICMP 超时消息。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_9.gif"><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_9_1.png" alt="本地主机向另一远程主机发送 traceroute 请求"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_9_2.png" alt="交换机检查数据包，转发 traceroute 数据包"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_9_3.png" alt="远程路由器检查 traceroute 数据包，但 ICMP 处理超时"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_9_4.png" alt="远程路由器检查 traceroute 数据包，返回超时信息"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_9_5.png" alt="交换机转发超时数据包，终端打印信息，并结束一次数据包生命"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/11_9_5.png" alt="当数据包成功传输到远端时，远端设备将响应 ICMP Echo 并做出应答，返回本地设备"></p><blockquote><p>从 Traceroute 发送的第一个消息序列的 TTL 字段值为 1。这会导致此 TTL 使 IPv4 数据包在第一台路由器处超时。该路由器使用 ICMPv4 超时消息作为响应。现在，<code>Traceroute 知道了第一跳的地址</code>。</p></blockquote><blockquote><p>随后，Traceroute 逐渐增加每个消息系列的 TTL 字段值（2、3、4…）。这可为 Trace 提供数据包在该路径沿途再次超时所经过的每一跳的地址。TTL 字段的值将不断增加，直至到达目的主机或增至预定义的最大值。</p></blockquote><blockquote><p>到达最终目的主机后，该主机将不再以 ICMP 超时消息做出应答，而会以 ICMP 端口无法到达消息或 ICMP Echo应答消息做出应答。</p></blockquote><hr><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul><li>ICMP消息</li></ul><blockquote><p>TCP/IP 套件在与其他 IP 设备通信时提供错误消息和信息性消息。这些消息使用 ICMP 发送。这些消息的目的是提供有关在一定条件下处理IP数据包的相关问题的反馈。ICMP消息对于ICMPv4和ICMPv6来说都是通用的，包括主机连通性、目的地或服务不可达以及超时。ICMP Echo消息测试 IP 网络上主机的可达性。本地主机向一台主机发送 ICMP Echo请求。如果主机可用，目的主机会回应以Echo应答。这是 ping 实用程序的基础。当主机或网关收到无法传送的数据包时，它会使用 ICMP 目的地不可达消息通知源主机。消息包括指示数据包为何无法传送的代码。路由器使用 ICMPv4 超时消息表明，因为数据包的生存时间 (TTL) 字段递减到零而不能转发该数据包。如果路由器接收数据包并且将TTL 字段的值递减为零，则它会丢弃数据包并向源主机发送超时消息。ICMPv6 还会在这种情况下发送超时。ICMPv6使用IPv6跳数限制字段来确定数据包是否已过期。traceroute工具使用超时消息。IPv6 路由器和 IPv6 设备之间的消息（包括动态地址分配）包括 RS 和 RA。IPv6 设备之间的消息包括重定向（类似于 IPv4）、NS 和 NA。</p></blockquote><ul><li>Ping和Traceroute测试</li></ul><blockquote><p>Ping 使用 ICMP Echo请求和Echo应答消息来测试主机之间的连接。为了测试与网络上的另一台主机的连接，可使用 ping 命令将Echo请求发送给该主机地址。若指定地址处的主机收到回应请求，便会使用Echo应答进行响应。每收到一个Echo应答，ping 都会提供发出请求与收到应答的时间反馈。所有请求发送完毕后，ping 实用程序会提供摘要，包括成功率和到达目的地的平均往返时间。Ping可用于测试本地主机上IPv4或IPv6的内部配置。Ping 本地环回地址 127.0.0.1，对于 IPv6，则是 ::1。用 ping 命令通过 ping 主机默认网关的 IP 地址来测试主机在本地网络上进行通信的能力。成功 ping通网关表示主机和充当网关的路由器接口在本地网络中均运行正常。Ping 也可用于测试本地主机跨网际网络通信的能力。本地主机可以ping 远程网络中运行正常的 IPv4 主机。Traceroute (tracert) 可以生成通信路径上成功到达的跳数列表。此列表提供了验证和故障排除信息。如果数据到达目的地，则 Trace 就会列出主机之间的路径中每台路由器上的接口。如果数据在沿途的某一跳上失败，则回应 Trace 的最后一个路由器的地址可以提供指示，说明发现问题或有安全限制的地方。往返时间是数据包到达远程主机以及从该主机返回响应所花费的时间。Traceroute 使用第 3 层报头中的 IPv4 TTL 字段功能和 IPv6 跳数限制字段功能以及 ICMP 超时消息。</p></blockquote><hr><h2 id="传输层（第-4-层）"><a href="#传输层（第-4-层）" class="headerlink" title="传输层（第 4 层）"></a><a href="https://phoenixnest.github.io/School-Computer-Network-Technology-4-Transport-Layer/">传输层（第 4 层）</a></h2><hr><h2 id="会话层（第-5-层）"><a href="#会话层（第-5-层）" class="headerlink" title="会话层（第 5 层）"></a>会话层（第 5 层）</h2><blockquote><p>顾名思义，会话层的功能就是创建并维护源应用程序和目的应用程序之间的对话。会话层用于处理信息交换，发起对话并使其处于活动状态，并在对话中断或长时间处于空闲状态时重启会话。</p></blockquote><hr><h2 id="表示层（第-6-层）"><a href="#表示层（第-6-层）" class="headerlink" title="表示层（第 6 层）"></a>表示层（第 6 层）</h2><p>表示层具有三个主要功能：</p><ul><li><p><strong>将来自源设备的数据格式化或表示成兼容形式，以便目的设备接收。</strong></p></li><li><p><strong>采用可被目的设备解压缩的方式对数据进行压缩。</strong></p></li><li><p><strong>加密要传输的数据并在收到数据时解密数据。</strong></p></li></ul><p>如图所示，表示层为应用层格式化数据并制定文件格式标准。常见的视频标准包括Matroska视频(MKV)、活动图像专家组 (MPEG)和QuickTime视频(MOV)。常见图形图像格式为图形交换格式 (GIF)、联合图像专家组 (JPG) 和便携式网络图像 (PNG) 格式。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/14.png"><hr><h2 id="应用层（第-7-层）"><a href="#应用层（第-7-层）" class="headerlink" title="应用层（第 7 层）"></a><a href="https://phoenixnest.github.io/School-Computer-Network-Technology-7-Application-Layer/">应用层（第 7 层）</a></h2><hr><h2 id="网络安全基础"><a href="#网络安全基础" class="headerlink" title="网络安全基础"></a><a href="https://phoenixnest.github.io/School-Computer-Network-Technology-Cyber-Security/">网络安全基础</a></h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理 • 网络安全基础</title>
      <link href="School-Computer-Network-Technology-Cyber-Security/"/>
      <url>School-Computer-Network-Technology-Cyber-Security/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇是对<a href="https://phoenixnest.github.io/Notes-Computer-Network-Technology/">计算机网络原理</a>一文中的<a href="https://phoenixnest.github.io/School-Computer-Network-Technology/#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80">网络安全基础知识</a>部分的详细介绍。<br>所用教学平台：<a href="%22https://cn.netacad.com/%22">Cisco Networking Academy</a></p></blockquote><hr><h2 id="安全威胁和漏洞"><a href="#安全威胁和漏洞" class="headerlink" title="安全威胁和漏洞"></a>安全威胁和漏洞</h2><h3 id="威胁类型"><a href="#威胁类型" class="headerlink" title="威胁类型"></a>威胁类型</h3><p>有线和无线计算机网络是人们日常活动中不可或缺的一部分。个人和组织都同样依赖其计算机和网络。不速之客的入侵可能导致代价高昂的网络中断和工作成果的丢失。针对网络的攻击有时具有相当的破坏性，可能造成重要信息或资产的损坏或失窃，导致时间上和金钱上的损失。</p><p>入侵者会通过软件漏洞、硬件攻击或通过猜测某人的用户名和密码来获取网络访问。通过修改或利用软件漏洞来获取访问权的入侵者通常被称为威胁发起者。</p><p>一旦威胁发起者取得网络的访问权，就可能给网络带来四种威胁。</p><blockquote><p>信息盗窃</p></blockquote><p>指侵入计算机以获取机密信息。信息可以用于各种目的或出售。例子: 盗窃组织的专有信息，例如研究和开发数据。</p><img style="height: 240px;width: 240px" src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_1_1.png"><hr><blockquote><p>数据丢失与操纵</p></blockquote><p>是指闯入计算机破坏或更改数据记录。数据丢失的示例是：一个威胁发起者发送可重新格式化计算机硬盘的病毒。数据操纵示例是：闯入记录系统来更改信息（例如物品价格）。</p><img style="height: 240px;width: 240px" src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_1_2.png"><hr><blockquote><p>身份盗窃</p></blockquote><p>是一种信息盗窃形式，以冒用他人的身份为目的窃取个人信息。利用此类信息，威胁发起者便可以非法获取文件、申请信用贷款或者进行未经授权的在线购物。身份盗窃案件日渐增多，每年造成的损失达数十亿之多。</p><img style="height: 240px;width: 240px" src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_1_3.png"><hr><blockquote><p>服务中断</p></blockquote><p>阻止合法用户访问他们有权访问的服务。例如: 对服务器、网络设备或网络通信链路发起的拒绝服务 (DoS) 攻击。</p><img style="height: 240px;width: 240px" src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_1_4.png"><hr><h3 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h3><p>漏洞是指网络或设备的薄弱程度。路由器、交换机、桌面、服务器、甚至安全设备都存在一定程度的漏洞。一般而言，受到攻击的网络设备都是端点设备，例如服务器和台式计算机。</p><p>有三种主要的漏洞或弱点：技术、配置和安全策略。所有这三种漏洞源都会让网络或设备对各种攻击保持开放状态，包括恶意代码攻击和网络攻击。</p><hr><blockquote><p>技术漏洞</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_2_1.png"><hr><blockquote><p>配置漏洞</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_2_2.png"><hr><blockquote><p>策略漏洞</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_2_3.png"><hr><h3 id="物理安全"><a href="#物理安全" class="headerlink" title="物理安全"></a>物理安全</h3><p>网络中一个同样重要的漏洞区域是设备的物理安全性。如果网络资源可以被物理性破坏，攻击发起者便可借此拒绝对网络资源的使用。</p><p>物理威胁分为四类：</p><ul><li><p><strong>硬件威胁</strong> － 这包括对服务器、路由器、交换机、布线间和工作站的物理破坏</p></li><li><p><strong>环境威胁</strong> －这包括极端温度（过热或过冷）或极端湿度（过湿或过干）</p></li><li><p><strong>电气威胁</strong> － 这包括电压过高、电源电压不足（电气管制）、不合格电源（噪音），以及断电</p></li><li><p><strong>维护威胁</strong> － 这包括关键电气组件处理不佳（静电放电），缺少关键备用组件、布线混乱和标识不明</p></li></ul><p>必须创建和实现一个良好的物理安全计划来解决这些问题。该图显示了物理安全计划的一个示例。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_3.png" alt="制定物理安全规划，限制对设备的破坏"></p><hr><h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><h3 id="恶意软件的类型"><a href="#恶意软件的类型" class="headerlink" title="恶意软件的类型"></a>恶意软件的类型</h3><p>上一主题介绍了网络威胁的类型以及使威胁成为可能的漏洞。本主题将详细介绍威胁发起者如何获得网络的访问权限或限制授权用户的访问权限。</p><p>恶意软件是“有恶意的软件”的简称。是专门用来损坏、破坏、窃取数据、主机或网络或对数据、主机或网络进行“坏的”或者非法操作的代码或软件。恶意软件的类型包括病毒、蠕虫和特洛伊木马</p><ul><li>病毒</li></ul><blockquote><p>计算机病毒是一种通过将自身副本插入另一个程序并成为其一部分来传播的恶意软件类型。它在计算机之间传播，感染所到之处。病毒从严重程度上来讲包括从导致轻度恼人影响到损坏数据或软件和导致拒绝服务 (DoS) 条件。几乎所有的病毒都是附加到一个可执行文件中，这意味着病毒可能在系统上存在，但在用户运行或打开恶意主机文件或程序前不会处于活跃状态也不会传播。执行主机代码后，也就执行了病毒代码。通常情况下，主机程序在感染了病毒后仍继续运行。但是，一些病毒用其自身副本覆盖其他程序，这就完全破坏了主机程序。当病毒附加的软件或文档通过网络、磁盘、文件共享或被感染的电子邮件附件从一台计算机传输到另一台计算机时，也传播了病毒。</p></blockquote><ul><li>蠕虫</li></ul><blockquote><p>计算机蠕虫与病毒相似，它们均可复制自身的功能副本，并造成相同类型的损坏。与病毒相比，病毒需要通过感染的主机文件来传播，而蠕虫属于独立软件，无需借助主机程序或人工帮助即可传播。蠕虫不需要附加在程序中来感染主机并通过系统漏洞进入计算机。蠕虫无需帮助便可利用系统功能在网络中传输。</p></blockquote><ul><li>特洛伊木马</li></ul><blockquote><p>特洛伊木马是另一种类型的恶意软件，以希腊人用来潜入特洛伊的木马来命名。它是看起来合法的有害软件。用户通常是被骗加载特洛伊木马并在他们的系统上执行。特洛伊木马激活后，可以在主机上进行任意数量的攻击，从激怒用户（过多的弹窗或改变桌面）到破坏主机（删除文件、窃取数据或激活和传播病毒等其他恶意软件）。众所周知，特洛伊木马为恶意用户访问系统创建后门。</p></blockquote><p>不同于病毒和蠕虫，特洛伊木马不通过感染其他文件进行复制。它们也不自我复制。特洛伊木马必须通过用户交互传播，如打开电子邮件附件或从互联网下载并运行文件。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_4.gif"><hr><h3 id="侦察攻击"><a href="#侦察攻击" class="headerlink" title="侦察攻击"></a>侦察攻击</h3><p>除了恶意代码攻击外，网络还可能遭受各种网络攻击。网络攻击可分为三大类别：</p><ul><li><p><strong>侦察攻击</strong> – 搜索和映射系统、服务或漏洞</p></li><li><p><strong>访问攻击</strong> – 数据、系统或用户访问权限的未授权控制</p></li><li><p><strong>拒绝服务</strong> – 网络、系统或服务的禁用或损坏</p></li></ul><p>对于侦察攻击，外部威胁发起者可以使用互联网工具（如nslookup和whois实用程序）轻松地确定分配给公司或实体的 IP 地址空间。确定 IP 地址空间后，威胁发起者可以 ping 这些公有 IP 地址以确定哪些地址正在使用。为帮助自动执行此步骤，威胁发起者可能会使用 ping 扫描工具，例如<strong>fping</strong>或<strong>gping</strong>。它系统地向给定范围或子网中的所有网络地址执行 ping 操作。这类似于浏览电话簿的某一部分，拨打其中列出的每个号码，看哪些号码有人接听。</p><blockquote><p>互联网查询</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_5_1.gif" alt="威胁发起者正在查找与目标相关的初始信息。他可以使用多种工具，其中包括Google搜索、组织机构网站、whois等。"></p><blockquote><p>Ping 扫描</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_5_2.gif" alt="现在，威胁发起 ping 扫描，以确定哪些 IP 地址处于活动状态。"></p><blockquote><p>端口扫描</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_5_3.gif" alt="威胁发起者对发现的活动 IP 地址执行端口扫描。"></p><hr><h3 id="访问攻击"><a href="#访问攻击" class="headerlink" title="访问攻击"></a>访问攻击</h3><p>访问攻击利用身份验证服务、FTP 服务和 Web 服务的已知漏洞，获取对 Web 帐户、机密数据库和其他敏感信息的访问。访问攻击使个人能够对他们无权查阅的信息进行未经授权访问。访问攻击可分为四种类型：密码攻击、信任利用、端口重定向和中间人攻击。</p><blockquote><p>密码攻击</p></blockquote><p>威胁发起者可以使用多种方法实施密码攻击：</p><ul><li><p>暴力攻击</p></li><li><p>特洛伊木马攻击</p></li><li><p>数据包嗅探</p></li></ul><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_6_1.png"><hr><blockquote><p>信任利用</p></blockquote><p>在信任利用攻击中，威胁发起者会使用未经授权的特权来访问系统，可能还会进一步攻陷目标。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_6_2.gif"><hr><blockquote><p>端口重定向</p></blockquote><p>在端口重定向攻击中，威胁发起者会把攻陷的系统作为攻击其他目标的大本营。图中的示例显示出威胁发起者使用 SSH（端口22）连接受攻击主机 A 的威胁发起者。主机 B 信任主机 A；因此，允许威胁发起者使用 Telnet 访问主机 B。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_6_3.png"><hr><blockquote><p>中间人</p></blockquote><p>在中间人攻击中，威胁发起者会置身于两个合法实体之间，以便读取或修改双方之间传输的数据。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_6_4.png"><hr><h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3><p>拒绝服务 (DoS) 攻击是知名度最高的攻击，并且是最难防范的攻击。然而，由于其实施简单、破坏力强大，安全管理员需要特别关注 DoS 攻击。</p><p>DoS 攻击的方式多种多样。不过其目的都是通过消耗系统资源使授权用户无法正常使用服务。为了帮助防止 DoS 攻击，必须使操作系统和应用程序与最新的安全更新保持同步。</p><blockquote><p>DoS攻击</p></blockquote><p>DoS 攻击属于重大风险，因为它们可以中断通信，并在时间和财务上造成大量损失。这些攻击执行起来相对简单，即使是缺乏技能的威胁发起者也可以执行。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_7_1.gif"><hr><blockquote><p>DDoS攻击</p></blockquote><p>分布式 DoS 攻击 (DDoS) 与 DoS 攻击类似，但是它从多个协同攻击源发起攻击。举例来说，威胁发起者建立了一个受感染主机的网络，受感染的主机称为僵尸主机。受感染主机（僵尸）的网络称为僵尸网络。威胁发起者使用命令和控制(CnC)程序来指示僵尸网络进行DDoS攻击。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_7_2.gif"><hr><h2 id="网络攻击缓解"><a href="#网络攻击缓解" class="headerlink" title="网络攻击缓解"></a>网络攻击缓解</h2><h3 id="纵深防御方法"><a href="#纵深防御方法" class="headerlink" title="纵深防御方法"></a>纵深防御方法</h3><p>现在您已经了解了更多有关威胁发起者如何入侵网络的信息，您需要了解如何防止这种未经授权的访问。本主题详细介绍了为使您的网络更加安全可以采取的一些措施。</p><p>要缓解网络攻击，必须首先保护设备，包括路由器、交换机、服务器和主机。大多数组织机构使用纵深防御法（也称为分层方法）来确保安全性。这需要网络设备和服务相互配套以协同工作。</p><p>思考图中的网络。已经实施了若干安全设备和服务来保护用户和资产免受 TCP/IP 威胁的侵害。</p><p>通过所有网络设备（包括路由器和交换机）各自图标上显示的密码组合锁判断，这些网络设备也经过了强化。这表示这些设备已受到保护，以防止威胁发起者对其获取访问权和进行篡改。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_8.png"><hr><h3 id="保留备份"><a href="#保留备份" class="headerlink" title="保留备份"></a>保留备份</h3><p>备份设备配置和数据是防止数据丢失的最有效方式之一。数据备份可将计算机上的信息副本存储到可放在安全地方的可移动备份介质中。基础设施设备应该在FTP或类似的文件服务器上备份配置文件和IOS映像。如果计算机或路由器硬件发生故障，可以使用备份副本恢复数据或配置。</p><p>应根据安全策略中的规定定期执行备份。数据备份通常存储在非现场位置，在主要设施发生任何问题时能保护备份介质。Windows 主机提供了备份和还原实用程序。对用户来说，将数据备份到其他驱动器或基于云的存储提供商非常重要。</p><p>该表显示了备份考虑事项及其描述。</p><table><thead><tr><th align="left">考虑事项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">频率</td><td align="left">1. 根据安全策略中的标识定期执行备份。 2.完全备份可能非常耗时，因此需要每月或 或每周执行一次备份，并经常对更改的文件进行部分备份。</td></tr><tr><td align="left">存储容量</td><td align="left">务必对备份进行验证，以确保数据的完整性并验证文件恢复程序。验证文件恢复程序。</td></tr><tr><td align="left">安全</td><td align="left">应按照安全策略的要求，每天，每周或每月轮流将备份转移到批准的异地存储位置。</td></tr><tr><td align="left">验证</td><td align="left">应使用强密码保护备份。恢复数据需要提供密码。</td></tr></tbody></table><hr><h3 id="升级、更新和补丁"><a href="#升级、更新和补丁" class="headerlink" title="升级、更新和补丁"></a>升级、更新和补丁</h3><p>保持与最新进展同步会使对网络攻击的防御更加有效。随着新的恶意软件不断涌现，企业必须保持当前的防病毒软件为最新版本。</p><p>缓解蠕虫攻击的最有效方法是从操作系统厂商处下载安全更新，并为所有存在漏洞的系统应用补丁。管理大量系统时，会牵涉到创建用于部署在新系统或升级系统上的标准软件映像（经授权可在客户端系统中使用的操作系统和可信任的应用程序）。但是，安全要求不断变化，而且已部署系统也可能需要安装安全更新补丁。</p><p>管理关键安全补丁的一个解决方案是确保所有终端系统自动下载更新，如图中Windows 10所示。安全补丁会自动下载并安装，无需用户干预。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_10.png"><hr><h3 id="认证、授权和记账"><a href="#认证、授权和记账" class="headerlink" title="认证、授权和记账"></a>认证、授权和记账</h3><p>所有网络设备都应该进行安全配置，只允许经过授权的个人访问。认证、授权和记账（AAA 或“三 A”）网络安全服务提供了设置网络设备访问控制的主要框架。</p><p>AAA 方法用于控制可以访问网络的用户（认证）、用户访问网络时可以执行的操作（授权），以及把他们在那里时所做的事记录下来（记账）。</p><p>AAA 的概念类似于信用卡的使用。信用卡会确定谁可以使用它、消费限额是多少，并记录使用者的消费项目，如图所示。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_11.png"><hr><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>防火墙是保护用户远离外部威胁的最为有效的安全工具之一。防火墙可通过防止不必要的流量进入内部网络来保护计算机和网络。</p><p>防火墙驻留在两个或多个网络之间，控制其间的流量并帮助阻止未授权的访问。例如，图中上面的拓扑说明防火墙如何使来自内部网络主机的流量离开并返回到内部网络。底部拓扑说明系统如何拒绝外部网络（即 Internet）发起的流量访问内部网络。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_12_1.png" alt="防火墙操作"></p><p>防火墙可以允许外部用户控制对特定服务的访问。例如，外部用户可访问的服务器通常位于称为隔离区 (DMZ) 的特殊网络中，如图所示。DMZ 使网络管理员能够为连接到该网络的主机应用特定策略。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/16_12_2.png" alt="带有DMZ的防火墙拓扑"></p><hr><h3 id="防火墙的类型"><a href="#防火墙的类型" class="headerlink" title="防火墙的类型"></a>防火墙的类型</h3><p>防火墙产品可以打包成各种形式。这些产品使用不同技术来区分应禁止和应允许的网络访问。其包括以下内容：</p><ul><li><p><strong>数据包过滤</strong> - 根据 IP 或 MAC 地址阻止或允许访问</p></li><li><p><strong>应用程序过滤</strong> - 根据端口号阻止或允许访问特定类型的应用程序</p></li><li><p><strong>URL 过滤</strong> - 根据特定的 URL 或关键字阻止或允许访问网站</p></li><li><p><strong>状态包侦测（SPI，Serial Peripheral Interface）</strong> - 传入数据包必须是对内部主机所发出请求的合法响应。除非得到特别允许，否则未经请求的数据包会被拦截。状态包侦测还可具有识别和过滤特定类型攻击，例如拒绝服务 (DoS) 的能力。</p></li></ul><hr><h3 id="终端安全"><a href="#终端安全" class="headerlink" title="终端安全"></a>终端安全</h3><p>端点，或主机，是充当网络客户端的单个计算机系统或设备。常见终端包括笔记本电脑、台式机、服务器、智能手机和平板电脑。保护端点设备是网络管理员最具挑战性的工作之一，因为它牵涉到人类本性。</p><p>公司必须制定适当的有明确记录的策略，并且员工必须了解这些规则。需要培训员工正确使用网络。</p><p>策略通常包括使用防病毒软件和主机入侵防御。更全面的终端安全解决方案依赖网络访问控制。</p><hr><h2 id="设备安全"><a href="#设备安全" class="headerlink" title="设备安全"></a>设备安全</h2><p>在网路中有很多区域需要格外提供安全防护，设备本身就是其中之一。您可能已经有了计算机、智能手机或平板电脑的密码。它是否足够坚固？您是否使用其他工具来增强设备的安全性? 本主题会告诉您怎么做。</p><p>当在设备上安装新的操作系统时，安全设置保留为默认值。在大多数情况下，这种安全级别并不够。对于思科路由器，思科AutoSecure 功能可用于协助保护系统，如示例所示。</p><pre><code class="CISCO">Router# auto secure                --- AutoSecure Configuration ---*** AutoSecure configuration enhances the security ofthe router but it will not make router absolutely securefrom all security attacks ***</code></pre><p>此外，还有以下适用于大部分操作系统的一些简单步骤：</p><ul><li><p>立即更换默认用户名和密码。</p></li><li><p>限制对系统资源的访问，只有授权用户才可以访问。</p></li><li><p>尽可能关闭和卸载任何不必要的服务和应用程序。</p></li></ul><p>通常，制造商提供的设备已经在仓库中存放了一段时间，并没有安装最新补丁。必须在实施之前更新所有软件并安装所有安全补丁。</p><hr><h3 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h3><p>为了保护网络设备，使用强密码非常重要。以下是需要遵循的标准原则：</p><ul><li><p>使用的密码长度至少为 8 个字符，最好是 10 个或更多字符。密码越长越安全。</p></li><li><p>使用复杂密码。如果条件允许，密码中混合使用大写和小写字母、数字、符号和空格。</p></li><li><p>密码中避免使用重复的常用字词、字母或数字顺序、用户名、亲属或宠物的名字、个人传记信息（例如出生日期、身份证号码、祖先的名字）或其他易于识别的信息。</p></li><li><p>故意将口令中的词拼错。例如，Smith = Smyth = 5mYth 或 Security = 5ecur1ty。</p></li><li><p>定期更改密码。如果密码不知不觉地遭到破坏，那么威胁发起者使用该密码的机会就会受到限制。</p></li><li><p>请勿将密码写出来并放在显眼位置上，比如桌面上或显示屏上。</p></li></ul><blockquote><p>弱密码</p></blockquote><table><thead><tr><th align="center">弱密码</th><th align="center">密码薄弱的原因</th></tr></thead><tbody><tr><td align="center">secret</td><td align="center">简单词典密码</td></tr><tr><td align="center">smith</td><td align="center">姓氏</td></tr><tr><td align="center">toyota</td><td align="center">汽车品牌</td></tr><tr><td align="center">bob1967</td><td align="center">用户的姓名和生日</td></tr><tr><td align="center">Blueleaf23</td><td align="center">简单的单词和数字</td></tr></tbody></table><blockquote><p>强密码</p></blockquote><table><thead><tr><th align="center">强密码</th><th align="center">密码强的原因</th></tr></thead><tbody><tr><td align="center">b67n42d39c</td><td align="center">组合使用字母数字字符</td></tr><tr><td align="center">12^h u4@1p7</td><td align="center">组合使用字母数字字符和特殊符号，并包括空格</td></tr></tbody></table><p>思科路由器会忽略密码中的前置空格，但第一个字符之后的空格不会忽略。因此，创建强密码的一种方法就是使用空格键和创建一个由多个词组成的短语。这就是所谓的密码短语。密码短语通常比简单密码更易记忆。而且猜到它所用时间更长，也更难猜到。</p><hr><h3 id="其他密码安全性"><a href="#其他密码安全性" class="headerlink" title="其他密码安全性"></a>其他密码安全性</h3><p>强密码只有在保持其机密性才是有用的。在思科路由器和交换机上可以采取以下几个步骤来帮助确保密码的机密性：</p><ul><li><p>加密所有的明文密码</p></li><li><p>设置可接受的最小密码长度</p></li><li><p>阻止暴力密码猜测攻击</p></li><li><p>在指定时间后 禁用非活动的特权 EXEC 模式访问。</p></li></ul><p>如图中的示例配置所示，<strong>service password-encryption</strong>全局配置命令防止未经授权的个人在配置文件中查看明文形式的密码。哪个命令可加密所有的明文密码？请注意在示例中，密码 “cisco” 已加密为 “03095A0F034F”。</p><p>为了确保配置的所有密码至少为指定的最小长度，请在全局配置模式下使用 <strong>security passwords min-length</strong>命令。在图中，任何新配置的密码都必须至少有8个字符。</p><p>威胁发起者可以使用密码破解软件对网络设备进行暴力攻击。这种攻击不断尝试猜测有效的密码，直到其中一个成功为止。使用 <strong>login block-for # attempts # within #</strong> 全局配置命令来阻止此类攻击。如图中示例，<strong>login block-for 120 attempts 3 within 60</strong>命令是在 60 秒内有 3 次登录尝试失败时阻止vty登录尝试 120 秒。</p><p>网络管理员可能会分心，意外地在终端上打开一个特权执行模式会话。这可能使内部威胁发起者能够更改或删除设备配置。</p><p>默认情况下，思科路由器将在 10 分钟不活动后注销 EXEC 会话。但是，您可以使用 <strong>exec-timeout</strong> 分 秒 线路配置命令减少此设置。此命令可应用于在线控制台、辅助线路和 vty 线路。在图中，我们告诉思科设备在用户闲置 5 分 30 秒后自动断开 vty 线上的非活动用户。</p><pre><code class="CISCO">R1(config)# service password-encryption R1(config)# security passwords min-length 8 R1(config)# login block-for 120 attempts 3 within 60R1(config)# line vty 0 4 R1(config-line)# password cisco R1(config-line)# exec-timeout 5 30 R1(config-line)# transport input ssh R1(config-line)# end R1# R1# show running-config | section line vtyline vty 0 4 password 7 094F471A1A0A exec-timeout 5 30 login transport input sshR1#</code></pre><hr><h3 id="启用-SSH"><a href="#启用-SSH" class="headerlink" title="启用 SSH"></a>启用 SSH</h3><p>Telnet简化了远程设备访问，但并不安全。Telnet 数据包中包含的数据以未加密形式传输。因此，强烈建议在设备上启用安全外壳 (SSH) 以进行安全远程访问。</p><p>可以通过下列六个步骤来配置思科设备以支持 SSH。</p><ul><li><p><strong>步骤 1. 配置唯一的主机名</strong> - 设备必须有一个唯一的主机名，而不是默认主机名。</p></li><li><p><strong>步骤 2. 配置 IP 域名</strong> - 使用全局配置命令 <strong>ip-domain name</strong> 配置网络的 IP 域名。</p></li><li><p><strong>步骤 3. 生成密钥来加密 SSH 流量</strong> - SSH 加密源和目的地之间的流量。但是，要这样做，必须使用全局配置命令 <strong>crypto key generate rsa general-keys modulus</strong> 位数 生成唯一的身份验证密钥。该模数位数确定密钥大小并且可配置为 360 位至 2048 位。位值越大，密钥越安全。然而，较大的位值也需要较长的时间来加密和解密信息。最小建议系数长度为 1024 位。</p></li><li><p><strong>步骤 4. 验证或创建一个本地数据库条目</strong> - 使用 username 全局配置命令来创建本地数据库用户名条目。在示例中，使用了参数secret，因此密码将使用MD5加密。</p></li><li><p><strong>步骤 5. 向本地数据库认证身份</strong> - 使用 <strong>login local</strong> 线路配置命令对本地数据库的vty线路进行身份验证。</p></li><li><p><strong>步骤 6. 启用 vty inbound SSH 会话</strong> - 默认情况下，在 vty 线路上不允许输入会话。您可以使用 <strong>transport input [ssh | telnet]</strong> 命令指定多个输入协议，包括 Telnet 和 SSH。</p></li></ul><p>如示例所示，路由器 R1 配置在 span.com 域中。此信息与<strong>crypto key generate rsa general-keys modulus</strong>命令中指定的位值一起使用，用于创建加密密钥。</p><p>接下来，为名为 Bob 的用户创建本地数据库条目。最后，将vty线路配置为根据本地数据库进行身份验证，并且只接受传入的SSH会话。</p><pre><code class="CISCO">Router# configure terminalRouter(config)# hostname R1R1(config)# ip domain name span.comR1(config)# crypto key generate rsa general-keys modulus 1024The name for the keys will be: Rl.span.com % The key modulus size is 1024 bits% Generating 1024 bit RSA keys, keys will be non-exportable...[OK]•Dec 13 16:19:12.079: %SSH-5-ENABLED: SSH 1.99 has been enabledR1(config)#R1(config)# username Bob secret ciscoR1(config)# line vty 0 4R1(config-line)# login localR1(config-line)# transport input sshR1(config-line)# exitR1(config)#</code></pre><hr><h3 id="禁用未使用的服务"><a href="#禁用未使用的服务" class="headerlink" title="禁用未使用的服务"></a>禁用未使用的服务</h3><p>思科路由器和交换机启动时会有一列活动服务，这些活动在您的网络中可能需要或不需要。禁用任何未使用的服务以保留系统资源，如CPU周期和RAM，并防止威胁发起者利用这些服务。默认打开的服务类型将根据IOS版本而有所不同。例如，IOS-XE 通常只打开 HTTPS 和 DHCP 端口。您可以使用 show ip ports all 命令来验证这一点，如示例所示。</p><pre><code class="CISCO">Router# show ip ports allProto Local Address               Foreign Address             State       PID/Program NameTCB       Local Address               Foreign Address             (state)tcp   :::443                     :::*                        LISTEN      309/[IOS]HTTP COREtcp   *:443                      *:*                         LISTEN      309/[IOS]HTTP COREudp   *:67                        0.0.0.0:0                               387/[IOS]DHCPD ReceiveRouter#</code></pre><p>IOS-XE 之前的 IOS 版本使用 show control-plane host open-ports 命令。我们提到此命令，因为您可能会在旧设备上看到它。输出是相似的。但是，请注意，这个较旧的路由器有不安全的 HTTP 服务器和 Telnet 正在运行。这两种服务都应该被禁用。如示例所示，使用 no ip http server 全局配置命令禁用 HTTP。通过在行配置命令transport input ssh中指定仅 SSH 来禁用 Telnet 。</p><pre><code class="CISCO">Router# show control-plane host open-ports Active internet connections (servers and established)Prot        Local Address      Foreign Address                  Service    State tcp                 *:23                  *:0                   Telnet   LISTEN tcp                 *:80                  *:0                HTTP CORE   LISTEN udp                 *:67                  *:0            DHCPD Receive   LISTENRouter# configure terminalRouter(config)# no ip http serverRouter(config)# line vty 0 15Router(config-line)# transport input ssh</code></pre><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>安全威胁和漏洞</li></ul><blockquote><p>针对网络的攻击有时具有相当的破坏性，可能造成重要信息或资产的损坏或失窃，导致时间上和金钱上的损失。通过修改或利用软件漏洞来获取访问权的入侵者通常是威胁发起者。当黑客取得网络的访问权后，就可能给网络带来以下四种威胁：信息盗窃、数据丢失或操纵、身份盗窃以及服务中断。有三种主要的漏洞或弱点：技术、配置和安全策略。物理威胁分为四类：硬件、环境、电气和维护。</p></blockquote><ul><li>网络攻击</li></ul><blockquote><p>恶意软件是“有恶意的软件”的简称。是专门用来损坏、破坏、窃取数据、主机或网络或对数据、主机或网络进行“坏的”或者非法操作的代码或软件。恶意软件的类型包括病毒、蠕虫和特洛伊木马网络攻击可分为三大类：侦察、访问和拒绝服务。物理威胁分为四类：硬件、环境、电气和维护。三种类型的侦察攻击是：互联网查询、ping 扫描和端口扫描。四种类型的访问攻击是：密码（暴力、木马、数据包嗅探器）、信任利用、端口重定向和中间人。服务中断攻击的两种类型是：DoS 和 DDoS。</p></blockquote><ul><li>网络攻击缓解</li></ul><blockquote><p>要缓解网络攻击，必须首先保护设备，包括路由器、交换机、服务器和主机。大多数组织机构使用纵深防御法来确保安全性。这需要网络设备和服务相互配合以协同工作。这个环境中部署了一些安全设备和服务，来保护组织机构的用户、资产，免遭TCP/IP威胁的侵害：VPN、ASA防火墙、IPS、ESA/WSA和AAA服务器。基础设施设备应该在FTP或类似的文件服务器上备份配置文件和IOS映像。如果计算机或路由器硬件发生故障，可以使用备份副本恢复数据或配置。缓解蠕虫攻击的最有效方法是从操作系统厂商处下载安全更新，并为所有存在漏洞的系统应用补丁。要管理重要的安全补丁，请确保所有终端系统自动下载更新。AAA 方法用于控制可以访问网络的用户（认证）、用户可以执行的操作（授权），以及用户在访问网络时的行为（记账）。防火墙驻留在两个或多个网络之间，控制其间的流量并帮助阻止未授权的访问。外部用户可访问的服务器通常位于称为DMZ的特殊网络中。防火墙使用各种技术来确定允许或拒绝访问网络的内容，包括：数据包过滤、应用程序过滤、URL过滤和 SPI。保护终端设备的安全对于网络安全至关重要。公司必须制定有据可查的策略，其中可能包括使用杀毒软件和主机入侵防御。更全面的终端安全解决方案依赖网络访问控制。</p></blockquote><ul><li>设备安全</li></ul><blockquote><p>当在设备上安装新的OS时，安全设置保留为默认值。这种安全级别并不够。对于思科路由器，思科 AutoSecure 功能可用于协助保护系统。对于大多数OS的默认用户名和密码应该立即更改，对系统资源的访问应仅限于被授权使用这些资源的个人，任何不必要的服务和应用程序都应该尽可能地关闭和卸载。为了保护网络设备，使用强密码非常重要。密码短语通常比简单密码更易记忆。而且猜到它所用时间更长，也更难猜到。对于路由器和交换机，加密所有明文密码，设置可接受的最小密码长度，阻止暴力密码猜测攻击，并在指定时间后禁用非活动特权 EXEC 模式访问。配置适当的设备来支持SSH，并禁用未使用的服务。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理 • IPv6 编址</title>
      <link href="School-Computer-Network-Technology-IPv6/"/>
      <url>School-Computer-Network-Technology-IPv6/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇是对<a href="https://phoenixnest.github.io/Notes-Computer-Network-Technology/">计算机网络原理</a>一文中的<a href="https://phoenixnest.github.io/School-Computer-Network-Technology/#IPv6%E7%BC%96%E5%9D%80">IPv6 编址</a>部分的详细介绍。<br>所用教学平台：<a href="%22https://cn.netacad.com/%22">Cisco Networking Academy</a></p></blockquote><hr><h2 id="IPv4-的问题"><a href="#IPv4-的问题" class="headerlink" title="IPv4 的问题"></a>IPv4 的问题</h2><h3 id="IPv6-的必要性"><a href="#IPv6-的必要性" class="headerlink" title="IPv6 的必要性"></a>IPv6 的必要性</h3><p>您已经知道IPv4的地址用完了。这就是为什么您需要了解 IPv6 的原因。</p><p>IPv6 旨在接替 IPv4。IPv6 拥有更大的 128 位地址空间，提供 340 涧（即，340后面有36个0）个不确定地址。不过，IPv6 不只是具有更大的地址空间。</p><p>当 IEFT 开始开发 IPv4 的接替版本时，还借此机会修复了 IPv4 的限制，并开发了增强功能。一个示例是 Internet 控制消息协议第 6 版 (ICMPv6)，它包括 IPv4 的 ICMP (ICMPv4) 中没有的地址解析和地址自动配置功能。</p><p>IPv4 地址空间耗尽一直是迁移到 IPv6 的动因。随着非洲、亚洲和世界其他地区越来越多地使用互联网，IPv4 地址已经无法满足这一增长需求。如图所示，5 个 RIR 中的 4 个都已耗尽了 IPv4 地址。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_1.png" alt="各RIR IPv4地址耗尽日期"></p><p>理论上，IPv4 最多有 43 亿个地址。私有地址与网络地址转换 (NAT) 对于放缓 IPv4 地址空间的耗尽起了不可或缺的作用。然而，NAT对于许多应用程序来说是有问题的，它会造成延迟，并且有严重阻碍对等体对对等体通信的限制。</p><p>随着移动设备数量的不断增加，移动供应商一直在引领着向IPv6的过渡。美国最大的两家移动运营商报告称，他们超过90%的流量都在IPv6之上。</p><p>大多数顶级ISP和内容提供商，如YouTube、Facebook和NetFlix，也已经完成了过渡。许多公司，如微软、Facebook和LinkedIn，都在向内部只允许使用ipv6过渡。2018年，宽带ISP Comcast报告部署超过65%，英国天空广播报告超过86%。</p><hr><blockquote><p>物联网</p></blockquote><p>当今的互联网与过去几十年相比大有不同。当今的互联网不仅仅是邮件、网页和计算机之间的文件传输。互联网正在不断向物联网 (IoT) 发展。能够访问互联网的设备将不仅仅只有计算机、平板电脑和智能手机。未来安装有传感器并支持互联网访问的设备将包括汽车、生物化学设备和家用电器以及自然生态系统等一切事物。</p><p>考虑到互联网用户的不断增加、有限的 IPv4 地址空间、NAT 问题和物联网等问题，是时候开始向 IPv6 过渡了。</p><hr><h3 id="IPv4-和-IPv6-共存"><a href="#IPv4-和-IPv6-共存" class="headerlink" title="IPv4 和 IPv6 共存"></a>IPv4 和 IPv6 共存</h3><p>过渡到 IPv6 不是一朝一夕可以完成的。在不久的将来，IPv4和IPv6都将共存，并且过渡将需要几年的时间。IETF 已经创建了各种协议和工具来协助网络管理员将网络迁移到 IPv6。迁移技术可分为三类：</p><ul><li>双堆栈</li></ul><p>双堆栈允许 IPv4 和 IPv6 在同一网段上共存。双堆栈设备同时运行 IPv4 和 IPv6 协议栈。称为原生 IPv6，这意味着客户网络与他们的ISP建立了IPv6连接，并能够通过IPv6访问互联网上的内容。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_2_1.png"><ul><li>隧道</li></ul><p>隧道是一种通过 IPv4 网络传输 IPv6 数据包的方法。IPv6 数据包与其他类型数据类似，也封装在 IPv4 数据包中。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_2_2.png"><ul><li>转换</li></ul><p>网络地址转换 64 (NAT64) 允许支持 IPv6 的设备与支持 IPv4 的设备使用类似于 IPv4 中 NAT 的转换技术进行通信。IPv6 数据包被转换为 IPv4 数据包，IPv4 数据包被转换为 IPv6 数据包。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_2_3.png"><blockquote><p>注意: 隧道和转换用于过渡到原生IPv6，仅应在需要时使用。目标是从源到目的地进行本地 IPv6 通信。</p></blockquote><hr><h2 id="IPv6-地址表示方法"><a href="#IPv6-地址表示方法" class="headerlink" title="IPv6 地址表示方法"></a>IPv6 地址表示方法</h2><h3 id="IPv6-编址格式"><a href="#IPv6-编址格式" class="headerlink" title="IPv6 编址格式"></a>IPv6 编址格式</h3><p>学习网络中的IPv6的第一步是理解IPv6地址的编写和格式化方式。IPv6 地址比 IPv4 地址多得多，这就是为什么我们不太可能用完它们。</p><p>IPv6 地址长度为 128 位，写作十六进制值字符串。如图所示，每 4 位以一个十六进制数字表示，<br>共 32 个十六进制值。IPv6 地址不区分大小写，可用大写或小写书写。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_3.png" alt="16位数据段或十六进制数"></p><blockquote><p>首选格式</p></blockquote><p>前面的图也显示了，书写 IPv6 地址的首选格式为 x:x:x:x:x:x:x:x，每个“x”均包括四个十六进制值。术语“八位组”是指 IPv4 地址的八位。在 IPv6 中，十六位位组是指代 16 位二进制或四位十六进制数的非官方术语。每个“x”是一个16 位二进制数或四位十六进制数字组成的十六进制数。</p><p>首选格式表示使用所有 32 个十六进制数字书写 IPv6 地址。这并不意味着它是表示 IPv6 地址的理想方法。在本模块中，您将了解到有两条规则可帮助减少表示一个 IPv6 地址所需数字的数目。</p><p>这些是IPv6 地址首选格式的示例。</p><pre><code class="IPv6">2001 : 0db8 : 0000 : 1111 : 0000 : 0000 : 0000: 0200 2001 : 0db8 : 0000 : 00a3 : abcd : 0000 : 0000: 1234 2001 : 0db8 : 000a : 0001 : c012 : 9aff : fe9a: 19ac 2001 : 0db8 : aaaa : 0001 : 0000 : 0000 : 0000: 0000 fe80 : 0000 : 0000 : 0000 : 0123 : 4567 : 89ab: cdef fe80 : 0000 : 0000 : 0000 : 0000 : 0000 : 0000: 0001 fe80 : 0000 : 0000 : 0000 : c012 : 9aff : fe9a: 19ac fe80 : 0000 : 0000 : 0000 : 0123 : 4567 : 89ab: cdef 0000 : 0000 : 0000 : 0000 : 0000 : 0000 : 0000: 0001 0000 : 0000 : 0000 : 0000 : 0000 : 0000 : 0000: 0000 </code></pre><hr><h3 id="规则-1-省略前导-0"><a href="#规则-1-省略前导-0" class="headerlink" title="规则 1 - 省略前导 0"></a>规则 1 - 省略前导 0</h3><p>第一条有助于缩短 IPv6 地址记法的规则是省略十六进制数中的所有前导 0（零）。以下是省略前导零的四个方法示例：</p><ul><li><p><strong>01ab</strong> 可表示为 1ab</p></li><li><p><strong>09f0</strong> 可表示为 9f0</p></li><li><p><strong>0a00</strong> 可表示为 a00</p></li><li><p><strong>00ab</strong> 可表示为 ab</p></li></ul><p>此规则仅适用于前导 0，不适用于后缀 0，否则会造成地址不明确。例如，十六进制的“abc”可能是“0abc”，也可能是“abc0”，但这些表示的值不相同。</p><blockquote><p>省略前导 0</p></blockquote><table><thead><tr><th align="center">类型</th><th align="center">格式</th></tr></thead><tbody><tr><td align="center"><strong>首选</strong></td><td align="center">2001 : <strong>0</strong>db8 : <strong>000</strong>0 : 1111 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>0</strong>200</td></tr><tr><td align="center"><strong>无前导 0</strong></td><td align="center">2001 :  db8 :    0 : 1111 :    0 :    0 :    0 :  200</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>首选</strong></td><td align="center">2001 : <strong>0</strong>db8 : <strong>000</strong>0 : <strong>00</strong>a3 : ab00 : <strong>0</strong>ab0 : <strong>00</strong>ab : 1234</td></tr><tr><td align="center"><strong>无前导 0</strong></td><td align="center">2001 :  db8 :    0 :   a3 : ab00 :  ab0 :   ab : 1234</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>首选</strong></td><td align="center">2001 : <strong>0</strong>db8 : <strong>000</strong>a : <strong>000</strong>1 : c012 : 90ff : fe90 : <strong>000</strong>1</td></tr><tr><td align="center"><strong>无前导 0</strong></td><td align="center">2001 :  db8 :    a :    1 : c012 : 90ff : fe90 :    1</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>首选</strong></td><td align="center">2001 : <strong>0</strong>db8 : aaaa : <strong>000</strong>1 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0</td></tr><tr><td align="center"><strong>无前导 0</strong></td><td align="center">2001 :  db8 : aaaa :    1 :    0 :    0 :    0 :    0</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>首选</strong></td><td align="center">fe80 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>0</strong>123 : 4567 : 89ab : cdef</td></tr><tr><td align="center"><strong>无前导 0</strong></td><td align="center">fe80 :    0 :    0 :    0 :  123 : 4567 : 89ab : cdef</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>首选</strong></td><td align="center">fe80 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>1</td></tr><tr><td align="center"><strong>无前导 0</strong></td><td align="center">fe80 :    0 :    0 :    0 :    0 :    0 :    0 :    1</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>首选</strong></td><td align="center"><strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>1</td></tr><tr><td align="center"><strong>无前导 0</strong></td><td align="center">0 :    0 :    0 :    0 :    0 :    0 :    0 :    1</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>首选</strong></td><td align="center"><strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0 : <strong>000</strong>0</td></tr><tr><td align="center"><strong>无前导 0</strong></td><td align="center">0 :    0 :    0 :    0 :    0 :    0 :    0 :    0</td></tr></tbody></table><hr><h3 id="规则-2-双冒号"><a href="#规则-2-双冒号" class="headerlink" title="规则 2 - 双冒号"></a>规则 2 - 双冒号</h3><p>第二条有助于缩短 IPv6 地址记法的规则是使用双冒号 (::) 替换任何由一个或多个全由 0 组成的16 位十六进制数组成的连续字符串。例如，2001:db8:cafe:1:0:0:0:1（前导0省略）可以表示为2001:db8:cafe:1::1。双冒号 (::) 用于代替三个全 0十六进制数 (0:0:0)。</p><p>双冒号 (::) 仅可在每个地址中使用一次，否则可能会得出一个以上的地址。当与忽略前导 0 的方法一起使用时，IPv6 地址记法可以大幅缩短。这通常称为压缩格式。</p><p>下面是一个不正确使用双冒号的例子：2001:db8::abcd::1234。</p><p>在上面的例子中，双冒号使用了两次。以下是这个不正确的压缩格式地址可能的扩展:</p><ul><li><p>2001:db8::abcd:0000:0000:1234</p></li><li><p>2001:db8::abcd:0000:0000:0000:1234</p></li><li><p>2001:db8:0000:abcd::1234</p></li><li><p>2001:db8:0000:0000:abcd::1234</p></li></ul><p>如果一个地址有多个连续的全为0的十六进制数字符串，最佳实践是在最长的字符串上使用双冒号(::)。如果字符串相等，则第一个字符串应使用双冒号 (::)。</p><blockquote><p>省略前导 0 和所有 0 段</p></blockquote><table><thead><tr><th align="center">类型</th><th align="center">格式</th></tr></thead><tbody><tr><td align="center"><strong>首选</strong></td><td align="center">2001 : <strong>0</strong>db8 : <strong>000</strong>0 : 1111 : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0</strong>200</td></tr><tr><td align="center"><strong>压缩/空间</strong></td><td align="center">2001 :  db8 :    0 : 1111 :                    :  200</td></tr><tr><td align="center"><strong>压缩</strong></td><td align="center">2001:db8:0:1111::200</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>首选</strong></td><td align="center">2001 : <strong>0</strong>db8 : <strong>000</strong>0 : <strong>000</strong>0 : ab00 : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong></td></tr><tr><td align="center"><strong>压缩/空间</strong></td><td align="center">2001 :  db8 :    0 :    0 : ab00 ::</td></tr><tr><td align="center"><strong>压缩</strong></td><td align="center">2001:db8:0:0:ab00::</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>首选</strong></td><td align="center">2001 : <strong>0</strong>db8 : aaaa : <strong>000</strong>1 : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong></td></tr><tr><td align="center"><strong>压缩/空间</strong></td><td align="center">2001 :  db8 : aaaa :    1 ::</td></tr><tr><td align="center"><strong>压缩</strong></td><td align="center">2001:db8:aaaa:1::</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>首选</strong></td><td align="center">fe80 : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0</strong>123 : 4567 : 89ab : cdef</td></tr><tr><td align="center"><strong>压缩/空间</strong></td><td align="center">fe80 :                    :  123 : 4567 : 89ab : cdef</td></tr><tr><td align="center"><strong>压缩</strong></td><td align="center">fe80::123:4567:89ab:cdef</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>首选</strong></td><td align="center">fe80 : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>000</strong>1</td></tr><tr><td align="center"><strong>压缩/空间</strong></td><td align="center">fe80 :                                         :    1</td></tr><tr><td align="center"><strong>压缩</strong></td><td align="center">fe80::1</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>首选</strong></td><td align="center"><strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>000</strong>1</td></tr><tr><td align="center"><strong>压缩/空间</strong></td><td align="center">::                                                  1</td></tr><tr><td align="center"><strong>压缩</strong></td><td align="center">::1</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>首选</strong></td><td align="center"><strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong> : <strong>0000</strong></td></tr><tr><td align="center"><strong>压缩/空间</strong></td><td align="center">::</td></tr><tr><td align="center"><strong>压缩</strong></td><td align="center">::</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><hr><h2 id="IPv6-地址类型"><a href="#IPv6-地址类型" class="headerlink" title="IPv6 地址类型"></a>IPv6 地址类型</h2><h3 id="单播，组播，任播"><a href="#单播，组播，任播" class="headerlink" title="单播，组播，任播"></a>单播，组播，任播</h3><p>与 IPv4 一样，有不同类型的 IPv6 地址。事实上，IPv6 地址有三大类：</p><ul><li><p><strong>单播</strong> - IPv6 单播地址用于唯一标识支持 IPv6 的设备上的接口。</p></li><li><p><strong>组播</strong> - IPv6 组播地址用于将单个 IPv6 数据包发送到多个目的地。</p></li><li><p><strong>任播</strong> -IPv6 任播地址是可分配到多个设备的 IPv6 任播地址。发送至任播地址的数据包会被路由到最近的拥有该地址的设备。任播地址不在本课程的讨论范围之内。</p></li></ul><p>与 IPv4 不同，IPv6 没有广播地址。但是，IPv6 具有 IPv6 全节点组播地址，这在本质上与广播地址的效果相同。</p><hr><h3 id="IPv6-前缀长度"><a href="#IPv6-前缀长度" class="headerlink" title="IPv6 前缀长度"></a>IPv6 前缀长度</h3><p>IPv4 地址的前缀或网络部分可以由点分十进制子网掩码或前缀长度（斜线记法）标识。例如， IPv4 地址 192.168.1.10（点分十进制子网掩码为 255.255.255.0）等值于 192.168.1.10/24。</p><p>在 IPv4 中，/24 称为前缀。在 IPv6 中，它被称为前缀长度。IPv6 不使用点分十进制子网掩码记法。与IPv4一样，前缀长度以斜线记法表示，用于表示 IPv6 地址的网络部分。</p><p>前缀长度范围为 0 至 128。推荐的局域网和大多数其他网络类型 IPv6 前缀长度为 /64，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_7.png" alt="IPv6 前缀长度"></p><p>强烈建议对大多数网络使用 64 位接口 ID。这是因为无状态地址自动配置(SLAAC)使用64位作为接口ID。它还使子网划分更易于创建和管理。</p><hr><h3 id="IPv6-单播地址的类型"><a href="#IPv6-单播地址的类型" class="headerlink" title="IPv6 单播地址的类型"></a>IPv6 单播地址的类型</h3><p>IPv6 单播地址用于唯一标识支持 IPv6 的设备上的接口。发送到单播地址的数据包由分配有该地址的接口接收。与 IPv4 类似，源 IPv6 地址必须是单播地址。目的 IPv6 地址可以是单播地址也可以是组播地址。该图显示了IPv6 单播地址的不同类型。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_8.png" alt="IPv6 单播地址"></p><p>与IPv4设备只有一个地址不同，IPv6地址通常有两个单播地址:</p><ul><li><p><strong>全局单播地址(GUA)</strong> - 这类似于公有 IPv4 地址。这些地址具有全局唯一性，是互联网可路由的地址。GUA可静态配置或动态分配</p></li><li><p><strong>链路本地地址 (LLA)</strong> - 这对于每个支持ipv6的设备都是必需的。LLA用于与同一链路中的其他设备通信。在 IPv6 中，术语链路是指子网。LLA仅限于单个链路。它们的唯一性仅在该链路上得到保证，因为它们在该链路之外不具有可路由性。换句话说，路由器不会转发具有本地链路源地址或目的地址的数据包。</p></li></ul><hr><h3 id="关于唯一本地地址的注意事项"><a href="#关于唯一本地地址的注意事项" class="headerlink" title="关于唯一本地地址的注意事项"></a>关于唯一本地地址的注意事项</h3><p>唯一本地地址（范围 fc00:: /7 到 fdff:: /7）尚未普遍实现。因此，本模块仅涵盖 GUA 和 LLA 配置。然而，唯一本地地址最终可能被用于地址不应该从外部访问的设备，例如内部服务器和打印机。</p><p>IPv6 唯一本地地址与 IPv4 的 RFC 1918 私有地址具有相似之处，但是也有着重大差异。</p><ul><li><p>唯一本地地址用于一个站点内或数量有限的站点之间的本地编址。</p></li><li><p>唯一本地地址可用于从来不需要访问其他网络的设备。</p></li><li><p>唯一本地地址不会全局路由或转换为全局 IPv6 地址。</p></li></ul><p>注意: 许多站点也使用 RFC 1918 地址的私有性质来尝试去保护或隐藏其网络，使其免遭潜在的安全风险。但是，这绝不是这些技术的既定用途，IETF 始终推荐各站点在面向互联网的路由器上采取妥善的安全预防措施。</p><hr><h3 id="IPv6-GUA"><a href="#IPv6-GUA" class="headerlink" title="IPv6 GUA"></a>IPv6 GUA</h3><p>IPv6 全局单播地址 (GUA) 具有全局唯一性，可在 IPv6互联网上路由。这些地址相当于公有 IPv4 地址。互联网名称与数字地址分配机构 (ICANN)，即 IANA 的运营商，将 IPv6 地址块分配给五家 RIR。目前分配的仅是前三位为 001 或 2000::/3 的全局单播地址（GUA），如图所示。</p><blockquote><p>该图显示了第一个十六进制数的值范围，其中当前可用的GUAs的第一个十六进制数字以2或3开头。这只是可用 IPv6 地址空间的 1/8，对于其他类型单播和组播地址而言只是很小的一部分。</p></blockquote><blockquote><p>注意: 2001:db8::/32已经留作备档之用，包括示例用途。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_10_1.png" alt="该图显示了 GUA 的三个部分：首先是全局路由前缀，然后是子网 ID，最后是接口 ID。全局路由前缀的前三位是 001。第一个十六进制数的范围显示为0010 0000 0000 0000(2000)到0011 1111 1111 1111 (3fff)"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_10_2.png" alt="该图显示了 GUA 的三个部分：首先是带有48位长度的全局路由前缀，然后是16位长度的子网 ID，最后是64位长度的接口 ID。图下的文字写明：一个/ 48路由前缀 + 16 位子网 ID = /64前缀"></p><hr><h3 id="IPv6-GUA-结构"><a href="#IPv6-GUA-结构" class="headerlink" title="IPv6 GUA 结构"></a>IPv6 GUA 结构</h3><ul><li>全局路由前缀</li></ul><blockquote><p>全局路由前缀为提供商（如 ISP）分配给客户或站点的地址的前缀或网络部分。例如，ISP 通常会为其客户分配 /48 全局路由前缀。全局路由前缀通常会因 ISP 的策略而异。</p></blockquote><p>前面的图显示了使用/48全局路由前缀的GUA。/48 前缀是分配的常见全局路由前缀，本课程中的多数示例均使用该前缀。</p><p>例如，IPv6 地址2001:db8:acad::/48 的全局路由前缀，该前缀表示ISP知道该前缀（网络）的方式是前48位（3个十六进制数）（2001:db8:acad）。/48 前缀长度后面的双冒号 (::) 表示地址的剩余部分全部为 0。全局路由前缀的大小决定子网 ID 的大小。</p><ul><li>子网ID</li></ul><blockquote><p>子网ID字段是全局路由前缀和接口ID之间的区域。与IPv4不同，在IPv4中您必须从主机部分借用位来创建子网，IPv6在设计时考虑到了子网。组织使用子网 ID 确定其站点的子网。子网 ID 越大，可用子网越多。</p></blockquote><p>注意: 许多组织正在接收 /32 全局路由前缀。使用推荐的 /64 前缀来创建 64 位接口 ID，会留下一个 32 位子网 ID。这意味着具有 /32 全局路由前缀和 32 位子网 ID 的组织将拥有 43 亿个子网，每个子网都有 1800亿亿（18后面跟18个0）个子网。这是与公有 IPv4 地址数量一样多的子网！</p><p>在前面的图中，IPv6地址有一个/48全局路由前缀，这在许多企业网络中很常见。这使得检查地址的不同部分变得特别容易。使用典型的/64前缀长度，前四个十六进制数是地址的网络部分，其中第四个十六进制数表示子网 ID。剩下的四个十六进制数用于接口 ID。</p><ul><li>接口ID</li></ul><blockquote><p>IPv6 接口 ID 相当于 IPv4 地址的主机部分。使用术语“接口 ID”是因为单个主机可能有多个接口，而每个接口又有一个或多个 IPv6 地址。该图显示了 IPv6 GUA 的结构示例。强烈建议在大多数情况下使用 /64 子网，这会创建64位接口ID。64 位接口 ID 允许每个子网有1800亿亿个设备或主机。</p></blockquote><p>/64 子网或前缀（全局路由前缀 + 子网 ID）为接口 ID 留下 64 位。建议允许启用 SLAAC 的设备创建自己的 64 位接口 ID。它还使得 IPv6 编址计划的开发变得简单而有效。</p><p>注意: 与 IPv4 不同，在 IPv6 中，全 0 和全 1 主机地址可以分配给设备。可以使用全1地址，因为广播地址不在IPv6中使用。全 0 地址也可使用，但它留作子网路由器任播地址，应仅分配给路由器。</p><hr><h3 id="IPv6-LLA"><a href="#IPv6-LLA" class="headerlink" title="IPv6 LLA"></a>IPv6 LLA</h3><p>IPv6 链路本地地址(LLA)允许设备与同一链路上支持 IPv6 的其他设备通信，并且只能在该链路（子网）上通信。具有源或目的LLA的数据包不能在数据包的源链路之外进行路由。</p><p>GUA 不是一项要求。但是，每个启用 IPv6 的网络接口都必须有 LLA。</p><p>如果没有手动为接口配置LLA，设备会在不与 DHCP 服务器通信的情况下自动创建自己的地址。支持 IPv6 的主机会创建 IPv6 LLA，即使没有为该设备分配 IPv6 全局单播地址。这允许支持 IPv6 的设备与同一子网中的其他支持 IPv6 的设备通信。这包括与默认网关（路由器）的通信。</p><p>IPv6 LLAs在fe80::/10范围内。/10 表示前 10 位是 1111 1110 10xx xxxx。第一个十六进制数的范围是 1111 1110 1000 0000 (fe80) 到 1111 1110 1011 1111 (febf)。</p><blockquote><p>该图显示使用IPv6 LLA进行通信的示例。PC 能够使用LLA直接与打印机进行通信。</p></blockquote><blockquote><p>物理拓扑显示有两台 PC、一台服务器、一台打印机、一台交换机和一台路由器。它描述了链路本地通信不会路由到网络之外</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_12_1.png" alt="IPv6 链路本地通信"></p><p>下图显示了IPv6 LLA的一些用途。</p><blockquote><p>该图显示了两个路由器通过一个带有LLA地址的链路进行连接。带有指向每个路由器的双向箭头的数字1与文本“路由协议消息”一起通过链路。一台PC与左侧的路由器相连，带有数字2，一个箭头从PC指向路由器。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_12_2.png" alt="IPv6 链路本地通信"></p><p>注意: 通常情况下，<code>用作链路上其他设备的默认网关的是路由器的LLA而不是GUA</code>。</p><p>设备可以通过两种方式获取 LLA：</p><ul><li><p><strong>静态</strong> - 这意味着设备已手动配置。</p></li><li><p><strong>动态</strong> - 这意味着设备通过使用随机生成的值或使用扩展唯一标识符 (EUI) 方法创建自己的接口 ID，该方法使用客户端 MAC 地址和其他位。</p></li></ul><hr><h2 id="GUA-和-LLA-静态配置"><a href="#GUA-和-LLA-静态配置" class="headerlink" title="GUA 和 LLA 静态配置"></a>GUA 和 LLA 静态配置</h2><h3 id="路由器上的静态-GUA-配置"><a href="#路由器上的静态-GUA-配置" class="headerlink" title="路由器上的静态 GUA 配置"></a>路由器上的静态 GUA 配置</h3><p>如您在上一主题中了解到的，IPv6 GUA与公有 IPv4 地址数量相同。它们具有全局唯一性，可在 IPv6互联网上路由。IPv6 LLA 允许两个启用 IPV6 的设备在同一链路（子网）上相互通信。在路由器上静态配置IPv6 GUA和LLA很容易，可以帮助您创建IPv6网络。本主题教您如何做到这一点！</p><p>在 思科 IOS 中，大多数 IPv6 的配置和验证命令与 IPv4 的相似。在多数情况下，唯一区别是命令中使用ipv6 取代ip 。</p><p>例如，在接口上配置 IPv4 地址的思科IOS 命令是 ip address ip 地址 子网掩码，相比之下，在接口上配置 IPv6 GUA 的命令是 ipv6 address ipv6 地址/前缀长度。</p><p>注意 ipv6-address 和 prefix-length之间没有空格。</p><p>配置示例使用图中的拓扑和下列 IPv6 子网：</p><ul><li><p><strong>2001:db8:acad:1:/64</strong></p></li><li><p><strong>2001:db8:acad:2:/64</strong></p></li><li><p><strong>2001:db8:acad:3:/64</strong></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_13.png" alt="示例拓扑"></p><p>示例列出在 R1 的 G0/0/0、G0/0/1 和 Serial 0/1/0 接口上配置 IPv6 GUA所需的命令。</p><pre><code class="CISCO"># 路由器 R1 上的 IPv6 GUA 配置R1(config)# interface gigabitethernet 0/0/0R1(config-if)# ipv6 address 2001:db8:acad:1::1/64R1(config-if)# no shutdownR1(config-if)# exitR1(config)# interface gigabitethernet 0/0/1R1(config-if)# ipv6 address 2001:db8:acad:2::1/64R1(config-if)# no shutdownR1(config-if)# exitR1(config)# interface serial 0/1/0R1(config-if)# ipv6 address 2001:db8:acad:3::1/64R1(config-if)# no shutdown</code></pre><hr><h3 id="Windows-主机上的静态-GUA-配置"><a href="#Windows-主机上的静态-GUA-配置" class="headerlink" title="Windows 主机上的静态 GUA 配置"></a>Windows 主机上的静态 GUA 配置</h3><p>在主机上手动配置 IPv6 地址与配置 IPv4 地址相似。</p><p>如图中所示，为 PC1 配置的默认网关地址为2001:DB8:ACAD:1::1。该地址是同一网络中 R1 千兆以太网接口的GUA。或者，也可以配置默认网关地址以与千兆以太网接口的LLA相匹配。使用路由器的LLA作为默认网关地址被认为是最佳实践。任一配置都可以。</p><p>该图显示的是Windows Internet Protocol Version 6(TCP/IPv6) 属性窗口。单选按钮“使用下面的 IP 地址”已选择。IPv6 地址是2001:db8:acad:1::1。子网前缀长度为 64。默认网关是2001:db8:acad:1::1。单选按钮“使用下面的 DNS 服务器地址”已选择。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_14.png"><p>与使用 IPv4 一样，在客户端配置静态地址并不能扩展至更大的环境。因此，多数 IPv6 网络的管理员会启用 IPv6 地址的动态分配。</p><p>设备可以通过两种方法自动获取 IPv6 GUA：</p><ul><li><p><strong>无状态地址自动配置 (SLAAC)</strong></p></li><li><p><strong>有状态 DHCPv6</strong></p></li></ul><p>注意: 使用 DHCPv6 或 SLAAC 时，路由器的LLA将自动指定为默认网关地址。</p><hr><h3 id="链路本地单播地址的静态配置"><a href="#链路本地单播地址的静态配置" class="headerlink" title="链路本地单播地址的静态配置"></a>链路本地单播地址的静态配置</h3><p>手动配置LLA可以让您创建的地址便于识别和记忆。一般来说，只需要在路由器上创建可识别的LLA。这样做很有用，因为路由器LLA将被用作默认网关地址并包含在路由通告消息中。</p><p>LLA 可以使用 ipv6 address ipv6-链路本地地址 link-local 命令手动配置。当地址以 fe80 到 febf 范围的十六进制数开头时，link-local参数必须符合该地址。</p><p>该图显示了一个示例拓扑，每个接口上都有LLA。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_15.png" alt="带有 LLA 的拓扑 示例"></p><pre><code class="CISCO"># 路由器 R1 上 LLA 的配置R1(config)# interface gigabitethernet 0/0/0R1(config-if)# ipv6 address fe80::1:1 link-localR1(config-if)# exitR1(config)# interface gigabitethernet 0/0/1R1(config-if)# ipv6 address fe80::2:1 link-localR1(config-if)# exitR1(config)# interface serial 0/1/0R1(config-if)# ipv6 address fe80::3:1 link-localR1(config-if)# exit</code></pre><p>静态配置的LLA用于使它们更易于识别为属于路由器R1。在示例中，路由器 R1 的所有接口都配置了以 fe80::1:n 开头的 LLA 以及唯一的最右侧数字 “n”。“1” 表示路由器 R1。</p><p>遵循与路由器 R1 相同的语法，如果拓扑包含路由器 R2，那么它的三个接口将配置LLA为 fe80::2:1、fe80::2:2和fe80::2:3。</p><p>注意: 只要每个链路上的LLA是唯一的，就可以在每个链路上配置完全相同的LLA。这是因为LLA仅在该链路上具有唯一性。但是，常见的实践是在路由器的每个接口上创建一个不同的 LLA，以便轻松识别路由器和特定接口。</p><hr><h2 id="IPv6-GUA的动态编址"><a href="#IPv6-GUA的动态编址" class="headerlink" title="IPv6 GUA的动态编址"></a>IPv6 GUA的动态编址</h2><h3 id="RS-and-RA-消息"><a href="#RS-and-RA-消息" class="headerlink" title="RS and RA 消息"></a>RS and RA 消息</h3><p>如果您不想静态地配置IPv6 GUAs，也不必担心。大多数设备会动态获取其 IPv6 GUA。本主题说明如何使用路由器通告（RA）和路由器请求（RS）消息来完成此过程。本主题比较技术性，但是当您理解了路由器通告可以使用的三种方法之间的区别，以及创建接口ID的EUI-64进程与随机生成的进程的区别，您将在您的IPv6专业知识上有一个巨大的飞跃!</p><p>对于 GUA，设备通过 Internet 控制消息协议版本 6 (ICMPv6) 消息动态获取地址。IPv6 路由器每 200 秒定期将 ICMPv6 RA 消息发送到网络上所有支持 IPv6 的设备。在响应发送 ICMPv6 路由器请求 (RS) 消息的主机时，也会发送 RA 消息，该消息是对RA消息的请求。这两条消息都显示在图中。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_16.png" alt="ICMPv6 RS 和 RA 消息"></p><p>RA消息位于IPv6路由器以太网接口上。必须为路由器启用 IPv6 路由，这在默认情况下是不启用的。若要将路由器启用为 IPv6 路由器，必须使用 ipv6 unicast-routing 全局配置命令。</p><p>ICMPv6 RA 消息提示设备获取 IPv6 GUA的方式。最终决定取决于设备的操作系统。ICMPv6 RA 消息包括以下：</p><ul><li><p><strong>网络前缀和前缀长度</strong> – 这会告知设备其所属的网络。</p></li><li><p><strong>默认网关</strong> – IPv6 LLA，RA 消息的源 IPv6 地址。</p></li><li><p><strong>DNS 地址和域名</strong> – 这些是DNS 服务器的地址和域名。</p></li></ul><p>RA 消息有三种方法：</p><ul><li>方法 1: SLAAC - “我拥有您需要的一切，包括前缀、前缀长度和默认网关地址。”</li><li>方法 2:SLAAC 和 无状态DHCPv6服务器 - “这是我的信息，但您需要从 无状态DHCPv6 服务器获得其他信息，例如 DNS 地址。”</li><li>方法 3:有状态的 DHCPv6（无SLAAC） - “我可以给您默认网关的地址。您需要向有状态的 DHCPv6 服务器询问您的所有其他信息。”</li></ul><hr><h3 id="方法-1：SLAAC"><a href="#方法-1：SLAAC" class="headerlink" title="方法 1：SLAAC"></a>方法 1：SLAAC</h3><p>SLAAC是一种允许设备在没有DHCPv6服务的情况下创建自己的GUA的方法。使用 SLAAC，设备根据本地路由器的 ICMPv6 路由器通告 (RA) 消息获取必要信息。</p><p>默认情况下，RA 消息会提示接收设备使用 RA 消息中的信息创建其自己的 IPv6 GUA及其他必要信息。DHCPv6 服务器的服务不是必需项。</p><p>SLAAC 是无状态的，也就是说没有中央服务器（例如有状态DHCPv6 服务器）来分配GUA和维持设备及其地址的清单。借助 SLAAC，客户端设备使用 RA 消息中的信息创建其自己的GUA。如图中所示，地址的两部分生成如下：</p><ul><li><p>前缀 -这是在 RA 消息中通告的。</p></li><li><p>接口 ID -使用 EUI-64 流程或通过生成一个随机 64 位数字产生，取决于设备的操作系统。</p></li></ul><blockquote><p>该图显示了局域网，其中路由器正在向 PC 发送 ICMPv6 路由器通告消息。个人电脑的 IPv6 地址为 2001:db8:acad:1:fc99:47ff:fe75:cee0/64。这是一个图形，表示在RA消息中接收到的网络前缀是2001:db8:acad:1:，由客户端设备EUI-64或随机64位数字创建的接口ID是fc99:47ff:fe75:cee0。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_17.png" alt="ICMPv6 RS 和 RA 消息"></p><hr><h3 id="方法-2：SLAAC-和无状态-DHCPv6"><a href="#方法-2：SLAAC-和无状态-DHCPv6" class="headerlink" title="方法 2：SLAAC 和无状态 DHCPv6"></a>方法 2：SLAAC 和无状态 DHCPv6</h3><p>路由器的接口可配置为使用 SLAAC 和无状态 DHCPv6 或仅使用有状态 DHCPv6 发送路由器通告。</p><p>如图所示，使用此方法，RA 消息建议设备使用以下内容：</p><ul><li><p>SLAAC创建自己的IPv6 GUA。</p></li><li><p>路由器LLA，是RA源IPv6地址，作为默认网关地址。</p></li><li><p>使用无状态 DHCPv6 服务器获取其他信息，例如 DNS 服务器地址和域名。</p></li></ul><p>注意: 使用无状态 DHCPv6 服务器分配 DNS 服务器地址和域名。它不分配 GUA。</p><blockquote><p>该图显示了局域网和一台正在向路由器发送RS消息(标记为#1)的PC机。路由器正在发送作为回复的RA 消息（标记为#2）。PC还向无状态的 DHCPv6 服务器发送一条请求消息（标记为#3）。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_18.png" alt="ICMPv6 RS 和 RA 消息"></p><hr><h3 id="方法-3：有状态的DHCPv6"><a href="#方法-3：有状态的DHCPv6" class="headerlink" title="方法 3：有状态的DHCPv6"></a>方法 3：有状态的DHCPv6</h3><p>路由器接口可以配置为仅使用有状态的DHCPv6发送RA。</p><p>有状态 DHCPv6 与 IPv4 的 DHCP 相似。设备可以从有状态 DHCPv6 服务器自动接收编址信息，包括GUA、前缀长度和 DNS 服务器地址。</p><p>如图所示，使用此方法，RA 消息建议设备使用以下内容：</p><ul><li><p>路由器LLA，是RA源IPv6地址，作为默认网关地址。</p></li><li><p>使用有状态 DHCPv6 服务器获取GUA、DNS 服务器地址、域名和其他必要信息。</p></li></ul><blockquote><p>该图显示了局域网和一台正在向路由器发送消息(标记为#1)的PC机。路由器正在向PC发送消息（标记为#2）。PC还向服务器发送了一条消息（标记为#3）。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_19.png" alt="ICMPv6 RS 和 RA 消息"></p><p>使用有状态 DHCPv6 服务器分配并维持哪台设备接收哪个 IPv6 地址的清单。IPv4 的 DHCP 是有状态的。</p><p>注意: 默认网关地址仅可从 RA 消息中动态获取。无状态或有状态 DHCPv6 服务器均不提供默认网关地址。</p><hr><h3 id="EUI-64-流程和随机生成"><a href="#EUI-64-流程和随机生成" class="headerlink" title="EUI-64 流程和随机生成"></a>EUI-64 流程和随机生成</h3><p>当 RA 消息为 SLAAC 或 SLAAC 和无状态 DHCPv6 时，客户端必须生成自己的接口 ID。客户端从 RA 消息中获知地址的前缀部分，但必须创建自己的接口 ID。如图所示，接口 ID 可使用 EUI-64 流程或随机生成的 64 位数字创建。</p><blockquote><p>该图显示了路由器正在向 PC 发送 ICMPv6 路由器通告消息（标记为#1）。在标记为＃2的步骤中显示了PC，它从RA消息中创建其/ 64前缀，并使用EUI-64或64位随机数创建其接口ID。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_20.png" alt="ICMPv6 RS 和 RA 消息"></p><hr><h3 id="EUI-64-流程"><a href="#EUI-64-流程" class="headerlink" title="EUI-64 流程"></a>EUI-64 流程</h3><p>IEEE 定义了扩展唯一标识符 (EUI) 或修改的 EUI-64 流程。该流程使用客户端的 48 位以太网 MAC 地址，并在该 48 位 MAC 地址的中间插入另外 16 位来创建 64 位接口 ID。</p><p>以太网 MAC 地址一般使用十六进制表示，由两部分组成：</p><ul><li><p><strong>组织唯一标识符 (OUI)</strong> - OUI 为 IEEE 分配的 24 位（6 个十六进制数字）厂商代码。</p></li><li><p><strong>设备标识符</strong> - 设备标识符是通用 OUI 内的唯一 24 位（6 个十六进制数字）值。</p></li></ul><p>EUI-64 接口 ID 以二进制表示，共分三个部分：</p><ul><li><p>客户端 MAC 地址的 24 位 OUI，但是第 7 位（通用/本地 (U/L) 位）颠倒。这意味着，如果第 7 位是 0，则它会变为 1，反之亦然。</p></li><li><p>插入的 16 位值 fffe（十六进制）。</p></li><li><p>客户端 MAC 地址的 24 位设备标识符。</p></li></ul><p>该图是 EUI-64 流程图，它使用 R1 千兆以太网 MAC 地址，即 fc99:4775:cee0。</p><blockquote><p>该图显示了 EUI-64 流程中的步骤。在图的顶部是MAC地址fc:99:47:75:ce:e0。第1步：拆分 MAC 地址，OUI fc:99:47的前24位二进制是1111 1100 1001 1001 0100 0111。设备的最后24位标识为75:ce:e0，二进制是1111 0101 1100 1110 1110 0000。第2步：插入ffee二进制表示变为1111 1100 1001 1001 0100 0111 1111 1111 1111 1110 1110 1111 0101 1100 1110 1110 0000。第3步：颠倒u/l位。从左边开始的第7位从0变成了1。二进制地址现在是1111 1110 1001 1001 0100 0111 1111 1111 1111 1110 1110 1111 0101 1100 1110 1110 0000。修改后的十六进制记法的EUI-64接口ID现在是fe:99:47:ff:fe:75:ce:e0。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_21.png"><p><strong>ipconfig</strong> 命令的示例输出显示了使用 SLAAC 和 EUI-64 流程动态创建的 IPv6 GUA。识别地址可能是使用EUI-64创建的一个简单方法是位于接口ID中间的 <strong>fffe</strong>。</p><p>EUI-64 优势在于可以使用以太网 MAC 地址确定接口 ID。这也允许网络管理员使用唯一 MAC 地址轻松跟踪终端设备的 IPv6 地址。然而，这引起了许多用户的隐私担忧，他们担心自己的数据包可能会被追踪到实际的物理计算机。出于这些顾虑，可以转而使用随机生成的接口 ID。</p><pre><code class="bash"># EUI-64 生成的接口 IDC:\&gt; ipconfigWindows IP ConfigurationEthernet adapter Local Area Connection:Connection-specific DNS Suffix . :IPv6 Address. . . . . . . . . . . : 2001:db8:acad:1:fc99:47ff:fe75:cee0Link-local IPv6 Address . . . . . : fe80::fc99:47ff:fe75:cee0Default Gateway . . . . . . . . . : fe80::1C:\ &gt;</code></pre><hr><h3 id="随机生成的接口-ID"><a href="#随机生成的接口-ID" class="headerlink" title="随机生成的接口 ID"></a>随机生成的接口 ID</h3><p>根据操作系统，设备可以使用随机生成的接口 ID，而不使用 MAC 地址和 EUI-64 流程。从 Windows Vista 开始，Windows 使用随机生成的接口 ID，而不是 EUI-64 创建的接口 ID。Windows XP 和之前的 Windows 操作系统均使用 EUI-64。</p><p>如图所示，接口 ID 创建后（无论是使用 EUI-64 流程还是通过随机生成），它都可以在 RA 消息中结合 IPv6 前缀来创建GUA。</p><pre><code class="bash"># 随机生成的 64 位接口 IDC:\&gt; ipconfigWindows IP ConfigurationEthernet adapter Local Area Connection:   Connection-specific DNS Suffix  . :   IPv6 Address. . . . . . . . . . . : 2001:db8:acad:1:50a5:8a35:a5bb:66e1   Link-local IPv6 Address . . . . . : fe80::50a5:8a35:a5bb:66e1   Default Gateway . . . . . . . . . : fe80::1C:\&gt;</code></pre><p>注意: 为确保任何 IPv6 单播地址的唯一性，客户端可以使用重复地址检测 (DAD) 流程。这与 ARP 请求其地址的流程相似。如该请求没有响应，则地址是唯一的。</p><hr><h2 id="IPv6-LLA的动态编址"><a href="#IPv6-LLA的动态编址" class="headerlink" title="IPv6 LLA的动态编址"></a>IPv6 LLA的动态编址</h2><h3 id="动态-LLA"><a href="#动态-LLA" class="headerlink" title="动态 LLA"></a>动态 LLA</h3><p>所有 IPv6 设备都必须有 IPv6 LLA。与 IPv6 GUA一样，您也可以动态创建 LLA。无论您如何创建LLA(和GUA)，重要的是要验证所有IPv6地址配置。本主题介绍动态生成的 LLA和 IPv6 配置验证。</p><p>该图显示了如何使用fe80::/10 前缀和通过 EUI-64 流程或随机生成的 64 位数字创建的接口 ID 动态创建LLA。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_23.png"><hr><h3 id="Windows上的动态LLA"><a href="#Windows上的动态LLA" class="headerlink" title="Windows上的动态LLA"></a>Windows上的动态LLA</h3><p>操作系统，如Windows，通常会对SLAAC创建的GUA和动态分配的LLA使用相同的方法。请参阅之前显示的以下示例中突出显示的区域。</p><blockquote><p>EUI-64 生成的接口 ID</p></blockquote><pre><code class="bash">C:\&gt; ipconfigWindows IP ConfigurationEthernet adapter Local Area Connection:Connection-specific DNS Suffix . :IPv6 Address. . . . . . . . . . . : 2001:db8:acad:1:fc99:47ff:fe75:cee0Link-local IPv6 Address . . . . . : fe80::fc99:47ff:fe75:cee0Default Gateway . . . . . . . . . : fe80::1C:\&gt;</code></pre><blockquote><p>随机生成的 64 位接口 ID</p></blockquote><pre><code class="bash">C:\&gt; ipconfigWindows IP ConfigurationEthernet adapter Local Area Connection:   Connection-specific DNS Suffix  . :   IPv6 Address. . . . . . . . . . . : 2001:db8:acad:1:50a5:8a35:a5bb:66e1   Link-local IPv6 Address . . . . . : fe80::50a5:8a35:a5bb:66e1   Default Gateway . . . . . . . . . : fe80::1C:\&gt;</code></pre><hr><h3 id="思科路由器上的动态LLA"><a href="#思科路由器上的动态LLA" class="headerlink" title="思科路由器上的动态LLA"></a>思科路由器上的动态LLA</h3><p>当为接口分配GUA时，思科路由器会自动创建 IPv6 LLA。默认情况下，思科 IOS 路由器使用 EUI-64 为 IPv6 接口上的所有LLA生成接口 ID。对于串行接口，路由器会使用以太网接口的 MAC 地址。回想一下，LLA在该链路或网络上必须具有唯一性。但是，使用动态分配的LLA的缺点在于其接口 ID 较长，因此很难识别并记住分配的地址。示例显示了路由器 R1 千兆以太网0/0/0 接口的 MAC 地址。该地址用于在同一接口上动态创建LLA，也用于串行0/1/0接口。</p><p>为了更容易在路由器上识别和记忆这些地址，通常要在路由器上静态配置 IPv6 LLA。</p><p>在路由器 R1 上使用 EUI-64 的### IPv6 LLA</p><pre><code class="CISCO">R1# show interface gigabitEthernet 0/0/0GigabitEthernet0/0/0 is up, line protocol is up  Hardware is ISR4221-2x1GE, address is 7079.b392.3640 (bia 7079.b392.3640)(Output omitted)R1# show ipv6 interface briefGigabitEthernet0/0/0   [up/up]    FE80::7279:B3FF:FE92:3640    2001:DB8:ACAD:1::1GigabitEthernet0/0/1   [up/up]    FE80::7279:B3FF:FE92:3641    2001:DB8:ACAD:2::1Serial0/1/0            [up/up]    FE80::7279:B3FF:FE92:3640    2001:DB8:ACAD:3::1Serial0/1/1            [down/down]    unassignedR1#</code></pre><hr><h3 id="验证-IPv6-地址配置"><a href="#验证-IPv6-地址配置" class="headerlink" title="验证 IPv6 地址配置"></a>验证 IPv6 地址配置</h3><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_25.png" alt="示例拓扑"></p><blockquote><p>show ipv6 interface brief</p></blockquote><p><strong>show ipv6 interface brief</strong>命令会显示以太网接口的 MAC 地址。EUI-64 使用此 MAC 地址生成LLA的接口 ID。此外，<strong>show ipv6 interface brief</strong>命令用于显示各个接口的缩略输出。与接口位于同一行的 [up/up] 输出指示第 1 层/第 2 层接口状态。这与等效的 IPv4 命令的状态和协议列相同。</p><p>注意，每个接口有两个 IPv6 地址。每个接口的第二个地址是已配置的 GUA。第一个地址以 fe80 开头，是接口的链路本地单播地址。回想一下，分配GUA后，LLA会自动添加到接口。</p><p>另请注意，R1 的 Serial 0/0/0 本地链路地址与其 GigabitEthernet 0/0 接口相同。串行接口没有以太网 MAC 地址，因此思科 IOS 使用第一个可用的以太网接口的 MAC 地址。这样可行，因为本地链路接口仅在该链路上具有唯一性。</p><pre><code class="CISCO"># 路由器R1执行 show ipv6 interface brief 命令R1# show ipv6 interface briefGigabitEthernet0/0/0 [up/up]FE80::1:12001:DB8:ACAD:1::1GigabitEthernet0/0/1 [up/up]FE80::1:22001:DB8:ACAD:2::1Serial0/1/0 [up/up]FE80::1:32001:DB8:ACAD:3::1Serial0/1/1 [down/down]unassignedR1#</code></pre><blockquote><p>show ipv6 route</p></blockquote><p><strong>show ipv6 route</strong> 命令可用于检验 IPv6 网络和特定 IPv6 接口地址已添加到 IPv6 路由表中。该 <strong>show ipv6 route</strong> 命令将仅显示 IPv6 网络，而不显示 IPv4 网络。</p><p>在路由表中，路由旁边的 <strong>C</strong> 表示这是一个直连网络。当路由器接口配置了GUA并处于“up/up”状态时，IPv6 前缀和前缀长度会作为直连路由添加至 IPv6 路由表。</p><p>注意: <strong>L</strong>表示本地路由，即为接口分配的特定 IPv6 地址。这不是一个 LLA。由于LLA不是可路由地址，因此它们不包括在路由表中。</p><p>接口上配置的 IPv6 GUA也作为本地路由添加到路由表中。本地路由具有 /128 前缀。路由表使用本地路由来有效处理目的地址为路由器接口地址的数据包。</p><pre><code class="CISCO"># 路由器R1执行 show ipv6 route 命令R1# show ipv6 routeIPv6 Routing Table - default - 7 entriesCodes: C - Connected, L - Local, S - Static, U - Per-user Static routeC 2001:DB8:ACAD:1::/64 [0/0]via GigabitEthernet0/0/0, directly connectedL 2001:DB8:ACAD:1::1/128 [0/0]via GigabitEthernet0/0/0, receiveC 2001:DB8:ACAD:2::/64 [0/0]via GigabitEthernet0/0/1, directly connectedL 2001:DB8:ACAD:2::1/128 [0/0]via GigabitEthernet0/0/1, receiveC 2001:DB8:ACAD:3::/64 [0/0]via Serial0/1/0, directly connectedL 2001:DB8:ACAD:3::1/128 [0/0]via Serial0/1/0, receiveL FF00::/8 [0/0]via Null0, receiveR1#</code></pre><blockquote><p>ping</p></blockquote><p>IPv6 的 <strong>ping</strong> 命令和 IPv4 中这条命令的用法相同，只不过使用的是 IPv6 地址。如示例中所示，命令的作用是验证 R1 和 PC1 之间的第 3 层连通性。从路由器对LLA实施 ping 命令时，思科 IOS 会提示用户确认出接口。由于目的LLA可以在一个或多个链路或网络上使用，路由器需要知道要将 ping 发送到哪个接口。</p><pre><code class="CISCO"># 路由器R1执行 ping 命令R1# ping 2001:db8:acad:1::10Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 2001:DB8:ACAD:1::10, timeout is 2 seconds:!!!!!Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 msR1#</code></pre><hr><h2 id="IPv6-组播地址"><a href="#IPv6-组播地址" class="headerlink" title="IPv6 组播地址"></a>IPv6 组播地址</h2><h3 id="分配的-IPv6-组播地址"><a href="#分配的-IPv6-组播地址" class="headerlink" title="分配的 IPv6 组播地址"></a>分配的 IPv6 组播地址</h3><p>IPv6 组播地址类似于 IPv4 组播地址。回想一下，组播地址用于发送单个数据包到一个或多个目标（组播组）。IPv6 组播地址的前缀为ff00::/8。</p><blockquote><p>注意: 组播地址仅可用作目的地址，不能用作源地址。</p></blockquote><p>IPv6 组播地址分为两种类型：</p><ul><li><p>知名组播地址</p></li><li><p>请求节点组播地址</p></li></ul><hr><h3 id="知名-IPv6-组播地址"><a href="#知名-IPv6-组播地址" class="headerlink" title="知名 IPv6 组播地址"></a>知名 IPv6 组播地址</h3><p>已分配的知名IPv6 组播地址。分配的组播地址是为预先定义的设备组保留的组播地址。分配的组播地址是用于到达运行通用协议或服务的设备组的单个地址。分配的组播地址用在特定的协议环境，例如 DHCPv6。</p><p>这些是两种常见的 IPv6 分配组播组：</p><ul><li><p><strong>ff02:全节点组播组</strong> - 这是一个包含所有支持 IPv6 的设备的组播组。发送到该组的数据包由该链路或网络上的所有 IPv6 接口接收和处理。这与 IPv4 中的广播地址具有相同的效果。图中显示使用全节点组播地址进行通信的示例。IPv6 路由器将ICMPv6 RA 消息发送给全节点组播组。</p></li><li><p><strong>ff02:全路由器组播组</strong> - 这是所有IPv6路由器加入的组播组。当在IPv6路由器全局模式下启用ipv6 unicast-routing命令后，该路由器即成为该组的成员。发送到该组的数据包由该链路或网络上的所有 IPv6 路由器接收和处理。</p></li></ul><blockquote><p>该图显示了两台IPv6 地址为2001:DB8: ACAD1:10/64 和 2001: DB8: ACAD1:20/64的PC、一台 IPv6 地址为2001: db8: ACAD1:8/64的服务器和一台IPv6 地址为2001:db8:acad:1::9/64的打印机连接到交换机，交换机连接到路由器。上图显示了fe80::1的源IPv6地址和ff02::1的目的IPv6地址。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_27.png" alt="IPv6 全节点组播：RA消息"></p><hr><h3 id="请求节点-IPv6-组播地址"><a href="#请求节点-IPv6-组播地址" class="headerlink" title="请求节点 IPv6 组播地址"></a>请求节点 IPv6 组播地址</h3><p>请求节点组播地址类似于全节点组播地址。请求节点组播地址的优势在于它被映射到特殊的以太网组播地址。这使得以太网网卡可以通过检查目的 MAC 地址过滤该帧，而不是将它发送给 IPv6 流程来判断该设备是否是 IPv6 数据包的既定目标。</p><blockquote><p>该图显示了三台PC正在接收来自路由器的消息。每台PC都有以下信息性文本：我的以太网网卡确定此组播不是给我的。上图表明，目的 MAC 地址是组播，目的 IPv6 地址是请求节点组播。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_28.png"><hr><h2 id="IPv6-网络的子网"><a href="#IPv6-网络的子网" class="headerlink" title="IPv6 网络的子网"></a>IPv6 网络的子网</h2><h3 id="使用子网-ID-划分子网"><a href="#使用子网-ID-划分子网" class="headerlink" title="使用子网 ID 划分子网"></a>使用子网 ID 划分子网</h3><p>回想一下，使用IPv4时，我们必须从主机部分借用位来创建子网。这是因为对IPv4来说，子网划分是事后才想到的。但是，IPv6 的设计考虑到了子网划分。IPv6 GUA中的一个单独的子网ID字段用于创建子网。如图所示，子网ID字段是全局路由前缀和接口ID之间的区域。</p><blockquote><p>该图显示了 GUA 的各个部分。首先是48位全局路由前缀，然后是16位子网ID，最后是64位接口ID。图下的文字显示：一个/ 48路由前缀 + 16 位子网 ID = /64前缀</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_29.png" alt="带有 16 位子网 ID 的 GUA"></p><p>128 位地址的好处在是，它可以为每个网络支持足够多的子网并为每个子网支持足够多的主机。地址保留不是问题。例如，如果全局路由前缀是a /48，并且使用一个典型的64位接口ID，这将创建一个16位子网ID:</p><ul><li><p><strong>16 位子网 ID</strong> - 创建多达 65,536 个子网。</p></li><li><p><strong>64 位子网 ID</strong> - 每个子网支持多达 1800亿亿个主机 IPv6 地址（即 18,000,000,000,000,000,000）。</p></li></ul><p>注意: 也可以将子网划分为 64 位接口 ID（或主机部分），但是很少这么要求。</p><p>IPv6 子网划分也比 IPv4 容易实施，因为不需要转换为二进制。要确定下一个可用子网，只需要将十六进制数相加。</p><hr><h3 id="IPv6-子网划分示例"><a href="#IPv6-子网划分示例" class="headerlink" title="IPv6 子网划分示例"></a>IPv6 子网划分示例</h3><p>例如，假设一个组织分配了 2001:db8:acad::/48 全局路由前缀，并采用 16 位子网 ID。这将允许组织创建65,536个 /64 子网，如图所示。注意，所有子网的全局路由前缀是相同的。只为每个子网递增子网 ID 的十六位字节数（以十六进制形式）。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_30.png" alt="使用16位子网 ID 划分子网"></p><hr><h3 id="IPv6-子网分配"><a href="#IPv6-子网分配" class="headerlink" title="IPv6 子网分配"></a>IPv6 子网分配</h3><p>由于有 65,536 个子网可供选择，网络管理员的任务就变为设计一个逻辑方案来分配网络地址。</p><p>如图所示，示例拓扑需要五个子网，每个局域网一个，以及R1和R2之间的串行链路一个。与IPv4的示例不同，IPv6的串行链路子网将具有与局域网相同的前缀长度。虽然这可能会“浪费”地址，但是使用 IPv6 时地址保留并不是问题。</p><blockquote><p>该图显示了四台PC（PC1、PC2、PC3 和 PC4），每台PC的接口 ID 为::10。每台PC 都连接到一台交换机。<br>PC1位于网络2001:db8:acad:1::/64中，通过交换机连接到路由器1的G0/0/0接口，接口ID::1。<br>PC2位于网络2001:db8:acad:2::/64中，通过交换机连接到路由器1的G0/0/1接口，接口ID::1。<br>PC3位于网络2001:db8:acad:4::/64中，通过交换机连接到路由器2的G0/0/0接口，接口ID::1。<br>PC4位于网络2001:db8:acad:5::/64中，通过交换机连接到路由器2的G0/0/1接口，接口ID::1。</p><blockquote><p>在2001:db8:acad:3::/64网络中，路由器1和2通过它们的S0/1/0接口进行连接，R1的接口ID为::1,R2的接口ID为::2。</p></blockquote></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_31_1.png"><p>在本示例中 5 个 IPv6 子网的分配将使用 0001 到 0005 的子网 ID 字段。每个 /64 子网提供的地址都远多于所需要的地址。</p><blockquote><p>该图显示了地址块的子网:2001:db8:acad::/48。<br>这些子网分别是：<br>2001:db8:acad:0000::/64，<br>2001:db8:acad:0001::/64，<br>2001:db8:acad:0002::/64，<br>2001:db8:acad:0003::/64，<br>2001:db8:acad:0004::/64，<br>2001:db8:acad:0005::/64，<br>2001:db8:acad:0006::/64，<br>2001:db8:acad:0007::/64，<br>2001:db8:acad:0008::/64，<br>2001:db8:acad:ffff::/64，</p><blockquote><p>注释显示：从65,536个可用子网中分配了5个子网，并表明分配的5个子网是：<br>2001:db8:acad:0001::/64，<br>2001:db8:acad:0002::/64，<br>2001:db8:acad:0003::/64，<br>2001:db8:acad:0004::/64，<br>2001:db8:acad:0005::/64。</p></blockquote></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/10_31_2.png"><hr><h3 id="配置了-IPv6-子网的路由器"><a href="#配置了-IPv6-子网的路由器" class="headerlink" title="配置了 IPv6 子网的路由器"></a>配置了 IPv6 子网的路由器</h3><p>与配置 IPv4 类似，示例显示了每个路由器接口都已经配置到不同的 IPv6 子网中。</p><pre><code class="CISCO"># 路由器 R1 上的IPv6 地址配置R1(config)# interface gigabitethernet 0/0/0R1(config-if)# ipv6 address 2001:db8:acad:1::1/64R1(config-if)# no shutdownR1(config-if)# exitR1(config)# interface gigabitethernet 0/0/1R1(config-if)# ipv6 address 2001:db8:acad:2::1/64R1(config-if)# no shutdownR1(config-if)# exitR1(config)# interface serial 0/1/0R1(config-if)# ipv6 address 2001:db8:acad:3::1/64R1(config-if)# no shutdown</code></pre><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>IPv4 的问题</li></ul><blockquote><p>理论上，IPv4 最多有 43 亿个地址。私有地址和NAT一起帮助减缓了IPv4地址空间的消耗。考虑到互联网用户的不断增加、有限的 IPv4 地址空间、NAT 问题和物联网等问题，是时候开始向 IPv6 过渡了。在不久的将来，IPv4和IPv6都将共存，并且过渡将需要几年的时间。IETF 已经创建了各种协议和工具来协助网络管理员将网络迁移到 IPv6。迁移技术可以分为三类：双堆栈、隧道和转换。</p></blockquote><ul><li>IPv6 地址表示方法</li></ul><blockquote><p>IPv6 地址长度为 128 位，写作十六进制值字符串。每 4 位以一个十六进制数字表示；共 32 个十六进制值。书写 IPv6 地址的首选格式为 x: x: x: x: x: x: x: x，每个“x”均包括四个十六进制值。例如：2001:0db8:0000:1111:0000:0000:0000:0200。有两条规则可帮助减少表示一个 IPv6 地址所需数字的数目。第一条有助于缩短 IPv6 地址记法的规则是省略十六进制数中的所有前导 0（零）。例如：2001:db8:0:1111:0:0:0:200。第二条有助于缩短 IPv6 地址记法的规则是使用双冒号 (::) 替换任何由一个或多个全由 0 组成的16 位十六进制数组成的连续字符串。例如：2001:db8:0:1111::200。</p></blockquote><ul><li>IPv6 地址类型</li></ul><blockquote><p>IPv6 地址分为三种类型：单播、组播和任播。IPv6 不使用点分十进制子网掩码记法。与IPv4一样，前缀长度以斜线记法表示，用于表示 IPv6 地址的网络部分。IPv6 单播地址用于唯一标识支持 IPv6 的设备上的接口。IPv6地址通常有两个单播地址:GUA和LLA。IPv6 唯一本地地址具有以下用途：它们用于站点内或数量有限的站点之间的本地编址，它们可用于永远不需要访问其他网络的设备，并且它们不会全局路由或转换为全局 IPv6 地址。IPv6 全局单播地址 (GUA) 具有全局唯一性，可在 IPv6互联网上路由。这些地址相当于公有 IPv4 地址。GUA 有三个部分：全局路由前缀、子网 ID 和接口 ID。IPv6 链路本地地址(LLA)允许设备与同一链路上支持 IPv6 的其他设备通信，并且只能在该链路（子网）上通信。设备可以静态或动态地获取LLA。</p></blockquote><ul><li>GUA 和 LLA 静态配置</li></ul><blockquote><p>在接口上配置 IPv4 地址的思科 IOS 命令是ip address IP 地址 子网掩码。相比之下，在接口上配置 IPv6 GUA 的命令是 ipv6 address ipv6 地址/前缀长度 。与使用 IPv4 一样，在客户端配置静态地址并不能扩展至更大的环境。因此，多数 IPv6 网络的管理员会启用 IPv6 地址的动态分配。手动配置LLA可以让您创建的地址便于识别和记忆。一般来说，只需要在路由器上创建可识别的LLA。LCA 可以使用 ipv6 address ipv6-链路本地地址 link-local 命令手动配置。</p></blockquote><ul><li>IPv6 GUA的动态编址</li></ul><blockquote><p>设备通过ICMPv6消息来动态地获取GUA。IPv6 路由器每 200 秒定期将 ICMPv6 RA 消息发送到网络上所有支持 IPv6 的设备。在响应发送 ICMPv6 路由器请求 (RS) 消息的主机时，也会发送 RA 消息，该消息是对RA消息的请求。ICMPv6 RA消息包括:网络前缀和前缀长度、默认网关地址、DNS地址和域名。RA 消息有三种方法：SLAC、带无状态 DHCPv6 服务器的 SLAAC 和有状态的 DHCPv6（无 SLAAC）。借助 SLAAC，客户端设备使用 RA 消息中的信息创建其自己的GUA，因为该消息包含前缀和接口ID。对于带有无状态DHCPv6的SLAAC, RA消息建议设备使用SLAAC创建自己的IPv6 GUA，使用路由器LLA作为默认网关地址，并使用无状态DHCPv6服务器获取其他必要的信息。对于有状态的DHCPv6, RA建议设备使用路由器LLA作为默认网关地址，使用有状态的DHCPv6服务器获得GUA、DNS服务器地址、域名和所有其他必要的信息。接口 ID 可使用 EUI-64 流程或随机生成的 64 位数字创建。EUI流程使用客户端的 48 位以太网 MAC 地址，并在该 MAC 地址的中间插入另外 16 位来创建 64 位接口 ID。根据操作系统，设备可以使用随机生成的接口 ID。</p></blockquote><ul><li>IPv6 LLA的动态编址</li></ul><blockquote><p>所有 IPv6 设备都必须有 IPv6 LLA。LLA 可以手动配置或动态创建。操作系统，如Windows，通常会对SLAAC创建的GUA和动态分配的LLA使用相同的方法。当为接口分配GUA时，思科路由器会自动创建 IPv6 LLA。默认情况下，思科 IOS 路由器使用 EUI-64 为 IPv6 接口上的所有LLA生成接口 ID。对于串行接口，路由器会使用以太网接口的 MAC 地址。为了更容易在路由器上识别和记忆这些地址，通常要在路由器上静态配置 IPv6 LLA。要验证 IPv6 地址配置，请使用以下三个命令：</p></blockquote><pre><code class="bash">show ipv6 interface briefshow ipv6 routeping</code></pre><ul><li>IPv6 组播地址</li></ul><blockquote><p>IPv6有两种类型的组播地址：知名组播地址和请求节点组播地址。分配的组播地址是为预先定义的设备组保留的组播地址。已分配的知名组播地址。两个通用 IPv6 分配的组播组是：ff02::1 全节点组播组和 ff02::2 全路由器组播组。请求节点组播地址类似于全节点组播地址。请求节点组播地址的优势在于它被映射到特殊的以太网组播地址。</p></blockquote><ul><li>IPv6 网络的子网</li></ul><blockquote><p>IPv6 的设计考虑到了子网划分。IPv6 GUA中的一个单独的子网ID字段用于创建子网。子网ID字段是全局路由前缀和接口ID之间的区域。128 位地址的好处在于，它可以为每个网络的每个子网支持足够多的子网和主机。地址保留不是问题。例如，如果全局路由前缀是a /48，并且使用一个典型的64位接口ID，这将创建一个16位子网ID:</p></blockquote><ol><li>16 位子网 ID - 创建多达 65,536 个子网。</li><li>64 位子网 ID - 每个子网支持多达 1800亿亿个主机 IPv6 地址（即 18,000,000,000,000,000,000）。</li></ol><blockquote><p>由于有 65,536 个子网可供选择，网络管理员的任务就变为设计一个逻辑方案来分配网络地址。使用 IPv6 时地址保留并不是问题。与配置 IPv4 类似，每个路由器接口都可以配置到不同的 IPv6 子网中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理 • IPv4 编址</title>
      <link href="School-Computer-Network-Technology-IPv4/"/>
      <url>School-Computer-Network-Technology-IPv4/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇是对<a href="https://phoenixnest.github.io/Notes-Computer-Network-Technology/">计算机网络原理</a>一文中的<a href="https://phoenixnest.github.io/School-Computer-Network-Technology/#IPv4%E7%BC%96%E5%9D%80">IPv4 编址部分</a>的详细介绍。<br>所用教学平台：<a href="%22https://cn.netacad.com/%22">Cisco Networking Academy</a></p></blockquote><hr><h2 id="IPv4-编址"><a href="#IPv4-编址" class="headerlink" title="IPv4 编址"></a>IPv4 编址</h2><h3 id="IPv4-地址结构-网络部分和主机部分"><a href="#IPv4-地址结构-网络部分和主机部分" class="headerlink" title="IPv4 地址结构 - 网络部分和主机部分"></a>IPv4 地址结构 - 网络部分和主机部分</h3><p>IPv4 地址为32位分层地址，由网络部分和主机部分两个部分组成。在确定网络部分和主机部分时，必须先查看 32 位数据流，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_1.png" alt="IPv4 地址"></p><blockquote><p>对于同一网络中的所有设备，<code>地址的网络部分中的位必须完全相同</code>。<code>地址的主机部分中的位必须唯一，这方便识别网络中的特定主机</code>。如果两台主机在 32 位数据流中的指定网络部分有相同的位模式，则这两台主机位于同一网络。</p></blockquote><p>但是，主机如何知道 32 位数据流中的哪一部分用于标识网络，哪一部分用于标识主机呢？这就是子网掩码的作用。</p><hr><h3 id="IPv4-地址结构-子网掩码"><a href="#IPv4-地址结构-子网掩码" class="headerlink" title="IPv4 地址结构 - 子网掩码"></a>IPv4 地址结构 - 子网掩码</h3><p>如图所示，为主机分配 IPv4 地址需要以下内容：</p><ul><li><p>IPv4 地址 - 这是主机的唯一 IPv4 地址。</p></li><li><p>子网掩码\ - 用于标识 IPv4 地址的网络部分/主机部分。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_2_1.png" alt="Windows 计算机上的 IPv4 配置"></p><p>注意: 访问远程网络需要一个默认网关IPv4地址，<code>将域名转换为IPv4地址需要DNS服务器的IPv4地址</code>。</p><blockquote><p>IPv4子网掩码用于将地址的网络部分与IPv4地址的主机部分区分开来。当把 IPv4 地址分配给一台设备时，该设备使用子网掩码来确定设备的网络地址。网络地址代表同一网络中的所有设备的地址。</p></blockquote><p>下图以点分十进制和二进制格式显示了32位子网掩码。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_2_2.png" alt="子网掩码"></p><p>请注意子网掩码是一个1位连续序列，后面跟有一个0位连续序列组成的序列。</p><p>为了确定 IPv4 地址的网络部分和主机部分，要将子网掩码与 IPv4 地址进行从左到右逐位比较（如图所示）。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_2_3.png" alt="子网掩码"></p><p>注意，子网掩码实际上不包含 IPv4 地址的网络部分或主机部分，它仅通知计算机在哪里查找IPv4地址的网络部分和主机部分。</p><p>用于确定网络部分和主机部分的实际流程叫做 AND 运算。</p><hr><h3 id="前缀长度"><a href="#前缀长度" class="headerlink" title="前缀长度"></a>前缀长度</h3><p>使用点分十进制子网掩码地址表示网络地址和主机地址会变得很麻烦。幸运的是，还有另一种识别子网掩码的方法，称为前缀长度。</p><blockquote><p><code>前缀长度是子网掩码中设置为 1 的位数</code>。使用“斜线记法”写入，即“/”紧跟设置为 1 的位数。借此计算子网掩码中的位数，并在前面加斜线表示。</p></blockquote><p>请参阅下表示例：第一列中列出了主机地址使用的各种子网掩码。第二列显示转换的 32 位二进制地址。最后一列显示最终的前缀长度。</p><table><thead><tr><th align="center">子网掩码</th><th align="center">32 位地址</th><th align="center">前缀长度</th></tr></thead><tbody><tr><td align="center"><strong>255</strong>.0.0.0</td><td align="center"><strong>11111111</strong>.00000000.00000000.00000000</td><td align="center">/<strong>8</strong></td></tr><tr><td align="center"><strong>255.255</strong>.0.0</td><td align="center"><strong>11111111.11111111</strong>.00000000.00000000</td><td align="center">/<strong>16</strong></td></tr><tr><td align="center"><strong>255.255.255</strong>.0</td><td align="center"><strong>11111111.11111111.11111111</strong>.00000000</td><td align="center">/<strong>24</strong></td></tr><tr><td align="center"><strong>255.255.255.128</strong></td><td align="center"><strong>11111111.11111111.11111111</strong>.10000000</td><td align="center">/<strong>25</strong></td></tr><tr><td align="center"><strong>255.255.255.192</strong></td><td align="center"><strong>11111111.11111111.11111111.11</strong>000000</td><td align="center">/<strong>26</strong></td></tr><tr><td align="center"><strong>255.255.255.224</strong></td><td align="center"><strong>11111111.11111111.11111111.111</strong>00000</td><td align="center">/<strong>27</strong></td></tr><tr><td align="center"><strong>255.255.255.240</strong></td><td align="center"><strong>11111111.11111111.11111111.1111</strong>0000</td><td align="center">/<strong>28</strong></td></tr><tr><td align="center"><strong>255.255.255.248</strong></td><td align="center"><strong>11111111.11111111.11111111.11111</strong>000</td><td align="center">/<strong>29</strong></td></tr><tr><td align="center"><strong>255.255.255.252</strong></td><td align="center"><strong>11111111.11111111.11111111.111111</strong>00</td><td align="center">/<strong>30</strong></td></tr></tbody></table><p>注意: 网络地址也称为前缀或网络前缀。因此，前缀长度是子网掩码中设置为 1 的位数。</p><blockquote><p>当使用前缀长度表示 IPv4 地址时，IPv4 地址后面写入不带空格的前缀长度。例如，192.168.10.10 255.255.255.0可以写成192.168.10.10/24。后面将讨论各种类型前缀长度的使用。目前，重点是 /24（例如 255.255.255.0）前缀。</p></blockquote><hr><h3 id="确定网络：逻辑与-AND"><a href="#确定网络：逻辑与-AND" class="headerlink" title="确定网络：逻辑与(AND)"></a>确定网络：逻辑与(AND)</h3><blockquote><p>逻辑与(AND)是布尔或数字逻辑中使用的三种布尔运算之一。另外两种是或(OR)和非(NOT)。使用“与”运算来确定网络地址。</p></blockquote><p>逻辑与运算比较两个位，所得结果如下所示。<code>注意只有 1 AND 1 等于 1。任何其他组合都会产生 0</code>。</p><ul><li><p><strong>1 AND 1 = 1</strong></p></li><li><p><strong>0 AND 1 = 0</strong></p></li><li><p><strong>1 AND 0 = 0</strong></p></li><li><p><strong>0 AND 0 = 0</strong></p></li></ul><blockquote><p>注意: 在数字逻辑中，1 表示真，0 表示假。使用AND运算时，两个输入值都必须为 True (1)，结果才能为 True (1)。</p></blockquote><blockquote><p>要确定 IPv4 主机的网络地址，应将 IPv4 地址与子网掩码逐位进行逻辑 AND 运算。地址和子网掩码之间的 AND 运算得到的结果就是网络地址。</p></blockquote><p>要举例说明 AND 是如何用于发现网络地址的，假设主机的 IPv4 地址为 192.168.10.10，子网掩码为 255.255.255.0，如图所示：</p><ul><li><p><strong>IPv4 主机地址 (192.168.10.10)</strong> - 主机的 IPv4 地址，采用点分十进制和二进制格式。</p></li><li><p><strong>子网掩码 (255.255.255.0)</strong> - 主机的子网掩码，采用点分十进制和二进制格式。</p></li><li><p><strong>网络地址 (192.168.10.0)</strong> - IPv4地址和子网掩码之间的逻辑AND运算产生一个点分十进制和二进制格式的IPv4网络地址。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_4.png"><p>该图显示了 IPv4 主机地址和子网掩码之间的AND运算过程，产生主机的 IPv4 网络地址。IPv4主机地址是192.168.10.10。下面，地址被转换为11000000 10101000 00001010 00001010。下面，将写入子网掩码255.255.255.0。下面，子网掩码被转换为11111111 11111111 11111111 00000000。在子网掩码的二进制等效值下画了一条线。线下方是由AND运算过程确定的 IPv4 网络地址的点分十进制和二进制等效值。蓝色阴影框显示了 IPv4 主机地址的第一位（1），与子网掩码的第一位相比(也是 1)，从而产生 IPv4 网络地址中的第一位值为 1。IPv4 网络地址是 192.168.10.0，其二进制等效值是11000000 101001000 00001010 00000000。</p><p>以第一个位序列为例，请注意AND运算是在主机地址的1位和子网掩码的1位上执行的。这将产生网络地址的 1 位。1 AND 1 = 1。</p><p>IPv4 主机地址和子网掩码之间的AND运算过程，产生主机的 IPv4 网络地址。在此示例中，主机地址 192.168.10.10 与子网掩码 255.255.255.0 (/24) 之间的 AND运算会产生 IPv4 网络地址为192.168.10.0/24。这是一个重要的 IPv4运算，因为它会告诉主机其所属的网络。</p><hr><h3 id="网络地址、主机地址和广播地址"><a href="#网络地址、主机地址和广播地址" class="headerlink" title="网络地址、主机地址和广播地址"></a>网络地址、主机地址和广播地址</h3><p>在每个网络中有三种类型的 IP 地址：</p><ul><li><p><strong>网络地址</strong></p></li><li><p><strong>主机地址</strong></p></li><li><p><strong>广播地址</strong></p></li></ul><p>使用图中的拓扑，将检查这三种类型的地址。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_5.png"><hr><blockquote><p>网络地址</p></blockquote><p>网络地址是表示特定网络的地址。如果设备满足以下三个条件，则属于此网络：</p><ul><li><p>它具有<code>与网络地址相同的子网掩码</code>。</p></li><li><p>它具有<code>与网络地址相同的网络位</code>，如子网掩码所示。</p></li><li><p>它<code>与具有相同网络地址的其他主机位于同一广播域中</code>。</p></li></ul><p>主机通过在其 IPv4 地址与其子网掩码之间执行一个AND运算来确定其网络地址。</p><p>如表中所示，由子网掩码确定的网络地址在主机部分中包含所有 0 位。在此示例中，网络地址是 192.168.10.0/24。无法将网络地址分配给设备。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_6.png" alt="网络地址、主机地址和广播地址"></p><hr><blockquote><p>主机地址</p></blockquote><p><code>主机地址是可以分配给设备的地址</code>，如主机，笔记本电脑，智能手机，网络摄像头，打印机，路由器等。地址的主机部分是由子网掩码中 0 位表示的位。除了全0位（这将是网络地址）或全1位（这将是广播地址）之外，主机地址在主机部分可以有任何位的组合。</p><p>同一网络中的所有设备，必须具有相同的子网掩码和相同的网络位。只有主机位会有所不同，且必须是唯一的。</p><p>请注意表中，有第一个和最后一个主机地址：</p><ul><li><p><strong>第一个主机地址</strong> - 网络中的第一个主机，除最后一位（最右边）为1位外包含所有0位。在这个例子中，它的地址是192.168.10.1/24。</p></li><li><p><strong>最后一个主机地址</strong> - 网络中的最后一个主机，除最后一位（最右边）为0位外包含所有1位。在这个例子中，它的地址是192.168.10.254/24。<br>从192.168.10.1/24到192.168.10.254/24之间（包含）的任何地址都可以分配给网络上的设备。</p></li></ul><hr><blockquote><p>广播地址</p></blockquote><p><code>广播地址是在需要访问IPv4网络上的所有设备时使用的地址</code>。如表中所示，由子网掩码确定的网络广播地址在主机部分中包含所有 1 位。在此示例中，网络地址是 192.168.10.255/24。<code>无法将广播地址分配给设备</code>。</p><hr><h3 id="IPv4-单播"><a href="#IPv4-单播" class="headerlink" title="IPv4 单播"></a>IPv4 单播</h3><blockquote><p>单播传输是指在<strong>一对一通信中</strong>，<strong>一个设备向另一个设备发送消息</strong>。</p></blockquote><blockquote><p><code>单播数据包具有一个目的 IP 地址，该地址是一个单播地址，该地址指向一个单独的接收者</code>。<strong>源 IP 地址只能是单播地址，因为数据包只能来自单个源</strong>。这与目的IP地址是单播、广播还是组播无关。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_7_1.png" alt="源主机发送单播信息"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_7_2.png" alt="目的主机接受单播信息"></p><p><strong>IPv4 单播主机地址的地址范围是 1.1.1.1到 223.255.255.255</strong>。不过，此范围中的很多地址被留作特殊用途。</p><hr><h3 id="IPv4-广播"><a href="#IPv4-广播" class="headerlink" title="IPv4 广播"></a>IPv4 广播</h3><blockquote><p>广播播传输是指设备在一对多通信中，向网络上的所有设备发送消息。</p></blockquote><p>广播数据包以主机部分全部为 1 的地址或 32 个 1 位作为目的 IP 地址。</p><p>注意: <strong>IPv4 使用广播数据包</strong>，但是<code>IPv6 没有广播数据包</code>。</p><blockquote><p>广播数据包必须由同一广播域中的所有设备处理。广播域标识同一网段上的所有主机。可以对广播进行定向或限制。定向广播是将数据包发送给特定网络中的所有主机。例如，位于 172.16.4.0/24 网络的主机向 172.16.4.255 发送数据包。受限广播将被发送至 255.255.255.255。默认情况下，路由器不转发广播。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_8_1.png" alt="源主机向交换机发送信息"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_8_2.png" alt="交换机向余下主机与设备发送广播信息"></p><p><strong>广播数据包使用网络上的资源，使网络上的所有接收主机都处理该数据包</strong>。因此，<code>广播通信应加以限制，以免对网络或设备的性能造成负面影响</code>。因为<code>路由器可分隔广播域，所以细分网络可以通过消除过多的广播通信来提高网络性能</code>。</p><hr><p>IP直接广播</p><p><code>除了 255.255.255.255 的广播地址外，每个网络还有一个广播 IPv4 地址。这个地址称为定向广播，它使用网络范围内的最大地址，即所有主机位全部为 1 的地址</code>。例如，网络 192.168.1.0/24的定向广播地址是 192.168.1.255。<code>此地址允许与该网络中的所有主机进行通信。要向网络中的所有主机发送数据，主机只需以该网络广播地址为目标地址发送一个数据包即可</code>。</p><blockquote><p>未直接连接到目标网络的设备转发 IP 定向广播，其方式与转发去往网络上主机的单播 IP 数据包相同。当定向广播数据包到达直接连接到目标网络的路由器时，该数据包在目标网络上进行广播。</p></blockquote><p>注意: 由于安全问题和恶意用户的滥用，从思科 IOS 版本 12.0 开始通过全局配置命令 no ip directed-broadcasts，定向广播在默认情况下是关闭的。</p><hr><h3 id="IPv4-组播"><a href="#IPv4-组播" class="headerlink" title="IPv4 组播"></a>IPv4 组播</h3><blockquote><p>主机通过<code>组播</code>传输可以<code>向所属组播组中的选定主机组发送一个数据包</code>，<code>从而减少了流量</code>。</p></blockquote><p>组播数据包是一个目的IP地址为组播地址的数据包。IPv4 将 224.0.0.0 到 239.255.255.255 的地址保留为组播范围。</p><blockquote><p><strong>接收特定组播数据包的主机称为组播客户端</strong>。组播客户端使用客户端程序请求的服务来加入组播组。</p></blockquote><p>每个组播组由一个 IPv4 组播目的地址代表。<code>当 IPv4 主机加入组播组后，该主机既要处理目的地址为此组播地址的数据包，也要处理发往其唯一单播地址的数据包</code>。</p><p>路由协议（如 OSPF）使用组播传输。例如，启用 OSPF 的路由器使用保留的 OSPF 组播地址 224.0.0.5 相互通信。只有启用 OSPF 的设备才会以 224.0.0.5 作为目的 IPv4 地址处理这些数据包。所有其他设备将忽略这些数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_9_1.png" alt="源主机向交换机发送信息"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_9_2.png" alt="交换机向余下主机与设备发送信息"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_9_3.png" alt="各主机与设备检查信息是否为源主机所指定"></p><hr><h3 id="公有和私有-IPv4-地址"><a href="#公有和私有-IPv4-地址" class="headerlink" title="公有和私有 IPv4 地址"></a>公有和私有 IPv4 地址</h3><p>正如有不同的方式传输 IPv4 数据包一样，也有不同类型的 IPv4 地址。一些 IPv4 地址不能用于外联到互联网，而其他地址则专门用于路由到互联网。一些用于验证连接，另一些则是自分配的。</p><blockquote><p>公有 IPv4 地址是能在 ISP（互联网运营商）路由器之间全局路由的地址。但是，并非所有可用的 IPv4 地址都可用于互联网。大多数组织使用称为私有地址的地址块向内部主机分配 IPv4 地址。</p></blockquote><p>20 世纪 90 年代中期，随着万维网(WWW)的引入，由于 IPv4 地址空间耗尽，引入了私有 IPv4 地址。私有 IPv4 地址并不是唯一的，可以在任何网络内部使用它。</p><p>注意: <strong>IPv4 地址耗尽的长期解决方案是 IPv6</strong>。</p><table><thead><tr><th align="center">网络地址和前缀</th><th align="center">RFC 1918 私有地址范围</th></tr></thead><tbody><tr><td align="center">10.0.0.0/8</td><td align="center">10.0.0.0 - 10.255.255.255</td></tr><tr><td align="center">172.16.0.0/12</td><td align="center">172.16.0.0 - 172.31.255.255</td></tr><tr><td align="center">192.168.0.0/16</td><td align="center">192.168.0.0 - 192.168.255.255</td></tr></tbody></table><p>注意: 私有地址在 RFC 1918 中定义，有时也称为 RFC 1918 地址空间。</p><hr><h3 id="路由到互联网"><a href="#路由到互联网" class="headerlink" title="路由到互联网"></a>路由到互联网</h3><p>大多数内部网络（从大型企业到家庭网络）都使用私有 IPv4 地址来编址所有内部设备（Intranet），包括主机和路由器。但是，私有地址不可全局路由。</p><blockquote><p>在图中，客户网络 1、2 和 3 正在其内部网络之外发送数据包。这些数据包有一个源IPv4地址，它是一个私有地址，还有一个目的IPv4地址，它是公有地址(全局可路由)。<code>在将数据包转发给ISP之前，必须过滤(丢弃)带有私有地址的数据包或将其转换为公有地址</code>。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_11_1.png" alt="Private IPv4 Addresses and Network Address Translation (NAT)"></p><blockquote><p><code>在 ISP 可以转发此数据包之前，它必须使用网络地址转换 (NAT) 将源 IPv4 地址（即私有地址）转换为公有 IPv4 地址</code>。<strong>NAT用于转换私有和公有 IPv4 地址</strong>。这通常是在将内部网络连接到 ISP 网络的路由器上完成。在路由到互联网之前，组织内部网中的私有 IPv4 地址将被转换为公有 IPv4 地址。</p></blockquote><p>注意: 虽然具有私有 IPv4 地址的设备无法通过互联网从另一个设备直接访问，但 IETF 并不认为私有 IPv4 地址或 NAT 是有效的安全措施。</p><p>拥有可用于互联网的资源的组织（如 Web 服务器）也将拥有具有公有 IPv4 地址的设备。如图所示，该网络的这一部分被称为DMZ（非军事区）。图中的路由器不仅执行路由，还执行 NAT 并充当安全防火墙。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_11_1.png" alt="Private IPv4 Addresses and Network Address Translation (NAT)"></p><p>注意: 私有 IPv4 地址通常用于教育目的，而不是使用最有可能属于组织的公有 IPv4 地址。</p><hr><h3 id="专用-IPv4-地址"><a href="#专用-IPv4-地址" class="headerlink" title="专用 IPv4 地址"></a>专用 IPv4 地址</h3><blockquote><p>一些地址，比如网络地址和广播地址不能分配给主机。还有些特殊地址可以分配给主机，但这些主机在网络内的交互方式却受到限制。</p></blockquote><ul><li><strong>环回地址</strong></li></ul><p>环回地址（127.0.0.0 /8 或 127.0.0.1 到 127.255.255.254）通常仅被标识为127.0.0.1，主机使用这些特殊地址将流量指向其自身。例如，如图所示，主机可以使用这个特殊地址测试 TCP/IP 配置是否运行正常。注意 127.0.0.1 环回地址对ping命令的应答。也要注意该块中的任何地址是如何环回到本地主机的，如图的第二个ping所示。</p><p>对环回接口执行 ping 操作</p><pre><code class="bash">C:\Users\NetAcad&gt; ping 127.0.0.1Pinging 127.0.0.1 with 32 bytes of data:Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128Ping statistics for 127.0.0.1:Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),Approximate round trip times in milli-seconds:Minimum = 0ms, Maximum = 0ms, Average = 0msC:\Users\NetAcad&gt; ping 127.1.1.1Pinging 127.1.1.1 with 32 bytes of data:Reply from 127.1.1.1: bytes=32 time&lt;1ms TTL=128Reply from 127.1.1.1: bytes=32 time&lt;1ms TTL=128Reply from 127.1.1.1: bytes=32 time&lt;1ms TTL=128Reply from 127.1.1.1: bytes=32 time&lt;1ms TTL=128Ping statistics for 127.1.1.1:Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),Approximate round trip times in milli-seconds:Minimum = 0ms, Maximum = 0ms, Average = 0ms</code></pre><ul><li><strong>本地链路地址</strong></li></ul><blockquote><p>本地链路地址（169.254.0.0 /16 或 169.254.0.1 至 169.254.255.254）通常称为自动私有 IP 编址 (APIPA) 地址或自分配地址。 <strong>当没有可用的DHCP服务器时，Windows DHCP客户端使用它们进行自我配置。本地链路地址可以用于点对点连接，但通常不用于此目的</strong>。</p></blockquote><hr><h3 id="传统有类编址"><a href="#传统有类编址" class="headerlink" title="传统有类编址"></a>传统有类编址</h3><p>1981 年，使用在<a href="https://tools.ietf.org/html/rfc790">RFC 790</a> 中 Assigned Numbers 部分定义的有类编址对 IPv4 地址进行了分配。根据三个类别（A 类、B 类或 C 类）之一为客户分配网络地址。RFC 将单播范围分为具体的类别：</p><ul><li><p><strong>A 类 (0.0.0.0/8 - 127.0.0.0/8)</strong> - 用于<strong>支持拥有 1600 万以上主机地址的规模非常大的网络</strong>。<code>A类的第一个八位组使用固定的 /8 前缀表示网络地址，其他的三个八位组表示主机地址(每个网络支持1600 万以上主机地址)</code>。</p></li><li><p><strong>B 类 (128.0.0.0 /16 – 191.255.0.0 /16)</strong> - 用于<strong>支持拥有大约 65,000 个主机地址的大中型网络</strong>。<code>B类的两个高位八位组使用固定的 /16 前缀表示网络地址，其他的两个八位组表示主机地址(每个网络支持65,000个以上主机地址)</code>。</p></li><li><p><strong>C 类 (192.0.0.0 /24 – 223.255.255.0 /24)</strong> - 用于<strong>支持最多拥有 254 台主机的小型网络</strong>。<code>C类的前三个八位组使用固定的 /24 前缀表示网络地址，其余的八位组表示主机地址（每个网络中只有254个主机地址）</code>。</p></li></ul><blockquote><p>注意: 还有包含 224.0.0.0 到 239.0.0.0 的 D 类组播块以及包含 240.0.0.0 – 255.0.0.0 的 E 类实验地址块。</p></blockquote><p>当时，由于使用互联网的计算机数量有限，有类编址是分配地址的有效手段。如图所示，A 类和 B 类网络具有非常多的主机地址，而C类只有很少的主机地址。A 类网络占 IPv4 网络的 50%。这导致大多数可用的 IPv4 地址未被使用。</p><p>该图是一个饼图，显示了A、B、C、D 和 E IPv4编址的百分比，每个 A、B 和 C 类网络的网络和主机总数。百分比为:<strong>A类= 50%，B类= 25%，C类= 12.5%，D类和E类= 12.5%<strong>。每个网络的网络总数和主机总数为：</strong>A 类 = 128 个网络，每个网络共有 16,777,214 个主机</strong>；<strong>B 类 = 16,384 个网络，每个网络共有 65,534 个主机</strong>；<strong>C 类 = 2,097,152 个网络，每个网络共有 254 个主机</strong>。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_13.png"><p>二十世纪90年代中期，随着万维网 (WWW) 的引入，有类编址被弃用，以便更有效地分配有限的 IPv4 地址空间。有类地址分配被替换为今天使用的无类编址。无类编址会忽略A、B、C类的规则。公有 IPv4 网络地址（网络地址和子网掩码）是根据合理的地址数量分配的。</p><hr><h3 id="IP-地址的分配"><a href="#IP-地址的分配" class="headerlink" title="IP 地址的分配"></a>IP 地址的分配</h3><p>公有 IPv4 地址是能通过互联网全局路由的地址。公有 IPv4 地址必须是唯一的。</p><blockquote><p>IPv4 和 IPv6 地址是通过互联网编号指派机构 (IANA) 管理的。IANA 管理并向地区性互联网注册机构 (RIR) 分配 IP 地址块。图中显示了五个RIR。</p></blockquote><blockquote><p>RIR 的职责是向 ISP 分配 IP 地址，而 ISP 将向组织和更小的 ISP 提供 IPv4 地址块。根据 RIR 的政策规定，组织也可直接从 RIR 获取地址。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_14.png" alt="Regional Internet Registries"></p><hr><h3 id="广播域和分段"><a href="#广播域和分段" class="headerlink" title="广播域和分段"></a>广播域和分段</h3><p>您是否收到过群发给您公司或学校每个人的电子邮件？这就是一个广播电子邮件。它包含了您们每个人都需要知道的信息。但是，通常广播并不是与邮件列表中的每个人都相关。有时候，只有一部分人需要阅读这些信息。</p><p>在以太网局域网中，设备使用广播和地址解析协议 (ARP) 来定位其他设备。地址解析协议 (ARP)将第 2 层广播发送到本地网络上的已知 IPv4 地址，以发现相关 MAC 地址。以太网局域网上的设备还可以使用服务定位其他设备。主机通常需要使用动态主机配置协议 (DHCP) 来获取 IPv4 地址配置，这会发送本地网络上的广播来定位 DHCP 服务器。</p><p>交换机会将广播传播到所有接口，接收它的接口除外。例如，如果图中的交换机接收到广播，则它会将其转发到网络上连接的其他交换机和其他用户。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_15.png" alt="路由器分段广播域"></p><p>路由器不传播广播。路由器在收到广播时，它不会将其转发到其他接口。例如，当 R1 在其 Gigabit Ethernet 0/0 接口收到广播时，它不会将其转发到另一个接口。</p><p>因此，每个路由器接口都连接了一个广播域，而广播只能在特定广播域内传播。</p><hr><h3 id="大型广播域存在的问题"><a href="#大型广播域存在的问题" class="headerlink" title="大型广播域存在的问题"></a>大型广播域存在的问题</h3><p>大型广播域是连接很多主机的网络。大型广播域的一个问题是这些主机会生成太多广播，这会对网络造成不良影响。在图中，局域网1 连接了 400 个用户，可能会产生过量的广播流量。这会导致网络操作速度缓慢，因为它会导致大量的流量，而设备操作变慢是因为设备必须接受和处理每个广播数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_16_1.png" alt="大型广播域"></p><p>解决方案是使用称为“子网划分”的过程缩减网络的规模以创建更小的广播域。这些较小的网络空间通常称为“子网”。</p><p>在图中，网络地址为 172.16.0.0 /16 的 LAN 1 中的 400 个用户被划分到两个子网中，每个子网包含 200 个用户，网络地址分别为 172.16.0.0 /24 和 172.16.1.0 /24。广播仅在更小的网络域内传播。因此，LAN 1 中的广播不会传播到 LAN 2。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_16_2.png" alt="在网络之间通信"></p><p>注意，从一个单一的/16网络到两个/24网络前缀长度是如何变化的。这是基本的子网划分：使用主机位可以创建其他子网。</p><p>注意: 术语“子网”和“网络”经常互换使用。大多数网络是一些较大地址块的子网。</p><hr><h3 id="划分网络的原因"><a href="#划分网络的原因" class="headerlink" title="划分网络的原因"></a>划分网络的原因</h3><p>子网划分可以降低整体网络流量并改善网络性能。它也能让管理员实施安全策略，例如哪些子网允许或不允许进行通信。另一个原因是，它减少了由于错误配置、硬件/软件问题或恶意意图而受到异常广播流量影响的设备数量。</p><p>使用子网有多种方法，可帮助管理网络设备。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_17_1.png" alt="位置"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_17_2.png" alt="组域功能"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_17_3.png" alt="设备类型"></p><p>网络管理员可以使用对网络有意义的任何其他划分来创建子网。注意，在每个图中，子网使用较长的前缀来标识网络。</p><p>理解如何对网络划分子网是所有网络管理员必须掌握的基本技能。已经创建了各种方法来帮助理解这一过程。虽然开始时会让您有点晕头转向，但是请把注意力集中于细节和实践操作，那样就会更容易理解子网划分。</p><hr><h3 id="在二进制八位组边界上划分子网"><a href="#在二进制八位组边界上划分子网" class="headerlink" title="在二进制八位组边界上划分子网"></a>在二进制八位组边界上划分子网</h3><p>在上一个主题中，您了解了对网络进行划分的几个很好的理由。您还了解到，划分一个网络称为子网划分。子网划分是管理 IPv4 网络时的一项关键技能。一开始可能会有点困难，但是通过练习会变得容易得多。</p><p>创建 IPv4 子网时会将一个或多个主机位作为网络位。具体做法是延长子网掩码，从地址的主机部分借用若干位来增加网络位。借用的主机位越多，可以定义的子网也就越多。为了增加子网数量而借用的位越多，每个子网的主机数量就越少。</p><p>网络在二进制八位数边界 /8、/16 和 /24 处最容易进行子网划分。该表标识了这些前缀长度。注意，使用较长的前缀会减少每个子网能包含的主机数。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_18_1.png" alt="八位组边界上的子网掩码"></p><p>为了理解如何在二进制八位组边界上进行子网划分，请考虑以下示例。假设企业选择了私有地址 10.0.0.0/8 作为其内部网络地址。该网络地址可以在一个广播域中连接 16,777,214 个主机。显然，在一个子网上拥有超过 1600 万台主机并不理想。</p><p>企业可以进一步在二进制八位组边界 /16 处对 10.0.0.0/8 地址进行子网划分，如表所示。这能让企业定义多达 256 个子网（例如，10.0.0.0/16 – 10.255.0.0/16），每个子网可以连接 65,534 个主机。注意，前两个二进制八位组标识地址的网络部分，而后两个二进制八位组用于标识主机 IP 地址。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_18_2.png" alt="使用 /16前缀对网络 10.0.0.0/8进行子网划分"></p><p>另外，企业也可以选择在 /24 二进制八位组边界处对 10.0.0.0/8 网络进行子网划分，如表所示。这将让企业能定义 65,536 个子网，每个子网能连接 254 个主机。/24 边界在子网划分中使用非常广泛，因为它在这个二进制八位数边界处可以容纳足够多的主机，并且子网划分也很方便。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_18_3.png" alt="使用/24前缀对网络10.0.0.0/8进行 子网划分"></p><hr><h3 id="在二进制八位组边界内-划分子网"><a href="#在二进制八位组边界内-划分子网" class="headerlink" title="在二进制八位组边界内 划分子网"></a>在二进制八位组边界内 划分子网</h3><p>到目前为止所展示的示例都是从常见的 /8、/16 和 /24 网络前缀借用了主机位。然而，子网可以从任何主机位借用位来创建其他掩码。</p><p>例如，/24 网络地址通常通过从第 4 个二进制八位数借用位来使用更长的前缀进行子网划分。这可以让管理员在将网络地址分配到更少数量的终端设备时具有很好的灵活性。</p><p>参考下表可以看到6种对/24网络划分子网的方式。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_19.png" alt="对 /24 网络划分子网"></p><p>对在第 4 个二进制八位组中借用的每个位，可用的子网数会加倍，同时每个子网的主机地址数会减少。</p><ul><li><p><strong>/25 行</strong> - 从第 4 个二进制八位组借用 1 位可以创建每个能容纳 126 个主机的 2 个子网。</p></li><li><p><strong>/26 行</strong> - 借用 2 位可以创建每个能容纳 62 个主机的 4 个子网。</p></li><li><p><strong>/27 行</strong> - 借用 3 位可以创建每个能容纳 30 个主机的 8 个子网。</p></li><li><p><strong>/28 行</strong> - 借用 4 位可以创建每个能容纳 14 个主机的 16 个子网。</p></li><li><p><strong>/29 行</strong> - 借用 5 位可以创建每个能容纳 6 个主机的 32 个子网。</p></li><li><p><strong>/30 行</strong> - 借用 6 位可以创建每个能容纳 2 个主机的 64 个子网。</p></li></ul><hr><h3 id="使用-16-前缀创建子网"><a href="#使用-16-前缀创建子网" class="headerlink" title="使用 /16 前缀创建子网"></a>使用 /16 前缀创建子网</h3><p>有些子网比其他子网更容易。本主题介绍如何创建具有相同数量主机的子网。</p><p>在要求较多子网的情况下，需要 IPv4 网络有更多主机位可以借用。例如，网络地址 172.16.0.0 具有默认掩码 255.255.0.0 或 /16。该地址的网络部分有 16 位，主机部分也有 16 位。主机部分的这 16 位可借用来创建子网。表突出显示了对 /16 前缀进行子网划分的所有可能的场景。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_20.png" alt="对 /16 网络划分子网"></p><p>虽然您不需要记住这个表，但仍然需要很好地了解表中每个值的生成方式。不要让表的大小吓着了您。变大的原因是因为它有 8 个能借用的额外位，因此子网和主机的数量只能是变大。</p><hr><h3 id="使用-16-前缀创建-100-个子网"><a href="#使用-16-前缀创建-100-个子网" class="headerlink" title="使用 /16 前缀创建 100 个子网"></a>使用 /16 前缀创建 100 个子网</h3><p>假设一家大型企业需要至少 100 个子网，并且已选择私有地址 172.16.0.0/16 作为其内部网络地址。</p><p>当从 /16 地址借用位时，从借用第三个二进制八位组开始，并遵循从左向右的顺序。一次借用一个位直至所需的位数能创建 100 个子网。</p><p>该图显示了当从第三个二进制八位组和第四个二进制八位组借用位时能创建的子网数。注意，现在可以借用的主机位多达 14 个。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_21_1.png" alt="创建的子网数"></p><p>要满足企业100个子网的要求，需要借用 7 位（即 2^7= 128 个子网），如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_21_2.png" alt="172.16.0.0/23 网络"></p><p>回想一下，子网掩码必须作出更改以反映借用的位。在本示例中，当借用 7 个位时，掩码将扩展 7 个位到第三个二进制八位数。该掩码以十进制表示为 255.255.254.0，或者 /23 前缀，因为，第三个二进制八位组以二进制表示为 11111110，第四个二进制八位组以二进制表示为 00000000。</p><p>图中显示了生成的子网范围从 172.16.0.0 /23 到 172.16.254.0 /23。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_21_3.png" alt="产生 /23 子网"></p><p>在为子网借用 7 个位之后，第三个二进制八位组中剩余 1 个主机位，第四个二进制八位组中剩余 8 个主机位，所以总共有 9 个位没有借用。2的9次幂会产生 512 个主机地址。第一个地址是为网络地址保留的，最后一个地址是为广播地址保留的，因此减去这两个地址 (2^9-2) 等于每个 /23 子网有 510 个可用的主机地址。</p><p>如图所示，第一个子网的第一个主机地址是 172.16.0.1，最后一个主机地址是 172.16.1.254。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_21_4.png" alt="172.16.0.0/23 子网的地址范围"></p><hr><h3 id="使用-8-前缀创建-1000-个子网"><a href="#使用-8-前缀创建-1000-个子网" class="headerlink" title="使用 /8 前缀创建 1000 个子网"></a>使用 /8 前缀创建 1000 个子网</h3><p>一些组织，例如小型服务提供商或大型企业，可能需要更多的子网。例如，小型 ISP 可能需要 1000 个子网来满足其客户端。每个客户端可能在主机部分需要足够的空间来创建自己的子网。</p><p>ISP有一个网络地址 10.0.0.0 255.0.0.0 或 10.0.0/8。这意味着网络部分有 8 个位，24 个主机位可以在子网划分时借用。因此，小型 ISP 将对 10.0.0.0/8 网络进行子网划分。</p><p>为了创建子网，我们必须从现有互联网络 IPv4 地址的主机部分借用位。从第一个可用主机位开始从左到右借用，一次借用一个位，直到达到创建 1000 个子网所需的位数。如图所示，您需要借用 10 位来创建 1024 个子网(210 = 1024)。这包括从第二个二进制八位组借用 8 位，从第三个二进制八位组再借用 2 位。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_22_1.png" alt="创建的子网数"></p><p>该图显示了网络地址和生成的子网掩码（转换为 255.255.192.0 或 10.0.0.0/18）。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_22_2.png" alt="10.0.0.0/18 网络"></p><p>该图显示借用 10 位生成的子网，创建了从 10.0.0.0 /18 到 10.255.128.0 /18 的子网。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_22_3.png" alt="产生 /18 子网"></p><p>借用10位来创建子网，每个子网留下14位主机位。每个子网减去两个主机(一个用于网络地址，另一个用于广播地址)等于每个子网2^14 - 2 = 16382个主机。这意味着1000个子网中的每个子网最多可以支持16,382个主机。</p><p>该图显示了第一个子网的具体情况。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_22_4.png" alt="10.0.0.0/18 子网的地址范围"></p><hr><h3 id="对私有和公有IPv4地址空间进行子网划分"><a href="#对私有和公有IPv4地址空间进行子网划分" class="headerlink" title="对私有和公有IPv4地址空间进行子网划分"></a>对私有和公有IPv4地址空间进行子网划分</h3><p>虽然可以快速地将网络划分为子网，但是您的组织的网络可能同时使用公有和私有IPv4地址。这会影响您的网络划分子网的方式。</p><p>该图显示了典型的企业网络：</p><ul><li><p><strong>内部网</strong> - 这是公司网络的内部部分，只能在组织内部访问。内部网中的设备使用私有 IPv4 地址。</p></li><li><p><strong>DMZ</strong> - 这是公司网络的一部分，其中包含可供互联网使用的资源，如 Web 服务器。DMZ 中的设备使用公有 IPv4 地址。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_23.png" alt="公有和私有 IPv4 地址空间"></p><p>内部网和 DMZ 都有自己的子网划分要求和挑战。</p><p>内部网使用私有 IPv4 编址空间。这允许组织使用任何私有 IPv4 网络地址，包括带有 24 个主机位和超过 1600 万台主机的 10.0.0/8 前缀。使用有 24 个主机位的网络地址可使子网划分更容易、更灵活。这包括使用 /16 或 /24 在八位组边界上进行子网划分。</p><p>例如，私有 IPv4 网络地址 10.0.0.0/8 可以使用 /16 掩码进行子网划分。如表中所示，这将产生 256 个子网，每个子网有 65,534 个主机。如果一个组织需要的子网少于200个，允许一定的增长，这将给每个子网提供了足够多的主机地址。</p><ul><li><strong>使用 /16前缀对网络 10.0.0.0/8进行子网划分</strong></li></ul><table><thead><tr><th align="center">子网地址（256 个可能的子网）</th><th align="center">主机范围（每个子网可能有 65,534 个主机）</th><th align="center">广播</th></tr></thead><tbody><tr><td align="center"><strong>10.0</strong>.0.0/<strong>16</strong></td><td align="center"><strong>10.0</strong>.0.1 - <strong>10.0</strong>.255.254</td><td align="center"><strong>10.0</strong>.255.255</td></tr><tr><td align="center"><strong>10.1</strong>.0.0/<strong>16</strong></td><td align="center"><strong>10.1</strong>.0.1 - <strong>10.1</strong>.255.254</td><td align="center"><strong>10.1</strong>.255.255</td></tr><tr><td align="center"><strong>10.2</strong>.0.0/<strong>16</strong></td><td align="center"><strong>10.2</strong>.0.1 - <strong>10.2</strong>.255.254</td><td align="center"><strong>10.2</strong>.255.255</td></tr><tr><td align="center"><strong>10.3</strong>.0.0/<strong>16</strong></td><td align="center"><strong>10.3</strong>.0.1 - <strong>10.3</strong>.255.254</td><td align="center"><strong>10.3</strong>.255.255</td></tr><tr><td align="center"><strong>10.4</strong>.0.0/<strong>16</strong></td><td align="center"><strong>10.4</strong>.0.1 - <strong>10.4</strong>.255.254</td><td align="center"><strong>10.4</strong>.255.255</td></tr><tr><td align="center"><strong>10.5</strong>.0.0/<strong>16</strong></td><td align="center"><strong>10.5</strong>.0.1 - <strong>10.5</strong>.255.254</td><td align="center"><strong>10.5</strong>.255.255</td></tr><tr><td align="center"><strong>10.6</strong>.0.0/<strong>16</strong></td><td align="center"><strong>10.6</strong>.0.1 - <strong>10.6</strong>.255.254</td><td align="center"><strong>10.6</strong>.255.255</td></tr><tr><td align="center"><strong>10.7</strong>.0.0/<strong>16</strong></td><td align="center"><strong>10.7</strong>.0.1 - <strong>10.7</strong>.255.254</td><td align="center"><strong>10.7</strong>.255.255</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center"><strong>10.255</strong>.0.0/16</td><td align="center"><strong>10.255</strong>.0.1 - <strong>10.255</strong>.255.254</td><td align="center"><strong>10.255</strong>.255.255</td></tr></tbody></table><p>使用 10.0.0.0/8 私有 IPv4 网络地址的另一种选择是使用 /24 掩码进行子网划分。如表中所示，这将产生 65,536 个子网，每个子网有 254 个主机。如果一个组织需要超过256个子网，那么使用/24进行子网划分，每个子网有254个主机可以使用。</p><ul><li>使用 /24 对网络10.0.0.0/8进行子网划分</li></ul><table><thead><tr><th align="center">子网地址(65,536 个可能的子网)</th><th align="center">主机范围（每个子网可能有 254 个主机）</th><th align="center">广播</th></tr></thead><tbody><tr><td align="center"><strong>10.0.0</strong>.0/24</td><td align="center"><strong>10.0.0</strong>.1 - <strong>10.0.0</strong>.254</td><td align="center"><strong>10.0.0</strong>.255</td></tr><tr><td align="center"><strong>10.0.1</strong>.0/24</td><td align="center"><strong>10.0.1</strong>.1 - <strong>10.0.1</strong>.254</td><td align="center"><strong>10.0.1</strong>.255</td></tr><tr><td align="center"><strong>10.0.2</strong>.0/24</td><td align="center"><strong>10.0.2</strong>.1 - <strong>10.0.2</strong>.254</td><td align="center"><strong>10.0.2</strong>.255</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center"><strong>10.0.255</strong>.0/24</td><td align="center"><strong>10.0.255</strong>.1 - <strong>10.0.255</strong>.254</td><td align="center"><strong>10.0.255</strong>.255</td></tr><tr><td align="center"><strong>10.1.0</strong>.0/24</td><td align="center"><strong>10.1.0</strong>.1 - <strong>10.1.0</strong>.254</td><td align="center"><strong>10.1.0</strong>.255</td></tr><tr><td align="center"><strong>10.1.1</strong>.0/24</td><td align="center"><strong>10.1.1</strong>.1 - <strong>10.1.1</strong>.254</td><td align="center"><strong>10.1.1</strong>.255</td></tr><tr><td align="center"><strong>10.1.2</strong>.0/24</td><td align="center"><strong>10.1.2</strong>.1 - <strong>10.1.2</strong>.254</td><td align="center"><strong>10.1.2</strong>.255</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center"><strong>10.100.0</strong>.0/24</td><td align="center"><strong>10.100.0</strong>.1 - <strong>10.100.0</strong>.254</td><td align="center"><strong>10.100.0</strong>.255</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center"><strong>10.255.255</strong>.0/24</td><td align="center"><strong>10.255.255</strong>.1 - <strong>10.255.255</strong>.254</td><td align="center"><strong>10.255.255</strong>.255</td></tr></tbody></table><p>10.0.0.0/8还可以使用任何其他前缀长度的数字进行子网划分，如/12、/18、/20等。这将为网络管理员提供多种选择。使用10.0.0.0/8私有IPv4网络地址使子网规划和实现变得简单。</p><ul><li>关于DMZ</li></ul><p>因为这些设备需要从互联网公开访问，所以DMZ中的设备需要公有IPv4地址。从20世纪90年代中期开始，公有IPv4地址空间的耗尽成为了一个问题。自 2011 年以来，IANA 和五个 RIR 中的四个用尽了 IPv4 地址空间。虽然组织正在向IPv6过渡，但是剩余的IPv4地址空间仍然非常有限。这意味着组织必须最大限度地提高其自身有限数量的公有 IPv4 地址。这要求网络管理员将其公有地址空间划分到具有不同子网掩码的子网中，以便最大限度地减少每个子网的未使用主机地址数量。这称为可变长子网掩码 (VLSM)。</p><hr><h3 id="最小化未使用的主机-IPv4-地址并最大化子网"><a href="#最小化未使用的主机-IPv4-地址并最大化子网" class="headerlink" title="最小化未使用的主机 IPv4 地址并最大化子网"></a>最小化未使用的主机 IPv4 地址并最大化子网</h3><p>要尽量减少未使用的主机 IPv4 地址数量并最大化可用子网数量，在规划子网时需要考虑两个因素：每个网络所需的主机地址数量和所需的单个子网数量。</p><p>该表显示了对 /24 网络进行子网划分的具体情况。注意，子网数量与主机数量成反比。借用越多的位来创建子网，可用的主机位越少。如果需要更多主机地址，就需要更多主机位，那么子网数就会更少。</p><p>最大子网中所需的主机地址数量将决定主机部分必须保留多少个位。回想一下，有 2 个地址不能使用，因此可用地址的数量可以这样计算：2^n-2。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_24.png" alt="对 /24 网络划分子网"></p><p>网络管理员必须设计网络编址方案，以满足每个网络的最大主机数量和子网数量需求。编址方案应允许每个子网的主机地址数量和子网的总数量的增长。</p><hr><h3 id="示例：高效的IPv4子网划分"><a href="#示例：高效的IPv4子网划分" class="headerlink" title="示例：高效的IPv4子网划分"></a>示例：高效的IPv4子网划分</h3><p>在本示例中，公司总部的ISP为其分配了一个公共网络地址172.16.0.0/22(10个主机位)。如图所示，这将提供 1022 个主机地址。</p><p>注意: 172.16.0.0/22 是 IPv4 私有地址空间的一部分。我们使用的是此地址，而不是实际的公有 IPv4 地址。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_25_1.png" alt="网络地址"></p><p>公司总部有一个 DMZ 和四个分支机构，每个分支机构都需要自己的公有 IPv4 地址空间。企业总部需要充分利用有限的IPv4地址空间。</p><p>图中显示的拓扑包括五个站点：一个公司办公室和四个分支站点。每个站点都需要互联网连接，因此需要五个互联网连接。这意味着组织需要来自公司 172.16.0.0/22 公共地址的 10 个子网。最大子网需要 40 个地址。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_25_2.png" alt="具有五个站点的企业拓扑"></p><p>172.16.0.0/22 网络地址有 10 个主机位，如图所示。由于最大子网需要 40 台主机，为 40 台主机提供编址至少需要 6 个主机位。这根据以下公式确定：2^6 -2 = 62 主机。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_25_3.png" alt="子网方案"></p><p>使用公式确定子网数，结果为 16 个子网：24= 16。由于示例中网际网络要求 10 个子网，这一数量可以满足其要求而且允许增加一定数量的子网。</p><p>因此，前 4 个主机位可用于分配子网。这意味着第三个八位组的两个位和第四个八位组的两个位将被借用。当从172.16.0.0/22网络借用 4 个位时，新的前缀长度为 /26，子网掩码为 255.255.255.192。</p><p>如图所示，子网可以分配给每个位置和路由器到路由器的连接。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_25_4.png" alt="为每个站点和 ISP 分配子网"></p><hr><h3 id="IP-地址保留"><a href="#IP-地址保留" class="headerlink" title="IP 地址保留"></a>IP 地址保留</h3><p>由于公有IPv4地址空间的耗尽，所以在对IPv4网络进行子网划分时，充分利用可用的主机地址是主要关注的问题。</p><p>注意: 更大的IPv6地址允许比IPv4更容易的地址规划和分配。保留IPv6地址不是问题。这是向IPv6 过渡的驱动力之一。</p><p>使用传统子网划分，为每个子网分配相同数量的地址。如果所有子网对主机数量的要求相同，或者保留IPv4地址空间不是问题，那么这些固定大小的地址块效率就会很高。通常，对于公有 IPv4 地址，情况并非如此。</p><p>例如，图中显示的拓扑要求七个子网，其中四个子网分别用于四个 LAN，而另外三个分别用于路由器之间的三个连接。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_26_1.png"><p>对指定地址 192.168.20.0/24 进行传统子网划分，从最后一个二进制八位组的主机部分可以借用 3 个位，以满足其七个子网的要求。如图所示，借用 3 个位可以创建 8 个子网，剩余 5 个主机位，每个子网有 30 个可用主机。该方案创建了所需子网，并且满足其最大 LAN 对主机的要求。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_26_2.png" alt="基本子网方案"></p><p>如图所示，这七个子网可以分配给局域网和广域网网络。</p><p>该图显示了由七个子网组成的网络拓扑的子网分配。有四个路由器，每个路由器都有一个连接的局域网和主机编址要求，以及三个路由器到路由器的连接，每个需要 2 个主机。R1 路由器大楼A的局域网有 25 个主机，并分配了子网 192.168.20.0/27。R2 路由器大楼B的局域网有 20 个主机，并分配了子网 192.168.20.32/27。R3 路由器大楼C的局域网有 15 个主机，并分配了子网 192.168.20.64/27。R4 路由器大楼D的局域网有 28 个主机，并分配了子网 192.168.20.96/27。R1 到 R2 的连接分配了子网192.168.20.128/27。R2 到 R3 的连接分配了子网192.168.20.160/27。R3 到 R4 的连接分配了子网192.168.20.192/27。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_26_3.png"><p>虽然该传统子网划分满足最大 LAN 的需要，并将地址空间划分为足够的子网，但它产生了大量未使用地址，造成地址浪费。</p><p>例如，这三个 WAN 链路的每个子网中仅仅需要两个地址。由于每个子网有 30 个可用地址，这些子网中每个子网有 28 个未使用地址。如图所示，这将产生 84 个未使用地址 (28x3)。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_26_4.png" alt="在 WAN 子网中未使用的地址"></p><p>此外，这样做还减少了可用子网的总数，从而限制了未来的发展。这种低效的地址使用率正是传统子网划分的缺点。对示例场景采用传统子网划分方案，效率并不是非常高，而且比较浪费。</p><p>变长子网掩码(VLSM)是为了避免浪费地址而开发的，它使我们能够对子网进行子网划分。</p><hr><h3 id="可变长子网掩码（VLSM，Variable-Length-Subnet-Mask）"><a href="#可变长子网掩码（VLSM，Variable-Length-Subnet-Mask）" class="headerlink" title="可变长子网掩码（VLSM，Variable Length Subnet Mask）"></a>可变长子网掩码（VLSM，Variable Length Subnet Mask）</h3><p>在前面主题的所有子网示例中，所有子网都使用相同的子网掩码。这意味着每个子网有相同数量的可用主机地址。如图左边所示，传统子网划分可以创建大小相等的子网。传统方案中每个子网都使用相同的子网掩码。如图右边所示，VLSM 使网络空间能够分为大小不等的部分。使用 VLSM，子网掩码将根据特定子网所借用的位数而变化，从而成为 VLSM 的“变量”部分。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_27_1.png"><p>VLSM 就是指对子网划分子网。图中显示了以前使用的相同拓扑。同样，我们会使用192.168.20.0/24网络，将其划分为七个子网，其中四个子网用于四个局域网，三个子网用于路由器之间的连接。</p><p>该图显示了由七个子网组成的网络拓扑。有四个路由器，每个路由器都有一个连接的局域网和主机编址要求，以及三个路由器到路由器的连接，每个需要 2 个主机。R1路由器的局域网是有25台主机的大楼A；R2路由器的局域网是有20台主机的大楼B；R3路由器的局域网是有15台主机的大楼C；R4路由器的局域网是有28台主机的大楼D。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_27_2.png"><p>该图显示了网络192.168.20.0/24如何划分成8个大小相等的子网，每个子网有30个可用的主机地址。其中四个子网用于局域网，三个子网可用于路由器之间的连接。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_27_3.png" alt="基本子网划分方案"></p><p>但是，路由器之间的连接每个子网仅需要两个主机地址（每个路由器接口一个主机地址）。目前，所有子网中的每个子网都有 30 个可用的主机地址。为了避免每个子网浪费28个地址，可以使用 VLSM 为 路由器之间的连接创建较小子网。</p><p>为了为路由器之间的链路创建较小子网，将其中一个子网细分。在本示例中，对最后一个子网 192.168.20.224/27 进一步划分子网。该图显示了通过使用子网掩码 255.255.255.252 或 /30 进一步对最后一个子网进行子网划分。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_27_4.png" alt="VLSM 子网划分方案"></p><p>为什么是/30 回想一下，当所需主机地址的数量已知时，可以使用公式 2^n-2（其中 n 等于剩余主机位的数量）。要提供两个可用地址，必须在主机部分保留 2 个主机位。</p><p>因为划分子网的 192.168.20.224/27 地址空间有 5 个主机位，所以可以借用 3 个位，在主机部分保留 2 个位，如图 2 所示。此时的计算与传统子网划分使用的计算完全相同。借用了位，并确定了子网范围。该图显示了如何将四个 /27 子网分配给局域网，将三个 /30 子网分配给路由器之间的链路。</p><p>该图显示了由四个 LAN 和三个 WAN 组成的网络拓扑的VLSM子网分配。有四个路由器，每个路由器都有一个连接的局域网和主机编址要求，以及三个路由器到路由器的连接，每个需要 2 个主机。R1 路由器大楼A的局域网有 25 个主机，并分配了子网 192.168.20.0/27。R2 路由器大楼B的局域网有 20 个主机，并分配了子网 192.168.20.32/27。R3 路由器大楼C的局域网有 15 个主机，并分配了子网 192.168.20.64/27。R4 路由器大楼D的局域网有 28 个主机，并分配了子网 192.168.20.96/27。R1 到 R2 的连接分配了子网192.168.20.224/30。R2 到 R3 的连接分配了子网192.168.20.228/30。R3 到 R4 的连接分配了子网192.168.20.232/30。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_27_5.png"><p>这种 VLSM 子网划分方案将每个子网的地址数目减少到适合需要较少子网的网络的大小。对路由器之间的链路的子网 7 划分子网，使子网 4、5 和 6 能够用于未来网络，而且路由器之间的链路中能够有 5 个额外的子网可用。</p><p>注意: 当使用 VLSM 时，请始终从满足最大子网的主机要求开始。继续子网划分直至满足最小子网的主机要求。</p><hr><h3 id="VLSM-拓扑地址分配"><a href="#VLSM-拓扑地址分配" class="headerlink" title="VLSM 拓扑地址分配"></a>VLSM 拓扑地址分配</h3><p>使用 VLSM 子网，可以为 LAN 和路由器之间网段提供地址，而不产生不必要浪费。</p><p>下图显示了分配给每个路由器接口的网络地址分配和 IPv4 地址。</p><p>该图显示了由四个 LAN 和三个 WAN 组成的网络拓扑的 VLSM 子网分配和接口 IP编址。有四个路由器，每个路由器都有一个连接的局域网和主机编址要求，以及三个路由器到路由器的连接，每个需要 2 个主机。R1 路由器大楼A的局域网连接到了R1的G0/0/0接口，地址是192.168.20.1/27，有 25 个主机，并分配了子网 192.168.20.0/27。R2 路由器大楼B的局域网连接到了R2的G0/0/0接口，地址是192.168.20.33/27，有 20 个主机，并分配了子网 192.168.20.32/27。R3 路由器大楼C的局域网连接到了R3的G0/0/0接口，地址是192.168.20.65/27，有 15 个主机，并分配了子网 192.168.20.64/27。R4 路由器大楼D的局域网连接到了R4的G0/0/0接口，地址是192.168.20.97/27，有 28 个主机，并分配了子网 192.168.20.96/27。R1 至 R2 的连接，分配了子网 192.168.20.224/30，将地址为 .225 的 R1 的 G0/0/1 接口连接到地址为 .226 的 R2 的 G0/0/1 接口。R2 至 R3 的连接，分配了子网 192.168.20.228/30，将地址为 .229 的 R2 的 G0/1/0 接口连接到地址为 .230 的 R3 的 G0/0/1 接口。R3 至 R4 的连接，分配了子网 192.168.20.232/30，将地址为 .233 的 R3 的 G0/1/0 接口连接到地址为 .234 的 R4 的 G0/0/1 接口。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/9_28.png"><p>使用常用编址方案，将每个子网的第一个主机 IPv4 地址分配给路由器的 LAN 接口。每个子网中的主机都将拥有该子网主机地址范围内的一个主机 IPv4 地址和一个合适的掩码。主机将与路由器 LAN 接口相连的地址作为默认网关地址。</p><p>该表显示了每个网络的网络地址和主机地址范围。显示了四个局域网的默认网关地址。</p><table><thead><tr><th align="center">-</th><th align="center">网络地址</th><th align="center">主机地址范围</th><th align="center">默认网关地址</th></tr></thead><tbody><tr><td align="center">大楼 A</td><td align="center">192.168.20.0/27</td><td align="center">192.168.20.1/27 至 192.168.20.30/27</td><td align="center">192.168.20.1/27</td></tr><tr><td align="center">大楼 B</td><td align="center">192.168.20.32/27</td><td align="center">192.168.20.33/27 至 192.168.20.62/27</td><td align="center">192.168.20.1/27</td></tr><tr><td align="center">大楼 C</td><td align="center">192.168.20.64/27</td><td align="center">192.168.20.65/27 至 192.168.20.94/27</td><td align="center">192.168.20.1/27</td></tr><tr><td align="center">大楼 D</td><td align="center">192.168.20.96/27</td><td align="center">192.168.20.97/27 至 192.168.20.126/27</td><td align="center">192.168.20.1/27</td></tr><tr><td align="center">R1至R2</td><td align="center">192.168.20.224/30</td><td align="center">192.168.20.225/30 至 192.168.20.226/30</td><td align="center">\</td></tr><tr><td align="center">R2至R3</td><td align="center">192.168.20.228/30</td><td align="center">192.168.20.229/30 至 192.168.20.230/30</td><td align="center">\</td></tr><tr><td align="center">R3至R4</td><td align="center">192.168.20.232/30</td><td align="center">192.168.20.233/30 至 192.168.20.234/30</td><td align="center">\</td></tr></tbody></table><hr><h2 id="结构化设计"><a href="#结构化设计" class="headerlink" title="结构化设计"></a>结构化设计</h2><h3 id="IPv4网络地址规划"><a href="#IPv4网络地址规划" class="headerlink" title="IPv4网络地址规划"></a>IPv4网络地址规划</h3><p>在开始子网划分之前，您应该为整个网络开发一个 IPv4 编址方案。您要了解您需要多少子网、特定子网需要多少主机、哪些设备是子网的一部分、网络的哪些部分使用私有地址、哪些使用公有地址以及许多其他决定因素。一个良好的编址方案允许增长。一个良好的编址方案也是一个良好的网络管理员的标志。</p><p>IPv4网络子网的规划要求同时分析组织的网络使用需求和子网的构建方法。进行网络需求调研是子网规划的起点。这意味着查看整个网络，包括内部网和DMZ，并确定如何划分每个区域。地址计划包括确定哪里需要地址保留(通常在DMZ中)，哪里有更大的灵活性(通常在内部网中)。</p><p>如果需要地址保留，计划应确定需要多少个子网以及每个子网有多少个主机。如前所述，这通常是DMZ中的公有IPv4地址空间所需要的。这很可能包括使用 VLSM。</p><p>在企业内部网中，地址保留通常不是问题，这主要是由于使用私有IPv4编址，包括10.0.0.0/8，有超过1600万个主机IPv4地址。</p><p>对于大多数组织，私有 IPv4 地址允许提供足够多的内部（内部网）地址。对于许多较大的组织和ISP来说，即使是私有的IPv4地址空间也不足以满足它们的内部需求。这也是组织向 IPv6 过渡的另一个原因。</p><p>对于使用私有 IPv4 地址的内部网和使用公有 IPv4 地址的 DMZ，地址规划和分配非常重要。</p><p>在需要时，地址计划包括根据大小确定每个子网的需要。每个子网将有多少台主机地址计划还需要包括如何分配主机地址，哪些主机要求静态 IPv4 地址和哪些主机可以使用 DHCP 获取其编址信息的需求。这也将有助于防止地址重复，同时允许出于性能和安全原因对地址进行监测和管理。</p><p>了解您的IPv4地址需求将确定您实施的主机地址的范围，并帮助确保有足够的地址满足您的网络需求。</p><hr><h3 id="设备地址分配"><a href="#设备地址分配" class="headerlink" title="设备地址分配"></a>设备地址分配</h3><p>在一个网络中，有不同类型的设备需要分配地址：</p><ul><li><p><strong>终端用户客户端</strong> – 大部分网络使用动态主机配置协议 (DHCP)动态地将IPv4地址分配给客户端设备。这能减少网络支持人员的负担，并显著减少输入错误。使用 DHCP 时，地址仅租用一段时间，并且可以在租约到期时重新使用。这是支持临时用户和无线设备的网络的一个重要特性。更改子网划分方案意味着 DHCP 服务器需要进行重新配置，并且客户端必须续订其 IPv4 地址。IPv6 客户端可以使用 DHCPv6 或 SLAAC 获取地址信息。</p></li><li><p><strong>服务器和外部设备</strong> - 这些应具有可预测的静态 IP 地址。对这些设备使用统一的编号系统。</p></li><li><p><strong>可从互联网访问的服务器</strong> - 需要在互联网上公开可用的服务器必须具有公有 IPv4 地址，通常使用 NAT 访问。在一些组织中，必须使远程用户可以使用内部服务器(不可公开使用)。在大多数情况下，这些服务器在内部分配了私有地址，用户需要创建一个虚拟专用网络 (VPN) 连接来访问服务器。这与用户从内部网中的主机访问服务器具有相同的效果。</p></li><li><p><strong>中间设备</strong> – 这些设备出于网络管理、监视和安全目的分配了地址。因为我们必须知道如何与中间设备通信，所以它们应当具有可以预测的静态地址。</p></li><li><p><strong>网关</strong> - 路由器和防火墙设备给每个接口分配一个 IP 地址，用作该网络中主机的网关。路由器接口一般使用网络中的最小地址或最大地址。</p></li></ul><p>在制定 IP 编址方案时，通常建议您使用一种固定模式为各类设备分配地址。这样有益于管理员添加和删除设备、根据 IP 过滤流量和简化文档。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>IPv4地址结构</li></ul><blockquote><p>IPv4 地址为32位分层地址，由网络部分和主机部分两个部分组成。对于同一网络中的所有设备，地址的网络部分中的位必须完全相同。地址的主机部分中的位必须唯一，这方便识别网络中的特定主机。主机需要唯一的 IPv4 地址和子网掩码来显示地址的网络/主机部分。前缀长度是子网掩码中设置为 1 的位数。使用“斜线记法”写入，即“/”紧跟设置为 1 的位数。逻辑 AND 运算比较两个位。只有 1 AND 1 生成 1，任何其他组合都会产生 0。任何其他组合都会产生 0。每个网络中都有网络地址、主机地址和广播地址。</p></blockquote><ul><li>IPv4单播、广播和组播</li></ul><blockquote><p>单播传输是指在一对一通信中，一个设备向另一个设备发送消息。单播数据包是具有目的IP 地址的数据包，该 IP 地址是单个收件人的单播地址。广播播传输是指设备在一对多通信中，向网络上的所有设备发送消息。广播数据包以主机部分全部为 1 的地址或32个1位作为目的 IP地址。主机通过组播传输可以向所属组播组中的选定主机组发送一个数据包，从而减少了流量。组播数据包是一个目的IP地址为组播地址的数据包。IPv4 将 224.0.0.0 到 239.255.255.255 的地址保留为组播范围。</p></blockquote><ul><li>IPv4地址类型</li></ul><blockquote><p>公有 IPv4 地址能在 ISP路由器之间进行全局路由。并非所有可用的 IPv4 地址都可用于互联网。大多数组织使用称为私有地址的地址块向内部主机分配 IPv4 地址。大多数内部网络使用私有IPv4地址来编址所有内部设备(内部网);然而，这些私有地址不可全局路由。主机使用环回地址将流量引导回自己。本地链接地址通常称为 APIPA 地址或自行分配地址。1981 年，IPv4 地址是使用有类编址分配的：A类、B类 或 C类。公有 IPv4 地址必须是唯一的，并且通过互联网全局路由。IPv4 和 IPv6 地址均由 IANA 管理，IANA 将 IP 地址块分配给 RIR。</p></blockquote><ul><li>网络分段</li></ul><blockquote><p>在以太网局域网中，设备广播使用ARP定位其他设备。交换机会将广播传播到所有接口，接收它的接口除外。路由器不传播广播，而是每个路由器接口都连接了一个广播域，而广播只能在特定域内传播。大型广播域是连接很多主机的网络。大型广播域的一个问题是这些主机会生成太多广播，这会对网络造成不良影响。解决方案是使用称为“子网划分”的过程缩减网络的规模以创建更小的广播域。这些较小的网络空间通常称为“子网”。子网划分可以降低整体网络流量并改善网络性能。管理员可以根据位置、网络之间或设备类型划分子网。</p></blockquote><ul><li>IPv4网络的子网</li></ul><blockquote><p>创建 IPv4 子网时会将一个或多个主机位作为网络位。具体做法是延长子网掩码，从地址的主机部分借用若干位来增加网络位。借用的主机位越多，可以定义的子网也就越多。借来增加子网数量的比特越多也会减少每个子网的主机数量。网络在二进制八位数边界 /8、/16 和 /24 处最容易进行子网划分。子网可以从任何主机位借用位来创建其他掩码。</p></blockquote><ul><li>使用/16和/8前缀划分子网</li></ul><blockquote><p>在要求较多子网的情况下，需要 IPv4 网络有更多主机位可以借用。为了创建子网，我们必须从现有互联网络 IPv4 地址的主机部分借用位。从第一个可用主机位开始从左到右借用，一次借用一位，直到达到创建所需子网数量的位数。当从 /16 地址借用位时，从借用第三个二进制八位数开始，并遵循从左向右的顺序。第一个地址保留给网络地址，最后一个地址保留给广播地址。</p></blockquote><ul><li>满足需求的子网划分</li></ul><blockquote><p>典型的企业网络包含内部网和 DMZ。两者都有子网划分要求和挑战。内部网使用私有 IPv4 编址空间。10.0.0.0/8还可以使用任何其他前缀长度的数字进行子网划分，如/12、/18、/20等。这将为网络管理员提供多种选择。因为这些设备需要从互联网公开访问，所以DMZ中的设备需要公有IPv4地址。组织必须最大限度地提高其自身有限数量的公有 IPv4 地址。要减少每个子网的未使用主机地址数，网络管理员将其公有地址空间划分到具有不同子网掩码的子网中。这称为可变长子网掩码 (VLSM)。管理员必须考虑每个网络需要多少个主机地址以及需要多少个子网。</p></blockquote><ul><li>VLSM</li></ul><blockquote><p>传统的子网划分可以满足组织对其最大局域网的需要，并将地址空间划分为足够数量的子网。但它也可能导致大量未使用地址的浪费。VLSM 使网络空间能够分为大小不等的部分。使用 VLSM，子网掩码将根据特定子网所借用的位数而变化，这是 VLSM 的“变量”部分。VLSM 就是指对子网划分子网。当使用 VLSM 时，请始终从满足最大子网的主机要求开始。继续子网划分直至满足最小子网的主机要求。子网划分始终需要在适当的位边界上启动。</p></blockquote><ul><li>结构化设计</li></ul><blockquote><p>网络管理员应该研究网络需求，以便更好地规划IPv4网络子网的结构。这意味着查看整个网络，包括内部网和DMZ，并确定如何划分每个区域。地址计划包括确定哪里需要地址保留(通常在DMZ中)，哪里有更大的灵活性(通常在内部网中)。需要保护地址的位置，计划应确定每个子网需要多少个子网以及多少个主机。这通常是DMZ中的公有IPv4地址空间所需要的。这很可能包括使用 VLSM。地址计划包括如何分配主机地址，哪些主机要求静态 IPv4 地址和哪些主机可以使用 DHCP 获取其编址信息的需求。在网络中，有不同类型的设备需要地址：最终用户客户端、服务器和外部设备、可从互联网访问的服务器、中间设备和网关。在制定 IP 编址方案时，使用一种固定模式为各类设备分配地址。这有助于添加和删除设备、根据 IP 过滤流量和简化文档。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理 • （七）应用层</title>
      <link href="School-Computer-Network-Technology-7-Application-Layer/"/>
      <url>School-Computer-Network-Technology-7-Application-Layer/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇是对<a href="https://phoenixnest.github.io/Notes-Computer-Network-Technology/">计算机网络原理</a>一文中的<a href="https://phoenixnest.github.io/School-Computer-Network-Technology/#%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%88%E7%AC%AC-7-%E5%B1%82%EF%BC%89">应用层</a>的详细介绍。<br>所用教学平台：<a href="%22https://cn.netacad.com/%22">Cisco Networking Academy</a></p></blockquote><hr><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>在OSI和TCP/IP 模型中的应用层最接近最终用户。如图所示，该层为用于通信的应用程序和用于消息传输的底层网络提供接口。应用层协议用于在源主机和目的主机上运行的程序之间进行数据交换。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_1.png"><p>基于TCP/IP模型，OSI 模型上面三层（应用层、表示层和会话层）定义了 TCP/IP 应用层的功能。</p><p>目前已有很多种应用层协议，而且人们还在不断开发新的协议。某些最广为人知的应用层协议包括超文本传输协议(HTTP)、文件传输协议 (FTP)，简单文件传输协议 (TFTP)，互联网邮件访问协议 (IMAP) 和域名系统 (DNS) 协议。</p><hr><h3 id="TCP-IP-应用层协议"><a href="#TCP-IP-应用层协议" class="headerlink" title="TCP/IP 应用层协议"></a>TCP/IP 应用层协议</h3><p>TCP/IP 应用层协议指定了许多常见互联网通信功能必需的格式和控制信息。在通信会话过程中，源设备和目的设备均使用应用层协议。为确保通信畅通，源主机和目的主机上所实现的应用层协议必须一致。</p><blockquote><p><strong>域名系统</strong></p></blockquote><p><code>DNS - 域名系统（或服务）</code></p><ul><li><p>TCP,UDP客户端 53</p></li><li><p>将域名（例如 cisco.com）转换为 IP 地址。</p></li></ul><blockquote><p><strong>主机配置</strong></p></blockquote><p><code>BOOTP - 引导程序协议</code></p><ul><li><p>UDP 客户端 68，服务器 67</p></li><li><p>允许无盘工作站探查其 IP 地址、网络中 BOOTP 服务器的 IP 地址以及要加载到内存中以引导机器的文件</p></li><li><p>BOOTP 正在被 DHCP 所取代</p></li></ul><p><code>DHCP - 动态主机配置协议</code></p><ul><li><p>UDP 客户端 68，服务器 67</p></li><li><p>动态分配IP地址可以重复使用不再需要的地址</p></li></ul><blockquote><p><strong>电子邮箱</strong></p></blockquote><p><code>SMTP - 简单邮件传输协议</code></p><ul><li><p>TCP 25</p></li><li><p>允许客户端向邮件服务器发送电子邮件</p></li><li><p>允许服务器向其他服务器发送电子邮件</p></li></ul><p><code>POP3 - 邮局协议</code></p><ul><li><p>TCP 110</p></li><li><p>允许客户端从邮件服务器检索电子邮件 将电子邮件* 下载到客户端的本地邮件应用程序</p></li></ul><p><code>IMAP - 互联网消息访问协议</code></p><ul><li><p>TCP 143</p></li><li><p>允许客户端访问存储在邮件服务器中的电子邮件</p></li><li><p>在服务器上维护电子邮件</p></li></ul><blockquote><p><strong>文件传输</strong></p></blockquote><p><code>FTP - 文件传输协议</code></p><ul><li><p>TCP 20至21</p></li><li><p>设置规则，使得一台主机上的用户能够通过网络访问另一台主机或向其传输文件</p></li><li><p>FTP是一种可靠、面向连接且进行确认的文件传输协议。</p></li></ul><p><code>TFTP - 简单文件传输协议</code></p><ul><li><p>UDP 客户端 69</p></li><li><p>一个简单的，无连接的文件传输协议，使用尽最大努力、不被答复的文件交付</p></li><li><p>它使用的开销比FTP少</p></li></ul><blockquote><p><strong>Web</strong></p></blockquote><p><code>HTTP - 超文本传输协议</code></p><ul><li><p>TCP 80,8080</p></li><li><p>有关在万维网上交换文本、图形图像、音频、视频以及其他多媒体文件的一组规则集</p></li></ul><p><code>HTTPS - 安全 HTTP</code></p><ul><li><p>TCP，UDP 443</p></li><li><p>浏览器使用加密技术保护 HTTP 通信</p></li><li><p>验证您的浏览器连接的网站</p></li></ul><hr><h2 id="对等体到对等体"><a href="#对等体到对等体" class="headerlink" title="对等体到对等体"></a>对等体到对等体</h2><h3 id="客户端（Client）-服务器（Server）模式"><a href="#客户端（Client）-服务器（Server）模式" class="headerlink" title="客户端（Client） - 服务器（Server）模式"></a>客户端（Client） - 服务器（Server）模式</h3><p>在前面的主题中，您了解了在源和目的主机上实现的TCP/IP应用层协议必须是兼容的。在本主题中，您将了解应用层中的客户端/服务器模式和使用的流程。对等网络也是如此。在客户端-服务器模型中，请求信息的设备称为客户端，而响应请求的设备称为服务器。 客户端是一个硬件/软件的组合，人们使用它来直接访问存储在服务器上的资源。</p><p>客户端进程和服务器进程都处于应用层。客户端首先向服务器发送数据请求，服务器通过发送一个或多个数据流来响应客户端。应用层协议规定了客户端和服务器之间请求和响应的格式。除了实际数据传输外，数据交换过程还要求用户身份验证以及要传输的数据文件的标识。</p><p>客户端-服务器网络的一个示例是使用 ISP 的电子邮件服务发送、接收和存储电子邮件。家用计算机的电子邮件客户端向 ISP 的电子邮件服务器请求所有未读邮件。随后服务器向客户端发送被请求的邮件以示响应。从客户端到服务器的数据传输称为上传；而从服务器到客户端的数据传输则称为下载。</p><p>如图所示，文件从服务器下载到客户端。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_2.png"><hr><h3 id="对等网络"><a href="#对等网络" class="headerlink" title="对等网络"></a>对等网络</h3><p>在对等 (P2P) 网络模式中，可以从对等设备访问数据，而无需使用专用服务器。</p><p>P2P 网络模型包含两个部分：P2P 网络和 P2P 应用程序。这两个部分具有相似的特征，但实际工作过程却大不相同。</p><p>在 P2P 网络中，两台或多台计算机通过网络互连，它们共享资源(如打印机和文件)时可以不借助专用服务器。每台接入的终端设备（称为“对等体”）既可以作为服务器，也可以作为客户端。在某项事务中，作为服务器的计算机也可以同时成为其他服务器的客户端。于是，计算机的角色根据请求的不同在客户端和服务器之间切换。</p><p>除共享文件外，这样一个网络还允许用户启用网络游戏，或者共享互联网连接。</p><p>在对等交换中，两台设备在通信过程中处于平等地位。对等体1拥有与对等体2共享的文件，并且可以访问直接连接到对等体2的共享打印机来打印文件。对等体2正在与对等体1共享直接连接的打印机，同时访问对等体1上的共享文件，如图所示。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_3.png"><hr><h3 id="点对点应用"><a href="#点对点应用" class="headerlink" title="点对点应用"></a>点对点应用</h3><p>如图所示，对等 (P2P) 应用程序允许设备在同一通信中同时充当客户端和服务器。在该模型中，每台客户端都是服务器，而每台服务器也同时是客户端。P2P 应用程序要求每台终端设备提供用户界面并运行后台服务。</p><p>某些 P2P 应用程序中采用混合系统，即共享的资源是分散的，但指向资源位置的索引存储在集中目录中。在混合系统中，每台对等设备通过访问索引服务器获取存储在另一台对等设备中的资源位置。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_4.png"><hr><h3 id="常见对等应用程序"><a href="#常见对等应用程序" class="headerlink" title="常见对等应用程序"></a>常见对等应用程序</h3><p>使用 P2P 应用程序时，网络中运行该应用程序的每台计算机都可以充当在网络中运行该应用程序的其他计算机的客户端或服务器。常见 P2P 网络包括:</p><ul><li><p>BitTorrent</p></li><li><p>Direct Connect</p></li><li><p>eDonkey</p></li><li><p>Freenet</p></li></ul><p>某些 P2P 应用程序基于 Gnutella 协议，允许每个用户与他人共享整个文件。如图所示，通过与 Gnutella 协议兼容的客户端软件，用户可以在互联网上连接 Gnutella 服务，然后定位并访问由其他 Gnutella 对等设备共享的资源。许多Gnutella客户机应用程序可用,包括μTorrent,BitComet, DC++, Deluge, 和emule。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_5.png"><p>许多 P2P 应用程序允许用户同时相互分享许多文件片段。客户端使用一个torrent文件查找其他拥有其所需片段的用户，以便可以稍后直接连接到他们。此文件还包含有关跟踪计算机的信息，跟踪哪些用户拥有某些文件的特定片段。客户端同时需要多个用户的文件片段。这被称为集群且该技术称为 BitTorrent。BitTorrent 有其自己的客户端。但有许多其他的 BitTorrent 客户端，包括uTorrent、Deluge 和 qBittorrent。</p><p>注意: 用户间可以分享任何类型的文件。这些文件中的许多是有版权的，这意味着只有创建者有使用和分发它们的权利。未得到版权持有者许可下载或分发有版权的文件是违法的。侵害版权会导致刑事起诉或民事诉讼。</p><hr><h2 id="Web-和电子邮件协议"><a href="#Web-和电子邮件协议" class="headerlink" title="Web 和电子邮件协议"></a>Web 和电子邮件协议</h2><h3 id="超文本传输协议和超文本标记语言"><a href="#超文本传输协议和超文本标记语言" class="headerlink" title="超文本传输协议和超文本标记语言"></a>超文本传输协议和超文本标记语言</h3><p>有些应用层特定的协议是为web浏览和电子邮件等常见用途设计的。第一个主题概述了这些协议。本主题将进一步详细介绍。</p><p>当在 Web 浏览器中输入一个 Web 地址或统一资源定位符 (URL) 时，Web 浏览器将与Web 服务建立连接。Web 服务正在使用 HTTP 协议的服务器上运行。一提到 Web 地址，大多数人往往想到 URL 以及统一资源标识符 (URI)。</p><hr><p>以下展示浏览器如何打开网页：</p><blockquote><p>步骤 1</p></blockquote><p>浏览器对 URL 地址的三个组成部分进行分析：</p><ul><li><p>http（协议或方案）</p></li><li><p><code>www.cisco.com</code>（服务器名称）</p></li><li><p>index.html（所请求的特定文件名）</p></li></ul><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_6_1.png"><hr><blockquote><p>步骤 2</p></blockquote><p>然后，浏览器将通过域名服务器将 <a href="http://www.cisco.com/">www.cisco.com</a> 转换成数字表示的 IP 地址，用它连接到该服务器。客户端通过向服务器发送GET请求向服务器发起一个HTTP请求并请求index.html文件。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_6_2.png"><hr><blockquote><p>步骤 3</p></blockquote><p>作为对请求的响应，服务器将此web页面的HTML代码发送到浏览器。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_6_3.png"><hr><blockquote><p>步骤 4</p></blockquote><p>浏览器解译 HTML 代码并为浏览器窗口格式化页面。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_6_4.png"><hr><h3 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h3><p>HTTP 是一种请求/响应协议。当客户端，尤其是 Web 浏览器，发送请求到 Web 服务器时，HTTP 将指定用于该通信的消息类型。常用的三种消息类型包括 GET（见图）、POST 和 PUT。</p><ul><li><p>GET - 客户端请求数据。客户端（Web 浏览器）向 Web 服务器发送 GET 消息以请求 HTML 页面。</p></li><li><p>POST - 上传数据文件到 Web 服务器，例如表单数据。</p></li><li><p>PUT - 用于向 Web 服务器上传资源或内容，例如图像。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_7.png"><p>尽管 HTTP 灵活性相当高，但它不是一个安全协议。由于请求消息以明文形式向服务器发送信息，它非常容易被拦截和解读。服务器的响应（尤其是 HTML 页面）也不加密。</p><p>为了在互联网中进行安全通信，人们使用 HTTP 安全（HTTPS）协议。HTTPS 借助身份验证和加密来保护数据，使数据得以安全地在客户端与服务器之间传输。HTTPS 使用的客户端请求服务器响应过程与 HTTP 相同，但在数据流通过网络传输以前会使用安全套接字层 (SSL) 加密。</p><hr><h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h3><p>电子邮件托管是 ISP 提供的主要服务之一。如果要在计算机或其他终端设备上运行电子邮件，仍然需要多种应用程序和服务，如图所示。邮件是通过网络发送、存储和检索电子消息的存储转发方法。邮件消息存储在邮件服务器的数据库中。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_8.png"><p>邮件客户端通过与邮件服务器通信来收发邮件。邮件服务器之间也会互相通信，以便将邮件从一个域发到另一个域中。也就是说，发送邮件时，邮件客户端并不会直接与另外一个邮件客户端通信。而是双方客户端均依靠邮件服务器来传输邮件。</p><p>电子邮件支持三种单独的协议以实现操作：简单邮件传输协议 (SMTP)、邮局协议 (POP) 和 Internet 邮件访问协议 (IMAP)。发送邮件的应用层进程会使用 SMTP。客户端会使用以下两种应用层协议之一来检索邮件：POP 或 IMAP。</p><hr><h3 id="SMTP、POP-和-IMAP"><a href="#SMTP、POP-和-IMAP" class="headerlink" title="SMTP、POP 和 IMAP"></a>SMTP、POP 和 IMAP</h3><blockquote><p>SMTP</p></blockquote><p>SMTP 邮件格式要求邮件具有报头和正文。虽然邮件正文没有长度限制，但邮件报头必须具有格式正确的收件人邮件地址和发件人地址。</p><p>当客户端发送邮件时，客户端 SMTP 进程会连接公认端口 25 上的服务器 SMTP 进程。连接建立后，客户端将尝试通过此连接发送邮件到服务器。服务器收到邮件后，如果收件人在本地，它会将邮件保存在本地账户中，或者将邮件转发给另一台邮件服务器以便传输。</p><p>发出邮件时，目的邮件服务器可能并不在线，或者正忙。因此，SMTP 将邮件转到后台处理，稍后再发送。服务器会定期检查邮件队列，然后尝试再次发送。经过预定义的过期时间后，如果仍然无法发送邮件，则会将其作为无法投递的邮件退回给发件人。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_9_1.png"><hr><blockquote><p>PoP</p></blockquote><p>应用程序使用 POP 从邮件服务器中检索邮件。根据 POP 的规定，邮件将从服务器下载到客户端，然后从服务器上删除。这是 POP 的默认操作。</p><p>服务器通过在 TCP 端口 110 上被动侦听客户端连接请求来启动 POP 服务。当客户端要使用此服务时，它会发送一个请求来建立与服务器的 TCP 连接，如图所示。一旦建立连接，POP 服务器即会发送问候语。然后客户端和 POP 服务器会交换命令和响应，直到连接关闭或中止。</p><p>根据 POP，由于电子邮件会下载到客户端并从服务器删除，因此电子邮件不会集中保存在某一特定的位置。因为 POP 不存储邮件，因此不建议用于需要集中备份解决方案的小型企业。</p><p>POP3 是最常用的版本。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_9_2.png"><hr><blockquote><p>IMAP</p></blockquote><p>IMAP 是另外一种用于检索电子邮件消息的协议。与 POP 不同的是，当用户连接使用 IMAP 的服务器时，邮件的副本会下载到客户端应用程序，如图所示。同时原始邮件会一直保留在服务器上，直到用户将它们手动删除。用户在自己的邮件客户端软件中查看邮件副本。</p><p>用户可以在服务器上创建文件层次结构来组织和保存邮件。该文件结构会照搬到邮件客户端。当用户决定删除邮件时，服务器会同步该操作，从服务器上删除对应的邮件。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_9_3.png"><hr><h2 id="IP-编址服务"><a href="#IP-编址服务" class="headerlink" title="IP 编址服务"></a>IP 编址服务</h2><h3 id="域名服务"><a href="#域名服务" class="headerlink" title="域名服务"></a>域名服务</h3><p>还有其他应用层特定的协议，它们被设计可以更容易地获取网络设备的地址。这些服务是必不可少的，因为记住 IP 地址而不是 URL 或手动配置中大型网络中的所有设备将非常耗时。本模块的第一个主题为您介绍了这些协议。本主题将详细介绍 IP 编址服务、DNS 和 DHCP。</p><p>在数据网络中，使用数字 IP 地址标记设备以便通过网络发送和接收数据。人们创建了可以将数字地址转换为简单易记名称的域名系统。</p><p>在互联网上，更便于人们记忆的是 “<a href="http://www.cisco.com&quot;/">http://www.cisco.com&quot;</a> 这样的完全限定域名，而不是该服务器的实际数字 IP 地址 198.133.219.25。如果思科决定更改 <a href="http://www.cisco.com/">www.cisco.com</a> 的数字地址，那么更改对用户是透明的，因为域名将保持不变。公司只需要将新地址与现有域名链接起来即可保证连通性。</p><p>DNS 协议定义了一套自动化服务，该服务将资源名称与所需的数字网络地址匹配。协议涵盖了查询格式、响应格式及数据格式。DNS 协议通信采用单一格式，即消息格式。该格式用于所有类型的客户端查<br>询和服务器响应、报错消息、以及服务器间的资源记录信息的传输。</p><hr><p>以下展示域名解析过程：</p><blockquote><p>步骤 1</p></blockquote><p>用户在浏览器应用程序地址字段中输入 FQDN（Fully Qualified Domain Name，全限定域名）。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_10_1.png"><hr><blockquote><p>步骤 2</p></blockquote><p>一个DNS 查询发送到客户端计算机的指定 DNS 服务器。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_10_2.png"><hr><blockquote><p>步骤 3</p></blockquote><p>DNS 服务器将 FQDN 与其 IP 地址匹配。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_10_3.png"><hr><blockquote><p>步骤 4</p></blockquote><p>DNS 查询响应将FQDN 的 IP 地址发送回客户端。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_10_4.png"><hr><blockquote><p>步骤 5</p></blockquote><p>客户端计算机使用IP地址向服务器发出请求。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_10_5.png"><hr><h3 id="DNS-消息格式"><a href="#DNS-消息格式" class="headerlink" title="DNS 消息格式"></a>DNS 消息格式</h3><p>DNS 服务器中存储不同类型的资源记录，用来解析域名。这些记录中包含域名、地址以及记录的类型。这些记录有以下类型：</p><ul><li><p><strong>A</strong> - 终端设备 IPv4 地址</p></li><li><p><strong>NS</strong> - 授权域名服务器</p></li><li><p><strong>AAAA</strong> - 终端设备 IPv6 地址（读作“四 A”）</p></li><li><p><strong>MX</strong> - 邮件交换记录</p></li></ul><p>在客户端进行查询时，服务器 DNS 进程首先会查看自己的记录以解析名称。如果服务器不能通过自身存储的记录解析域名，它将联系其他服务器对该域名进行解析。在检索到匹配信息并将其返回到原始请求服务器后，服务器临时存储数字地址，以供再次请求同一域名时使用。</p><p>Windows PC 上的 DNS 客户端服务还可存储以前在内存中解析的域名。ipconfig /displaydns命令显示所有 DNS 缓存条目。</p><p>如表中所示，DNS在服务器间使用相同的消息格式，包含所有类型的客户端查询的问题、回答、授权和更多信息以及服务器响应、错误消息和服务器间的资源记录信息的传输。</p><table><thead><tr><th align="center">DNS 消息部分</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">问题</td><td align="center">向域名服务器提出的问题</td></tr><tr><td align="center">回答</td><td align="center">回答该问题的资源记录</td></tr><tr><td align="center">权限（Authority）</td><td align="center">指向权限的资源记录</td></tr><tr><td align="center">更多</td><td align="center">包含其他信息的资源记录</td></tr></tbody></table><hr><h3 id="DNS-层级"><a href="#DNS-层级" class="headerlink" title="DNS 层级"></a>DNS 层级</h3><p>DNS 协议采用分层系统创建数据库以提供名称解析，如图所示。DNS 使用域名来划分层次。</p><p>域名结构被划分为多个更小的受管域。每台 DNS 服务器维护着特定的数据库文件，而且只负责管理 DNS 结构中那一小部分的“域名-IP”映射。当 DNS 服务器收到的域名转换请求不属于其所负责的 DNS 区域时，该 DNS 服务器可将请求转发到与该请求对应的区域中的 DNS 服务器进行转换。DNS 具有可扩展性，这是因为主机名解析分散于多台服务器上完成。</p><p>不同的顶级域有不同的含义，分别代表着组织类型或起源国家/地区。请参见以下顶级域示例：</p><ul><li><p>.com - 商业或行业</p></li><li><p>.org - 非营利组织</p></li><li><p>.cn - 中国</p></li></ul><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_11.png"><hr><h3 id="nslookup-命令"><a href="#nslookup-命令" class="headerlink" title="nslookup 命令"></a>nslookup 命令</h3><p>我们通常在配置网络设备时提供一个或者多个 DNS 服务器地址，DNS 客户端可以使用该地址进行域名解析。ISP往往会为 DNS 服务器提供地址。当用户应用程序请求通过域名连入远程设备时，DNS 客户端将向某一域名服务器请求查询，获得域名解析后的数字地址。</p><p>用户还可以使用操作系统中名为 Nslookup 的实用程序手动查询域名服务器，来解析给定的主机名。该实用程序也可以用于检修域名解析故障，以及验证域名服务器的当前状态。</p><p>在图中，发出nslookup命令后，即显示为主机配置的默认 DNS 服务器。可以在nslookup提示符下输入主机名或域名。Nslookup 实用程序还有很多选项，可以用于大量测试以及 DNS 进程验证。</p><pre><code class="bash"># 在 Windows 命令提示符中，输入nslookup命令开始名称服务器的手动查询。C:\&gt;nslookupDefault Server: UnknownAddress: 10.10.10.1# 输出列出了在客户端配置的 DNS 服务器的名称和 IP 地址。注意 DNS 服务器地址可以手动配置也可以通过DHCP 动态获取。您现在处于 nslookup 模式。输入域名 www.cisco.com。&gt;www.cisco.comServer:  UnKnownAddress:  10.10.10.1Non-authoritative answer:Name:    e2867.dsca.akamaiedge.netAddresses:  2600:1404:a:395::b33            2600:1404:a:38e::b33            172.230.155.162Aliases:  www.cisco.com          www.cisco.com.akadns.net          wwwds.cisco.com.edgekey.net          wwwds.cisco.com.edgekey.net.globalredir.akadns.net# 输出列出了服务器“e2867”目前在其数据库中与 “www.cisco.com” 相关的 IP 地址。注意，还列出了 IPv6 地址。此外，还显示了将解析为 “www.cisco.com” 的各种别名。# 输入exit命令退出 nslookup 模式并返回 Windows 命令行。&gt;exit</code></pre><hr><h3 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h3><p>IPv4 服务的动态主机配置协议 (DHCP) 会自动分配 IPv4 地址、子网掩码、网关以及其他 IPv4 网络参数。这称为动态编址。动态编址的替代选项是静态编址。在使用静态编址时，网络管理员在主机上手动输入 IP 地址信息。</p><p>主机连入网络时，将联系 DHCP 服务器并请求地址。DHCP 服务器从已配置地址范围（也称为“地址池”）中选择一条地址，并将其分配（租赁）给主机。</p><p>在较大型的网络中，或者用户经常变更的网络中，地址分配优先选用 DHCP。新用户可能在到达时需要连接；其他用户可能有新计算机必须要连接。与为每个连接使用静态编址的做法相比，采用 DHCP 自动分配 IPv4 地址的方法更有效。</p><p>DHCP可以在一段可配置的时间内分配IP地址，这段时间称为租期。租期是一个重要的 DHCP 设置，当租期过期或 DHCP 服务器收到 DHCPRELLAME 消息时，地址将返回到 DHCP 池以便重复使用。因此，用户可以自由的移动位置，并通过DHCP随时重新连接网络。</p><p>如图所示,很多类型的设备都可以成为 DHCP 服务器。在大多数中型到大型网络中，DHCP 服务器通常都是基于 PC 的本地专用服务器。在家庭网络中，DHCP 服务器通常位于本地路由器，将家庭网络连接到 ISP。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_13.png"><p>很多网络都同时采用 DHCP 和静态编址。DHCP 用于一般用途主机，例如用户终端设备。静态编址用于网络设备，例如网关路由器、交换机、服务器和打印机。</p><p>IPv6 的 DHCP（DHCPv6）为 IPv6 客户端提供类似服务。一个重要的不同是，DHCPv6 不会提供默认网关地址。这只能从路由器的 Router Advertisement（路由器通告）消息中动态获得。</p><hr><h3 id="DHCP-工作原理"><a href="#DHCP-工作原理" class="headerlink" title="DHCP 工作原理"></a>DHCP 工作原理</h3><p>如图所示，配置了 DHCP 的 IPv4 设备在启动或连接到网络时，客户端将广播一条 DHCP 发现 (DHCPDISCOVER) 消息以确定网络上是否有可用 DHCP 服务器。DHCP 服务器回复 DHCP 服务 (DHCPOFFER) 消息，为客户端提供租赁服务。该服务消息包含为其分配的 IPv4 地址和子网掩码、DNS 服务器的 IPv4 地址和默认网关的 IPv4 地址。租赁服务还包括租用期限。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_14.png"><p>如果本地网络中有超过一台 DHCP 服务器，客户端可能会收到多条 DHCPOFFER 消息。此时，客户端必须在这些服务器中进行选择，并且将包含服务器标识信息及客户端所接受的租赁服务的 DHCP 请求 (DHCPREQUEST) 消息发送出去。客户端还可选择向服务器请求分配以前分配过的地址。</p><p>如果客户端请求的 IPv4 地址（或者服务器提供的 IPv4 地址）仍然可用，服务器将返回 DHCP 确认 (DHCPACK) 消息，向客户端确认地址租赁。如果请求的地址不再有效，则所选服务器将回复一条 DHCP 否定确认 (DHCPNAK) 消息。一旦返回 DHCP NAK 消息，应重新启动选择进程，并重新发送新的 DHCP 发现消息。客户端租赁到地址后，应在租期结束前发送 DHCPREQUEST 消息进行续期。</p><p>DHCP 服务器确保每个 IP 地址都是唯一的（一个 IP 地址不能同时分配到不同的网络设备上）。因此，大多数ISP往往使用 DHCP 为其客户分配地址。</p><p>DHCPv6 有一组与DHCPv4 类似的消息。DHCPv6 消息包括 SOLICIT、ADVERTISE、INFORMATION REQUEST 和 REPLY。</p><hr><h2 id="文件共享服务"><a href="#文件共享服务" class="headerlink" title="文件共享服务"></a>文件共享服务</h2><h3 id="文件传输协议"><a href="#文件传输协议" class="headerlink" title="文件传输协议"></a>文件传输协议</h3><p>正如您在前面的主题中了解到的，在客户端/服务器模式中，如果两个设备都使用文件传输协议(FTP)，客户端可以将数据上传到服务器，并从服务器下载数据。与 HTTP、电子邮件和编址协议一样，FTP 是常用的应用层协议。本主题将更详细地讨论 FTP。</p><p>FTP 用于客户端和服务器之间的数据传输。FTP 客户端是一种在计算机上运行的应用，用于从 FTP 服务器中收发数据。</p><p>该图描绘了一个 FTP 传输。客户端通过网络与服务器联系。来自客户端的第一条消息是控制连接：客户端向服务器开放第一条连接，用于控制流量。来自客户端的第二条消息是数据连接：客户端开放第二个连接用于流量数据。客户端使用 “获取数据” 命令从服务器请求数据。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_15.png"><p>客户端使用 TCP 端口 21 与服务器建立第一个连接用于控制流量。流量由客户端命令和服务器应答组成。</p><p>客户端使用 TCP 端口 20 与服务器建立第二个连接用于实际数据传输。每当有数据需要传输时都会建立此连接。</p><p>数据传输可以在任何一个方向进行。客户端可以从服务器下载（取）数据，也可以向服务器上传（放）数据。</p><hr><h3 id="服务器消息块"><a href="#服务器消息块" class="headerlink" title="服务器消息块"></a>服务器消息块</h3><p>服务器消息块 (SMB) 是一种客户端/服务器文件共享协议，用于规范共享网络资源（如目录、文件、打印机以及串行端口）结构。这是一种请求-响应协议。所有的 SMB 消息都采用一种常用格式。该格式采用固定大小的文件头，后跟可变大小的参数以及数据组件。</p><p>以下是 SMB 消息的三个功能：</p><ul><li><p>启动、身份验证以及终止会话</p></li><li><p>控制文件和打印机的访问</p></li><li><p>允许应用程序向任何设备收发消息</p></li></ul><p>Microsoft 网络配置中主要采用 SMB 形式实现文件共享和打印服务。随着 Windows 2000 软件系列的推出，Microsoft 更改了基础结构以使用 SMB。而在以前的 Microsoft 产品中，SMB 服务需要使用非 TCP/IP 协议来执行域名解析。从 Windows 2000 开始，之后的所有 Microsoft 产品都使用 DNS 命名，使 TCP/IP 协议能够直接支持 SMB 资源共享，如图所示。</p><p>第一张图显示了Microsoft Windows的“我的文档”共享资源，以及来自服务器“我的文档”的客户端请求。客户端发送 SMB 请求并接收共享资源“我的文档”的 SMB 响应。共享资源包括显示为图标的文件系统、打印机，邮件槽和 API。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_16_1.png"><p>Windows PC 之间的 SMB 文件交换过程如下图所示。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/15_16_2.png"><p>与 FTP 协议支持的文件共享不同，SMB 协议中的客户端要与服务器建立长期连接。一旦建立连接，客户端用户就可以访问服务器上的资源，就如同资源位于客户端主机上一样。</p><p>在 LINUX 和 UNIX 操作系统中，通过 SAMBA（SMB 的一个版本）可以实现与 Microsoft 网络的资源共享。在 Apple Macintosh 操作系统中，通过 SMB 协议也可以实现资源共享。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>应用层、表示层和会话层</li></ul><blockquote><p>在OSI和TCP/IP 模型中的应用层最接近最终用户。应用层协议用于在源主机和目的主机上运行的程序之间进行数据交换。表示层有三个主要功能：将源设备上的数据格式化或呈现为目标设备可接收的兼容格式、以目的设备可解压的方式压缩数据、对数据进行加密以便在接收时进行传输和解密。会话层用于创建并维护源应用程序和目的应用程序之间的对话。会话层用于处理信息交换，发起对话并使其处于活动状态，并在对话中断或长时间处于空闲状态时重启会话。TCP/IP 应用层协议指定了许多常见互联网通信功能必需的格式和控制信息。在会话过程中，源设备和目的设备均使用这些协议。在源和目的主机上实现的该协议必须是兼容的。</p></blockquote><ul><li>对等体到对等体</li></ul><blockquote><p>在客户端/服务器模式中，请求信息的设备称为客户端，而响应请求的设备称为服务器。客户端首先向服务器发送数据请求，服务器通过发送一个或多个数据流来响应客户端。在 P2P 网络中，两台或多台计算机通过网络互连，它们共享资源时可以不借助专用服务器。每台对等体既可以作为服务器，也可以作为客户端。在某项事务中，作为服务器的计算机也可以同时成为其他服务器的客户端。P2P 应用程序要求每台终端设备提供用户界面并运行后台服务。某些 P2P 应用程序中采用混合系统，即共享的资源是分散的，但指向资源位置的索引存储在集中目录中。许多 P2P 应用程序允许用户同时相互分享文件片段。客户端使用一个称作 torrent 文件的小型文件查找其他拥有其所需片段的用户，以便可以直接连接到他们。此文件也包含跟踪计算机的信息,跟踪哪些用户有哪些文件片段。</p></blockquote><ul><li>Web和电子邮件协议</li></ul><blockquote><p>当在 Web 浏览器中输入一个 Web 地址或URL时，Web 浏览器将与Web 服务建立连接。Web 服务正在使用 HTTP 协议的服务器上运行。HTTP 是一种请求/响应协议。当客户端，尤其是 Web 浏览器，发送请求到 Web 服务器时，HTTP 将指定用于该通信的消息类型。常用的三种消息类型包括 GET、POST 和 PUT。为了跨互联网的安全通信，HTTPS 使用的客户端请求服务器响应过程与 HTTP 相同，但在数据流通过网络传输以前会使用SSL加密。电子邮件支持三种单独的协议以实现操作：SMTP、POP 和IMAP。发送邮件的应用层进程会使用 SMTP。客户端使用 POP 或 IMAP 检索电子邮件。SMTP 邮件格式要求邮件具有报头和正文。邮件正文没有长度限制，但邮件报头必须具有格式正确的收件人邮件地址和发件人地址。应用程序使用 POP 从邮件服务器中检索邮件。根据 POP 的规定，邮件将从服务器下载到客户端，然后从服务器上删除。与 POP 不同，使用IMAP时，当用户连接使用 IMAP 的服务器时，邮件的副本会下载到客户端应用程序。同时原始邮件会一直保留在服务器上，直到用户将它们手动删除。</p></blockquote><ul><li>IP编址服务</li></ul><blockquote><p>DNS 协议将资源名称与所需的数字网络地址匹配。DNS协议通信对所有类型的客户端查询和服务器响应、报错消息、以及服务器间的资源记录信息的传输使用消息格式。DNS 使用域名来划分层次。每台 DNS 服务器维护着特定的数据库文件，而且只负责管理 DNS 结构中那一小部分的“域名-IP”映射。计算机操作系统使用Nslookup允许用户手动查询域名服务器来解析特定主机名。IPv4的DHCP服务自动分配 IPv4 地址、子网掩码、网关以及其他 IPv4 网络参数。DHCPv6 为 IPv6 客户端提供类似的服务，但不提供默认网关地址。配置了 DHCP 的 IPv4 设备在启动或连接到网络时，客户端将广播一条 DHCPDISCOVER 消息以确定网络上是否有可用的 DHCP 服务器。DHCP 服务器回复DHCPOFFER消息，为客户端提供租赁服务。DHCPv6 有一组与DHCPv4 类似的消息。DHCPv6 消息包括 SOLICIT、ADVERTISE、INFORMATION REQUEST 和 REPLY。</p></blockquote><ul><li>文件共享服务</li></ul><blockquote><p>FTP 客户端是一种在计算机上运行的应用，用于从 FTP 服务器中收发数据。客户端建立与服务器的第一个连接，用于使用 TCP 端口 21 控制流量。客户端使用 TCP 端口 20 与服务器建立第二个连接用于实际数据传输。客户端可以从服务器下载（取）数据，也可以向服务器上传（放）数据。以下是SMB消息的三个功能：启动、认证和终止会话、控制文件和打印机访问，并允许应用向其他设备发送消息或从其他设备接收消息。与 FTP 协议支持的文件共享不同，SMB 协议中的客户端要与服务器建立长期连接。一旦建立连接，客户端用户就可以访问服务器上的资源，就如同资源位于客户端主机上一样。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理 • （四）传输层</title>
      <link href="School-Computer-Network-Technology-4-Transport-Layer/"/>
      <url>School-Computer-Network-Technology-4-Transport-Layer/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇是对<a href="https://phoenixnest.github.io/Notes-Computer-Network-Technology/">计算机网络原理</a>一文中的<a href="https://phoenixnest.github.io/School-Computer-Network-Technology/#%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%88%E7%AC%AC-4-%E5%B1%82%EF%BC%89">传输层</a>的详细介绍。<br>所用教学平台：<a href="%22https://cn.netacad.com/%22">Cisco Networking Academy</a></p></blockquote><hr><h2 id="传输层（第4层）"><a href="#传输层（第4层）" class="headerlink" title="传输层（第4层）"></a>传输层（第4层）</h2><h3 id="传输层的作用"><a href="#传输层的作用" class="headerlink" title="传输层的作用"></a>传输层的作用</h3><blockquote><p>应用层程序生成必须在源主机和目的主机之间交换的数据。传输层负责在不同主机上运行的应用程序之间进行的逻辑通信。这可能包括在两个主机之间建立临时会话以及应用程序信息的可靠传输等服务。</p></blockquote><p>传输层将应用层与负责网络传输的下层连接起来。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_1.png" alt="传输层"></p><p>传输层并不了解目标主机类型、数据必须经过的介质类型、数据使用的路径，链路拥塞情况或网络大小。</p><p>传输层包括两个协议：</p><ul><li><p><strong>传输控制协议 (TCP)</strong></p></li><li><p><strong>用户数据报协议 (UDP)</strong></p></li></ul><hr><h3 id="传输层的职责"><a href="#传输层的职责" class="headerlink" title="传输层的职责"></a>传输层的职责</h3><ul><li><strong>跟踪各个会话</strong></li></ul><blockquote><p>在传输层中，源应用和目的应用之间传输的每个数据集称为会话并分别进行跟踪。<code>传输层负责维护并跟踪这些会话</code>。</p></blockquote><p>如图所示，每台主机上都可以有多个应用同时在网络上通信。</p><p><code>大多数网络对单个数据包能承载的数据量都有限制。因此，必须将数据分成可管理的部分</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_2_1.png" alt="跟踪各个会话"></p><ul><li><strong>数据分段和数据段重组</strong></li></ul><blockquote><p><code>传输层负责将应用程序数据划分为适当大小的块</code>。根据所使用的传输层协议，传输层块称为数据段或数据报。</p></blockquote><p>该图说明了使用不同块进行每个会话的传输层。</p><p>传输层将数据划分为更易于管理和传输的更小的块（即，数据段或数据报）。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_2_2.png" alt="数据分段和数据段重组"></p><ul><li><strong>添加报头信息</strong></li></ul><blockquote><p><code>传输层协议还将包含二进制数据的报头信息添加到每个数据块中，这些数据被组织成几个字段</code>。不同的传输层协议通过这些字段值在管理数据通信过程中执行各自的功能。</p></blockquote><p>例如，接收主机使用报头信息将数据块重新组装为接收应用程序层程序的完整数据流。</p><p><code>传输层可以确保在设备上运行多个应用时，所有应用都能接收正确的数据</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_2_3.png" alt="添加报头信息"></p><ul><li><strong>标识应用</strong></li></ul><blockquote><p><strong>传输层必须能够划分和管理具有不同传输要求的多个通信</strong>。<code>为了将数据流传递到适当的应用程序，传输层使用称为端口号的标识符来标识目标应用</code>。</p></blockquote><p>如图所示，在每台主机中，每个需要访问网络的软件进程都将被分配一个唯一的端口号。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_2_4.png" alt="标识应用"></p><ul><li><strong>会话多路复用</strong></li></ul><blockquote><p>将某些类型的数据（即视频流）作为完整的通信流在网络中发送，会使用所有可用带宽。这将阻止其他通信会话同时发生。而且也难以对损坏的数据开展错误恢复和重新传输的工作。</p></blockquote><p>如图所示，<code>传输层使用数据段和多路复用，使不同的通信会话在同一网络上交错</code>。</p><p><code>可对数据段中的数据执行错误检查，以确定数据段在传输过程中是否发生了更改</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_2_5.png" alt="会话多路复用"></p><hr><h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><p>IP 只涉及数据包的结构、地址分配和路由。IP 不指定数据包的传送或传输方式。</p><blockquote><p>传输层协议指定如何在主机之间传输消息，并负责管理会话的可靠性要求。<code>传输层包括 TCP 和 UDP 协议</code>。</p></blockquote><p>不同的应用有不同的传输可靠性要求。因此，TCP/IP 提供了两个传输层协议，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_3.png" alt="传输层协议"></p><hr><h3 id="传输控制协议-TCP"><a href="#传输控制协议-TCP" class="headerlink" title="传输控制协议 (TCP)"></a>传输控制协议 (TCP)</h3><p>IP 只涉及从原始发送方到最终目的地的数据包的结构、编址和路由。IP不负责保证传递或确定发送方和接收方之间是否需要建立连接。</p><blockquote><p><strong>TCP 被认为是可靠且功能齐全的传输层协议，用于确保所有数据到达目的设备</strong>。<code>TCP包含确保应用数据传递的字段。这些字段需要发送和接收的主机进行额外处理</code>。</p></blockquote><p>注意：<strong>TCP将数据分为若干个数据段</strong>。</p><blockquote><p>TCP 传输类似于从源到目的地跟踪发送的数据包。如果快递订单分多个数据包，客户可以在线查看发货顺序。</p></blockquote><p>TCP 使用以下基本操作提供可靠性和流量控制：</p><ul><li><p><strong>编号并跟踪从特定应用程序发送到特定主机的数据段。</strong></p></li><li><p><strong>确认收到数据</strong></p></li><li><p><strong>在一定时间段后重新传输未确认的数据</strong></p></li><li><p><strong>有顺序的数据可能以错误的顺序到达 以接收方可以接受的有效速率 发送数据</strong></p></li></ul><p>为了维护会话的状态并跟踪信息，TCP必须首先在发送方和接收方之间建立连接。这就是为什么TCP被称为是一种面向连接的协议。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_4.gif" alt="TCP 数据段和确认信息从发送方传输到接收方的过程"></p><p>有关 TCP 的更多信息，请在互联网上搜索 RFC 793。</p><hr><h3 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 (UDP)"></a>用户数据报协议 (UDP)</h3><blockquote><p><code>UDP是一种比TCP更简单的传输层协议</code>。它<strong>不提供可靠性和流量控制</strong>，这意味着它需要更少的报头字段。由于发送方和接收方UDP进程不需要管理可靠性和流量控制，这意味着 UDP 数据报的处理速度比 TCP 数据段快。UDP 仅提供在相应应用之间传输数据报的基本功能，需要很少的开销和数据检查。</p></blockquote><p>注意：<strong>UDP 将数据划分为数据报，也称为数据段</strong>。</p><blockquote><p>UDP是一种无连接协议。<code>由于 UDP 不提供可靠性或流量控制，因此不需要建立连接</code>。<code>由于 UDP 不跟踪客户端和服务器之间发送或接收的信息，因此UDP 也称为无状态协议</code>。</p></blockquote><p><code>UDP 也称为最大努力交付协议</code>，因为在目的地接收到数据后没有确认消息。<strong>UDP 中没有通知发送方是否成功传输的传输层流程</strong>。</p><p>UDP 类似于邮寄未挂号的常规信件。发件人不知道收件人是否能够接收信件。邮局也不负责跟踪信件或在信件未到达最终目的地时通知发件人。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_5.gif" alt="UDP 数据报从发送方传输到接收方"></p><hr><h3 id="正确的应用程序使用正确的传输层协议"><a href="#正确的应用程序使用正确的传输层协议" class="headerlink" title="正确的应用程序使用正确的传输层协议"></a>正确的应用程序使用正确的传输层协议</h3><blockquote><p><strong>一些应用可以容忍在网络传输过程中丢失部分数据，但是不接受传输中出现延迟</strong>。<code>由于需要的网络开销较少，对于这些应用，UDP 是更好的选择。UDP 是 IP 语音 (VoIP) 之类应用的首选</code>。<strong>确认和重新发送会拖慢传输速度，并使语音会话不可接受</strong>。</p></blockquote><p>UDP 也被“请求-回复”应用程序使用，其中数据最少，并且可以快速完成重新传输。例如，域名服务 (DNS) 为此类事务使用 UDP。客户端从DNS服务器请求已知域名的IPv4和IPv6地址。如果客户端在预定的时间内没有收到响应，它将再次发送请求。</p><p>例如，如果视频数据流中的一段或者两段数据未到达目的地，就会造成数据流的短暂中断。这可能表现为图像失真或声音失真，用户也许不会察觉。如果目的设备必须负责处理丢失的数据，则流可能在等待重新发送的过程中被推迟，从而导致图像或声音的质量大大降低。在这种情况下，最好利用接收到的分段呈现最佳媒体，并放弃可靠性。</p><hr><blockquote><p><strong>对于其他应用程序，重要的是所有数据都应到达并且可以按适当的顺序对其进行处理</strong>。<code>对于这些类型的应用程序，使用TCP 作为传输协议</code>。</p></blockquote><p>例如，数据库、Web 浏览器和邮件客户端等应用，要求发送的所有数据都必须以原始形式到达目的地。任何数据的丢失都可能导致通信失败，要么不能完成通信，要么通信的信息不可读。例如，通过网页访问银行信息时，确保所有信息都正确发送和接收是非常重要的。</p><hr><blockquote><p>应用开发人员必须根据应用的需求，选择适合的传输层协议类型。视频可以通过 TCP 或 UDP 发送。存储音频和视频流的应用使用 TCP。应用程序使用 TCP 执行缓冲、带宽探测和拥塞控制，以便更好地控制用户体验。</p><blockquote><p>实时视频和语音通常使用UDP，但也可能使用TCP，或同时使用UDP和TCP。视频会议应用程序默认情况下可能使用UDP，但由于许多防火墙阻止UDP，应用程序也可以通过TCP发送。</p></blockquote><blockquote><p>存储音频和视频流的应用使用 TCP。例如，如果您的网络突然不能支持观看一个点播电影所需的带宽，则应用使播放暂停。在暂停期间，您可能会看到一个“缓冲……”消息，这时，TCP 正在重建流。当所有的片段都井然有序且恢复最低限度的带宽时，您的 TCP 会话重新开始，电影恢复播放。</p></blockquote></blockquote><p>该图总结了UDP和TCP之间的差异。</p><p>列出了<strong>UDP（快速，低开销，没有确认，没有重新发送）</strong>和<strong>TCP（可靠，确认数据，重新发送丢失的数据，并传递有序列号的数据）</strong>之间的差异</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_6.png" alt="UDP和TCP之间的差异"></p><hr><h2 id="TCP-概述"><a href="#TCP-概述" class="headerlink" title="TCP 概述"></a>TCP 概述</h2><h3 id="TCP-功能"><a href="#TCP-功能" class="headerlink" title="TCP 功能"></a>TCP 功能</h3><p>除了支持数据分段和重组的基本功能之外，TCP 还提供以下服务：</p><ul><li><p><strong>建立会话</strong> - <code>TCP是一种面向连接的协议</code>，在转发任何流量之前，在源设备和目的设备之间协商并建立永久连接（或会话）。通过建立会话，设备可以协商特定时间能够转发的流量，而且两个设备之间的通信数据可得到严格管理。</p></li><li><p><strong>确保可靠的传递</strong> - 由于多种原因，数据段在网络传输过程中可能会损坏或者完全丢失。<code>TCP确保从源设备发送的每个数据段都能够到达目的地</code>。</p></li><li><p><strong>提供相同顺序的传递</strong> - 由于网络可能提供了多条路由，每条路由又有不同的传输速率，所以可能导致数据抵达的顺序错乱。通过对数据段编号和排序，<code>TCP 确保按正确的顺序重组这些数据段</code>。</p></li><li><p><strong>支持流量控制</strong> - 网络主机的资源有限（即，内存或处理能力）。当 TCP 发现这些资源超负荷运转时，它可以请求源应用程序降低数据流速。为此，TCP 会调整源设备传输的数据量。流量控制可避免当接收主机的资源不堪重负时，数据的重新传输。</p></li></ul><hr><h3 id="TCP-报头"><a href="#TCP-报头" class="headerlink" title="TCP 报头"></a>TCP 报头</h3><blockquote><p><strong>TCP是有状态的协议，意味着它跟踪通信会话的状态</strong>。为了跟踪会话的状态，TCP 记录已发送的信息和已确认的信息。<strong>状态会话开始于会话建立时，结束于会话终止时</strong>。</p></blockquote><p>在封装应用层数据时，TCP 数据段会增加 20 个字节（即 160 位）的开销。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_6.png" alt="TCP 报头中的字段"></p><hr><h3 id="TCP-报头字段"><a href="#TCP-报头字段" class="headerlink" title="TCP 报头字段"></a>TCP 报头字段</h3><table><thead><tr><th align="center">TCP 报头字段</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>源端口</strong></td><td align="center"><strong>一个16位字段</strong>，用于通过端口号标识源应用程序。</td></tr><tr><td align="center"><strong>目的端口</strong></td><td align="center"><strong>一个16位字段</strong>，用于通过端口号标识目的应用程序。</td></tr><tr><td align="center"><strong>序列号</strong></td><td align="center"><strong>一个32位字段</strong>，用于数据重组。</td></tr><tr><td align="center"><strong>确认号</strong></td><td align="center"><strong>一个32位字段</strong>，用于指示已接收到数据,并且期望从源 接收下一个字节。</td></tr><tr><td align="center"><strong>报头长度</strong></td><td align="center"><strong>一个4位字段</strong>，称为“数据偏移”, 表示 TCP 数据段报头的长度。</td></tr><tr><td align="center"><strong>保留</strong></td><td align="center"><strong>一个6位字段</strong>，保留供将来使用。</td></tr><tr><td align="center"><strong>控制位</strong></td><td align="center"><strong>一个6位字段</strong>，包括位代码或标志, 指示 TCP 段的目的和功能。</td></tr><tr><td align="center"><strong>窗口大小</strong></td><td align="center"><strong>一个16位字段</strong>，用于指示一次可以接受的字节数。</td></tr><tr><td align="center"><strong>校验和</strong></td><td align="center"><strong>一个16位字段</strong>，用于数据段报头和数据的错误检查。</td></tr><tr><td align="center"><strong>紧急</strong></td><td align="center"><strong>一个16位字段</strong>，用于指示包含的数据是否紧急。</td></tr></tbody></table><hr><h3 id="使用-TCP-的应用程序"><a href="#使用-TCP-的应用程序" class="headerlink" title="使用 TCP 的应用程序"></a>使用 TCP 的应用程序</h3><p>TCP 很好地说明了 TCP/IP 协议簇的不同层如何拥有特定角色。TCP 处理与将数据流划分为数据段、提供可靠性、控制数据流量和数据段重新排序相关的所有任务。TCP 使应用程序不用再管理这些任务。</p><p>如图所示的应用程序只需要将数据流发送到传输层和使用 TCP 提供的服务。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_9.png" alt="指向两个方向的箭头，从HTTP、FTP、SMTP和SSH指向TCP，然后从TCP指向IP"></p><hr><h2 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h2><h3 id="UDP-功能"><a href="#UDP-功能" class="headerlink" title="UDP 功能"></a>UDP 功能</h3><blockquote><p><strong>UDP 是一种尽最大努力传输协议</strong>。<code>UDP 是一种轻型传输协议</code>，<strong>提供与 TCP 相同的数据分段和重组功能，但是没有 TCP 所提供的可靠性和流量控制</strong>。</p></blockquote><p>UDP 协议非常简单，它通常被描述为与 TCP 比较所不提供的功能。</p><p>UDP的特点包括以下几种：</p><ul><li><p><strong>数据按照接收顺序重构。</strong></p></li><li><p><strong>丢失的任何数据段都不会重新发送。</strong></p></li><li><p><strong>不会建立会话。</strong></p></li><li><p><strong>不会告知发送者资源可用性。</strong></p></li></ul><p>有关 UDP 的更多信息，请在互联网上搜索 RFC。</p><hr><h3 id="UDP-报头"><a href="#UDP-报头" class="headerlink" title="UDP 报头"></a>UDP 报头</h3><blockquote><p><strong>UDP 是无状态协议，这意味着客户端和服务器都不会跟踪通信会话的状态</strong>。如果使用 UDP 作为传输协议时要求可靠性，<code>必须由应用来处理可靠性</code>。</p></blockquote><p>通过网络传输实时视频和语音的一个最重要的要求是数据持续高速传输。实时视频和语音应用能够容忍具有极小或没有明显影响的一些数据丢失，非常适合于 UDP。</p><blockquote><p><code>UDP 中的通信块称为数据报或数据段</code>。这些数据报<strong>通过传输层协议尽力传送</strong>。</p><blockquote><p><code>UDP报头比TCP报头简单得多，因为它只有四个字段，需要8个字节(即64位)</code>。</p></blockquote></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_10.png" alt="UDP 报头中的字段"></p><hr><h3 id="UDP-报头字段"><a href="#UDP-报头字段" class="headerlink" title="UDP 报头字段"></a>UDP 报头字段</h3><table><thead><tr><th align="center">UDP 报头字段</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>源端口</strong></td><td align="center"><strong>一个16位字段</strong>，用于通过端口号标识源应用程序。</td></tr><tr><td align="center"><strong>目的端口</strong></td><td align="center"><strong>一个16位字段</strong>，用于通过端口号标识目的应用程序。</td></tr><tr><td align="center"><strong>长度</strong></td><td align="center"><strong>一个16位字段</strong>，指示UDP数据报报头的长度。</td></tr><tr><td align="center"><strong>校验和</strong></td><td align="center"><strong>一个16位字段</strong>，用于数据报报头和数据的错误检查。</td></tr></tbody></table><hr><h3 id="使用-UDP-的应用程序"><a href="#使用-UDP-的应用程序" class="headerlink" title="使用 UDP 的应用程序"></a>使用 UDP 的应用程序</h3><p>最适合采用 UDP 协议的三种应用程序包括：</p><ul><li><p><strong>实时视频和多媒体应用程序</strong> - 这些应用可以容忍部分数据丢失但要求延迟极小或没有延迟的应用程序。示例包括 VoIP 和实时流传输视频。</p></li><li><p><strong>简单请求和应答应用程序</strong> - 处理简单事务的应用程序，其中主机发送请求，但不一定收到应答。示例包括 DNS 和 DHCP。</p></li><li><p><strong>处理可靠性的应用程序</strong> - 不要求进行流量控制、错误检测、确认和错误恢复，或这些功能由应用程序来执行的单向通信。示例包括 SNMP 和 TFTP。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_12.png" alt="需要 UDP 的应用程序。显示了指向两个方向的箭头，从DHCP、DNS、SNMP、TFTP、VoIP和IPTV指向UDP，然后从UDP指向IP"></p><blockquote><p><strong>虽然 DNS 和 SNMP 默认使用 UDP，但它们都可以使用 TCP</strong>。<code>如果 DNS 请求或 DNS 响应大于 512 字节，DNS 会使用 TCP</code>，例如 DNS 响应包含许多域名解析时。同样，<code>在某些情况下，网络管理员可以配置 SNMP 使用 TCP</code>。</p></blockquote><hr><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><h3 id="多个单独的通信"><a href="#多个单独的通信" class="headerlink" title="多个单独的通信"></a>多个单独的通信</h3><p><strong>在某些情况下 TCP 是适合多个单独的通信的协议</strong>，在其他情况下则应使用 UDP。<code>无论传输何种类型的数据，TCP 和 UDP 都使用端口号</code>。</p><p>TCP 和 UDP 传输层协议使用端口号来管理多个同时的对话。如图所示，TCP和UDP报头字段标识源和目的应用程序端口号。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_13.png"><p><code>源端口号与本地主机上的原始应用程序相关联，而目的端口号与远程主机上的目的应用程序相关联</code>。</p><p>例如，假设一台主机正在向 Web 服务器发起网页请求。当主机发起网页请求时，主机会动态生成源端口号，以惟一地标识会话。由主机生成的每个请求将使用不同的动态创建的源端口号。这就使多个会话能够同时发生。</p><blockquote><p>在请求中，目的端口号是标识目的Web服务器正在被请求的服务类型的端口号。例如，当客户端在目的端口中指定端口 80 时，接收该消息的服务器就知道请求的是 Web 服务。</p></blockquote><blockquote><p>服务器可同时提供多个服务，例如在端口 80 上提供 Web 服务，并同时在端口 21 上提供建立文件传输协议 (FTP) 连接的服务。</p></blockquote><hr><h3 id="套接字对"><a href="#套接字对" class="headerlink" title="套接字对"></a>套接字对</h3><p>源端口和目的端口都被置入<code>分段</code>内，然后分段<code>封装</code>于 IP 数据包内。<code>IP 数据包中含有源 IP 地址和目的 IP 地址</code>。源 IP 地址和源端口号的组合或者目的 IP 地址和目的端口号的组合，称为套接字。</p><p>在图中的示例中，PC 同时从目标服务器请求 FTP 和 Web 服务。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_14.png"><p>在该示例中，PC生成的FTP请求包括第2层MAC地址和第3层IP地址。请求还标识了源端口号 1305（即，由主机动态生成）和标识了FTP服务的目的端口21。主机还使用相同的第 2 层和第 3 层地址从服务器请求了一个网页。但是，它使用的是源端口号 1099（即，由主机动态生成）和标识了Web服务的目的端口80。</p><blockquote><p>套接字用于标识客户端所请求的服务器和服务。客户端套接字可能如下所示，其中 1099 代表源端口号：192.168.1.5:1099，Web 服务器上的套接字则可能是192.168.1.7:80，这两个套接字组合在一起形成一个套接字对：192.168.1.5:1099，192.168.1.7:80</p><blockquote><p>有了套接字，一台客户端上运行的多个进程便可彼此区分，它们与同一服务器进程建立的多个连接也可以彼此区分。</p></blockquote><blockquote><p>对于请求数据的应用而言，该源端口号就像是一个返回地址。传输层将跟踪此端口和发出该请求的应用，当返回响应时，传输层可以将其转发到正确的应用。</p></blockquote></blockquote><hr><h3 id="端口号组"><a href="#端口号组" class="headerlink" title="端口号组"></a>端口号组</h3><p>互联网编号指派机构 (IANA) 是负责分配各种编址标准（包括端口号）的标准组织。<code>用于标识源端口号和目的端口号的16位二进制提供了从0到65535的端口范围</code>。</p><p>IANA 已将号码范围划分为以下三个端口组。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_15.png"><p>注意: 一些客户端操作系统在分配源端口时可能使用注册端口号而不是动态端口号。</p><p>该表显示了一些常用的公认端口号及其相关应用程序。</p><table><thead><tr><th align="center">端口号</th><th align="center">协议</th><th align="center">应用层</th></tr></thead><tbody><tr><td align="center"><strong>20</strong></td><td align="center"><strong>TCP</strong></td><td align="center">文件传输协议 (FTP) - <strong>数据</strong></td></tr><tr><td align="center"><strong>21</strong></td><td align="center"><strong>TCP</strong></td><td align="center">文件传输协议 (FTP) - <strong>控制</strong></td></tr><tr><td align="center"><strong>22</strong></td><td align="center"><strong>TCP</strong></td><td align="center">安全 Shell (SSH)</td></tr><tr><td align="center"><strong>23</strong></td><td align="center"><strong>TCP</strong></td><td align="center">Telnet</td></tr><tr><td align="center"><strong>25</strong></td><td align="center"><strong>TCP</strong></td><td align="center">简单邮件传输协议 (SMTP)</td></tr><tr><td align="center"><strong>53</strong></td><td align="center"><strong>UDP、TCP</strong></td><td align="center">域名服务 (DNS)</td></tr><tr><td align="center"><strong>67</strong></td><td align="center"><strong>TCP</strong></td><td align="center">动态主机配置协议 (DHCP) - 服务器</td></tr><tr><td align="center"><strong>68</strong></td><td align="center"><strong>TCP</strong></td><td align="center">简单文件传输协议 (TFTP)</td></tr><tr><td align="center"><strong>80</strong></td><td align="center"><strong>TCP</strong></td><td align="center">超文本传输协议 (HTTP)</td></tr><tr><td align="center"><strong>110</strong></td><td align="center"><strong>TCP</strong></td><td align="center">邮局协议第 3 版 (POP3)</td></tr><tr><td align="center"><strong>143</strong></td><td align="center"><strong>TCP</strong></td><td align="center">互联网消息访问协议 (IMAP)</td></tr><tr><td align="center"><strong>161</strong></td><td align="center"><strong>TCP</strong></td><td align="center">简单网络管理协议 (SNMP)</td></tr><tr><td align="center"><strong>443</strong></td><td align="center"><strong>TCP</strong></td><td align="center">安全超文本传输协议 (HTTPS)</td></tr></tbody></table><p><code>一些应用程序可能既使用 TCP，又使用 UDP</code>。例如，当客户端向 DNS 服务器发送请求时，DNS 使用 UDP。但是，两台 DNS 服务器之间的通信始终使用 TCP。</p><p>在IANA网站上搜索端口注册表，来查看端口号及相关应用的完整列表。</p><hr><h3 id="netstat-命令"><a href="#netstat-命令" class="headerlink" title="netstat 命令"></a>netstat 命令</h3><blockquote><p>不明的 TCP 连接可能造成重大的安全威胁。因为此类连接表示某程序或某人正连接到本地主机。有些时候，需要了解联网主机中启用并运行了哪些活动 TCP 连接。<code>Netstat 是一种重要的网络实用程序，可用来检验此类连接</code>。</p></blockquote><p>如下所示，输入命令 netstat可列出正在使用的协议、本地地址和端口号、外部地址和端口号以及连接的状态。</p><pre><code class="bash">C:\&gt; netstatActive Connections  Proto  Local Address          Foreign Address        State  TCP    192.168.1.124:3126     192.168.0.2:netbios-ssn    ESTABLISHED  TCP    192.168.1.124:3158     207.138.126.152:http   ESTABLISHED  TCP    192.168.1.124:3159     207.138.126.169:http   ESTABLISHED  TCP    192.168.1.124:3160     207.138.126.169:http   ESTABLISHED  TCP    192.168.1.124:3161     sc.msn.com:http        ESTABLISHED  TCP    192.168.1.124:3166     www.cisco.com:http     ESTABLISHED(output omitted)C:\&gt;</code></pre><blockquote><p>默认情况下，<code>netstat命令会试图将 IP 地址解析为域名</code>，<code>将端口号解析为公认应用程序</code>。使用 <code>-n</code> 选项<strong>能够以数字形式显示 IP 地址和端口号</strong>。</p></blockquote><hr><h2 id="TCP-通信过程"><a href="#TCP-通信过程" class="headerlink" title="TCP 通信过程"></a>TCP 通信过程</h2><h3 id="TCP-服务器进程"><a href="#TCP-服务器进程" class="headerlink" title="TCP 服务器进程"></a>TCP 服务器进程</h3><blockquote><p>在服务器上运行的每个应用程序进程都配置为使用一个端口号。端口号由系统管理员自动分配或手动配置。</p><blockquote><p>在同一传输层服务中，单个服务器上不能同时存在具有相同端口号的两个不同服务。例如，主机同时运行 Web 服务器应用程序和文件传输应用程序时，不能为两个应用程序配置相同的端口（如 TCP 端口 80）。</p></blockquote><blockquote><p>分配有特定端口的活动服务器应用程序被认为是开放的，也就是说，传输层将接受并处理分配到该端口的数据段。所有发送到正确套接字地址的传入客户端请求都将被接受，数据将被传送到服务器应用。在同一服务器上可以同时开启很多端口，每个端口对应一个动态服务器应用。</p></blockquote></blockquote><p>TCP 服务器进程的详细信息：</p><ul><li>发送 TCP 请求的客户端</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_17_1.png" alt="客户端 1 正在请求 Web 服务，客户端 2 正在使用公认端口（即 Web 服务 = 端口 80，电子邮件服务 = 端口 25）请求电子邮件服务。"></p><ul><li>请求的目的端口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_17_2.png" alt="请求动态生成源端口号。在这种情况下，客户端 1 使用源端口 49152，客户端 2 使用源端口 51152。"></p><ul><li>请求的源端口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_17_3.png" alt="当服务器响应客户端请求时，它会反转发起请求的目的端口和源端口。"></p><ul><li>响应的目的端口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_17_4.png" alt="注意，服务器对web请求的响应现在具有目的端口49152，而电子邮件的响应现在具有目的端口51152。"></p><ul><li>响应的源端口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_17_5.png" alt="服务器响应中的源端口是发起请求中的原始目的端口。"></p><hr><h3 id="TCP-连接的建立"><a href="#TCP-连接的建立" class="headerlink" title="TCP 连接的建立"></a>TCP 连接的建立</h3><blockquote><p>双方都把握手的行为理解为友好问候的信号。网络中的连接是类似的。<code>在 TCP 连接中，主机客户端使用三次握手过程与服务器建立连接</code>。</p></blockquote><ul><li>SYN</li></ul><p><strong>源客户端请求与服务器进行客户端 - 服务器通信会话。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_18_1.png" alt="SYN"></p><ul><li>ACK 和 SYN</li></ul><p><strong>服务器确认客户端-服务器通信会话，并请求服务器 - 客户端通信会话。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_18_2.png" alt="ACK 和 SYN"></p><ul><li>ACK</li></ul><p><strong>源客户端确认服务器 - 客户端通信会话。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_18_3.png" alt="ACK"></p><blockquote><p>三次握手验证目标主机是否可用来通信。</p></blockquote><hr><h3 id="会话终止"><a href="#会话终止" class="headerlink" title="会话终止"></a>会话终止</h3><blockquote><p>若要关闭连接，分段报头必须设置完成 (FIN) 控制标志。为终止每个单向 TCP 会话，需采用包含 FIN 分段和确认 (ACK) 分段的二次握手。因此，若要终止 TCP 支持的整个会话过程，需要实施四次交换，以终止两个双向会话。客户端或服务器都可以发起终止。</p></blockquote><ul><li>FIN</li></ul><p><strong>当客户端的数据流中没有其他要发送的数据时，它将发送带 FIN 标志设置的分段。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_19_1.png" alt="FIN"></p><ul><li>ACK</li></ul><p><strong>服务器发送 ACK 信息，确认收到从客户端发出的请求终止会话的 FIN 信息。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_19_2.png" alt="ACK"></p><ul><li>FIN</li></ul><p><strong>服务器向客户端发送 FIN 信息，终止从服务器到客户端的会话。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_19_3.png" alt="FIN"></p><ul><li>ACK</li></ul><p><strong>客户端发送 ACK 响应信息，确认收到从服务器发出的 FIN 信息。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_19_4.png" alt="ACK"></p><p><code>当所有数据段得到确认后，会话关闭。</code></p><hr><h3 id="TCP-三次握手分析"><a href="#TCP-三次握手分析" class="headerlink" title="TCP 三次握手分析"></a>TCP 三次握手分析</h3><p>主机维护状态，跟踪会话过程中的每个分段，并使用 TCP 报头信息交换已接收数据的相关信息。TCP 是全双工协议，每个连接都代表两个单向通信会话。若要建立连接，主机应执行三次握手。如图所示，TCP 报头中的控制位指出了连接的进度和状态。</p><p>这些是三次握手的功能：</p><ul><li><p><strong>确认目的设备存在于网络上。</strong></p></li><li><p><strong>确认目的设备有活动的服务，并且正在源客户端要使用的目的端口号上接受请求。</strong></p></li><li><p><strong>通知目的设备源客户端想要在该端口号上建立通信会话。</strong></p></li></ul><p>通信完成后，将关闭会话并终止连接。连接和会话机制保障了 TCP 的可靠性功能。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_20.png" alt="控制位字段"></p><p>TCP 分段报头的控制位字段中的六位被称为标志。标志是设置为开启或关闭的位。</p><p><code>六个控制位</code>标志如下：</p><ul><li><strong>URG</strong> - 紧急指针字段（重要）</li><li><strong>ACK</strong> - 用于建立连接和会话终止的确认标志</li><li><strong>PSH</strong> - 推送功能</li><li><strong>RST</strong> - 在出现错误或超时时重置连接</li><li><strong>SYN</strong> - 同步建立连接中使用的序列号</li><li><strong>FIN</strong> - 没有更多来自发送方的数据，并用于会话终止</li></ul><p>搜索互联网以了解 PSH 和 URG 标志的详细信息。</p><hr><h2 id="可靠性和流控制"><a href="#可靠性和流控制" class="headerlink" title="可靠性和流控制"></a>可靠性和流控制</h2><h3 id="TCP-可靠性-保证及按序传递"><a href="#TCP-可靠性-保证及按序传递" class="headerlink" title="TCP 可靠性 - 保证及按序传递"></a>TCP 可靠性 - 保证及按序传递</h3><blockquote><p>对某些应用程序来说，TCP更好，原因是，与 <strong>UDP 不同，TCP 重新发送丢弃的数据包以及对数据包进行编号，以便在传递前指示其正确的顺序</strong>。<strong>TCP 还可以帮助维护数据包的流量，以避免设备过载</strong>。</p></blockquote><blockquote><p><strong>有时可能TCP数据段没有到达目的地</strong>。<strong>有时TCP段可能会无序到达</strong>。</p><blockquote><p>因此，为了让接收方理解原始消息，必须接收所有数据，并重组这些数据段，使其恢复原有顺序。每个数据包中的数据段报头中都含有序列号，便于进行数据重组。序列号代表 TCP 分段的第一个数据字节在完整数据中的位置。</p></blockquote></blockquote><blockquote><p>在会话建立过程中，将设置初始序列号 (ISN)。此 ISN 表示传输到接收应用的字节起始值。在会话过程中，每传送一定字节的数据，序列号就随之增加。通过这样的数据字节跟踪，可以唯一标识并确认每个分段，还可以标识丢失的分段。</p></blockquote><p><code>ISN 并不是从 1 开始，而是随机的数字</code>。这样做的<code>目的是防止某些类型的恶意攻击</code>。为简单起见，本章的示例中我们将使用 1 作为 ISN。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_21.png" alt="在目的设备上对 TCP 数据段进行重新排序"></p><blockquote><p><code>接收方的 TCP 进程将数据段中的数据存入缓存区，然后数据段按照正确的序列顺序进行排列，重组后发送到应用层</code>。<strong>对于序列号混乱的分段，将被保留以备后期处理。等缺失的分段到达后，再来按顺序处理这些分段</strong>。</p></blockquote><hr><h3 id="TCP-可靠性-数据丢失和重传"><a href="#TCP-可靠性-数据丢失和重传" class="headerlink" title="TCP 可靠性 - 数据丢失和重传"></a>TCP 可靠性 - 数据丢失和重传</h3><p>无论网络设计得有多好，数据丢失还是时有发生。<code>TCP 提供了管理数据段丢失的方法。其中一个方法就是重新传输未确认的数据</code>。</p><p><code>序列 (SEQ) 号和确认 (ACK) 号一起使用，以确认接收传输段中包含的数据字节</code>。<strong>SEQ 编号标识正在传输的数据段中的第一个字节</strong>。<strong>TCP 使用发送回源代码的 ACK 编号来指示接收方希望接收的下一个字节。这称为期望确认</strong>。</p><p><code>在进行后续增强之前，TCP只能确认预期的下一个字节</code>。</p><p>例如，在图中，为简单起见，主机A使用数据段号向主机B发送段1到10。如果除段3和段4之外的所有数据段都已到达，主机B将应答并确认指定下一个预期的数据段是段3。主机A不知道其他数据段是否到达。因此，主机A将重新发送段3到段10。如果所有重新发送的数据段都成功到达，则段 5 到 段10 将是重复的。这会导致延迟、拥塞和效率低下。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_22_1.png"><blockquote><p>今天的主机操作系统通常采用一种称为选择性确认 (SAK) 的可选 TCP 功能，在三次握手期间协商。<strong>如果两个主机都支持SACK，则接收方可以明确地确认接收了哪些数据段(字节)，包括任何不连续的段</strong>。因此，发送主机只需要重新传输丢失的数据。</p></blockquote><p>例如，在下图中，还是为简单起见，主机A使用数据段号向主机B发送段1到10。如果除段3和段4之外的所有数据段都已到达，主机B可以确认它已经接收了段1和段2 (ACK 3)，并有选择地确认段5到10 (SACK 5-10)。主机A只需要重新发送段3和段4。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_22_2.png"><p>注意：TCP通常会为每个其他数据包发送ACK，但是超出本主题范围的其他因素可能会改变这种行为。</p><blockquote><p>TCP使用计时器来知道在重新发送一个数据段之前需要等待多长时间。</p></blockquote><hr><h3 id="TCP-流量控制-窗口大小和确认"><a href="#TCP-流量控制-窗口大小和确认" class="headerlink" title="TCP 流量控制 - 窗口大小和确认"></a>TCP 流量控制 - 窗口大小和确认</h3><blockquote><p>TCP 还提供了流量控制机制。流量控制即目的主机能够可靠地接收并处理的数据量。<strong>流量控制可以调整给定会话中源和目的地之间的数据流速，有助于保持 TCP 传输的可靠性</strong>。为此，<code>TCP 报头包括一个称为“窗口大小”的 16 位字段</code>。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_23.png" alt="TCP 窗口大小和确认的示例"></p><p><code>窗口大小用于确定在获得确认前可以发送的字节数。确认号是指下一个预期字节的编号</code>。</p><blockquote><p>窗口大小是 TCP 会话的目的设备一次可以接受和处理的字节数。</p></blockquote><p>在本例中，PC B 用于 TCP 会话的初始窗口大小为 10000 字节。从第 1 个字节开始，字节数为 1，PC A 在不收到确认的前提下可以发送的最后一个字节为 10,000。这被称为PC A的发送窗口。每个 TCP 分段均包含窗口大小，那样目的设备可以根据缓冲区的可用性随时修改窗口大小。</p><blockquote><p>初始窗口大小在三次握手期间建立 TCP 会话时确定。源设备必须根据目的设备的窗口大小限制发送到目的设备的字节数。只有源设备收到字节数已接收的确认之后，才能继续发送更多会话数据。通常情况下，目的设备不会等待其窗口大小的所有字节接收后才以确认应答。接收和处理字节时，目的设备就会发送确认，以告知源设备它可以继续发送更多字节。</p></blockquote><p>例如，通常情况下，PC B 不会等待所有 10,000 字节都接收后才发送确认。这就意味着 PC A 可以在收到 PC B 的确认时调整其发送窗口。如图所示，当 PC A 收到确认号为 2,921 的确认消息时，它即是下一个预期的字节的编号。PC A 发送窗口将增加 2920 字节。这会将发送窗口从 10000 字节更改为 12920。现在只要 PC A 发送不超出其新的发送窗口 12920 的字节数，它就能够向 PC B 另外发送 10000 字节。</p><blockquote><p>目的设备在处理接收的字节时发送确认并不断调整源设备的发送窗口大小被称为滑动窗口。</p></blockquote><p>在上一个示例中，PC A 的发送窗口会增加或滑动了 2921 个字节，从 10000 增到 12920。</p><blockquote><p>如果目的设备缓冲区空间的可用性减小，它可以缩减窗口大小，通知源设备减少发送的字节数，而不需要接收确认。</p></blockquote><blockquote><p>注意：设备如今使用滑动窗口协议。接收方通常在每收到两个数据段之后发送确认。在确认之前收到的数据段的数量可能有所不同。滑动窗口的优势在于，只要接收方确认之前的数据段，就可以让发送方持续传输数据段。滑动窗口的详细信息不在本课程的讨论范围之内。</p></blockquote><hr><h3 id="TCP-流量控制-最大段大小-MSS"><a href="#TCP-流量控制-最大段大小-MSS" class="headerlink" title="TCP 流量控制-最大段大小 (MSS)"></a>TCP 流量控制-最大段大小 (MSS)</h3><p>如图所示，在每个TCP数据段内，源主机正在传输 1460 字节的数据。这通常是目的设备可接收的最大段大小 (MSS)。MSS 是 TCP 报头中选项字段的一部分，用于指定设备可以在单个 TCP数据段中接收的最大数据量（以字节为单位）。MSS 大小不包括 TCP 报头。MSS 通常包括在三次握手过程中。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_24_1.png"><p>使用 IPv4 时，常见的 MSS 为 1460 字节。主机会从以太网最大传输单位 (MTU) 中减去 IP 和 TCP 报头，从而确定其 MSS 字段的值。在以太网接口上，默认 MTU 为 1500 个字节。减去 20 个字节的 IPv4 报头和 20 个字节的 TCP 报头，默认 MSS 大小为 1460 个字节，如图所示。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_24_2.png"><hr><h3 id="TCP-流量控制-避免拥塞"><a href="#TCP-流量控制-避免拥塞" class="headerlink" title="TCP 流量控制 - 避免拥塞"></a>TCP 流量控制 - 避免拥塞</h3><p>网络中出现拥塞会使过载的路由器丢弃数据包。当包含 TCP 数据段的数据包未到达其目的地时，它们就成为未确认的数据包。通过确定 TCP 数据段发送但未确认的速率，源设备可以假设一定程度的网络拥塞。</p><p>出现网络拥塞时，从源设备丢失的 TCP 数据段就会重传。如果不适当控制重传，TCP 数据段的额外重传会使拥塞的情况更糟。网络中不仅有 TCP 数据段的新数据包，而且还有重传丢失的 TCP 数据段的反馈效果，这都增加了拥塞。为避免和控制拥塞，TCP 使用了多个拥塞处理机制、计时器和算法。</p><p>如果源设备确定 TCP 数据段没有被确认或没有被及时确认，它会在收到确认之前减少发送的字节数。如图所示，PC A 感知到存在拥塞，因此，在收到PC B的确认之前减少了它发送的字节数。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_25.png" alt="TCP 拥塞控制"></p><p>注意是源设备在减少其发送的未确认的字节数，而不是由目的设备来确定窗口大小。</p><p>注意：实际拥塞处理机制、计时器和算法的解释不属于本课程的范围。</p><hr><h2 id="UDP-通信"><a href="#UDP-通信" class="headerlink" title="UDP 通信"></a>UDP 通信</h2><h3 id="UDP-低开销与可靠性"><a href="#UDP-低开销与可靠性" class="headerlink" title="UDP 低开销与可靠性"></a>UDP 低开销与可靠性</h3><p>如前所述，UDP非常适合需要快速通信的场合，比如VoIP。本主题详细解释为什么 UDP 非常适合某些类型的传输。如图所示，UDP 不建立连接。因为 UDP 的数据报头较小而且没有网络管理流量，因此可以提供低开销数据传输。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_26.png"><hr><h3 id="UDP-数据报重组"><a href="#UDP-数据报重组" class="headerlink" title="UDP 数据报重组"></a>UDP 数据报重组</h3><p>与 TCP分段类似，当将多个 UDP 数据报发送到目的主机时，它们通常采用不同的路径，到达顺序也可能跟发送时的顺序不同。与 TCP 不同，UDP 不跟踪序列号。如图所示，UDP 不会按传输顺序重新排列数据报。</p><p>因此，UDP 仅仅是将接收到的数据按照先来后到的顺序转发到应用程序。如果数据顺序对应用程序很重要，应用程序必须确定正确的顺序并决定如何处理数据。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_27.png" alt="UDP：无连接和不可靠"></p><hr><h3 id="UDP-服务器进程与请求"><a href="#UDP-服务器进程与请求" class="headerlink" title="UDP 服务器进程与请求"></a>UDP 服务器进程与请求</h3><p>如图所示，与基于 TCP 的应用程序相同的是，基于 UDP 的服务器应用程序也被分配了公认端口号或注册端口号。当上述应用或进程在服务器上运行时，它们就会接受与所分配端口号相匹配的数据。当 UDP 收到用于某个端口的数据报时，它就会按照应用的端口号将数据发送到相应的应用。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_28.png" alt="UDP 服务器侦听请求"></p><p>注意: 图中所示的远程认证拨号用户服务 (RADIUS) 服务器通过提供认证、授权和审计服务，来管理用户访问。RADIUS 的操作不属于本课程的范围。</p><hr><h3 id="UDP-客户端进程"><a href="#UDP-客户端进程" class="headerlink" title="UDP 客户端进程"></a>UDP 客户端进程</h3><p>与 TCP 一样，客户端应用向服务器进程请求数据，便会发起客户端-服务器通信。UDP 客户端进程则是从可用端口号中动态挑选一个端口号，用来作为会话的源端口。而目的端口通常都是分配到服务器进程的公认端口号或注册端口号。</p><p>客户端选定了源端口和目的端口后，通信事务中的所有数据报头都采用相同的端口对。对于从服务器到达客户端的数据来说，数据报头所含的源端口号和目的端口号作了互换。</p><ul><li><strong>发送 UDP 请求的客户端</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_29_1.png" alt="客户端1使用公认端口53发送DNS请求，而客户端2使用注册端口1812请求RADIUS身份验证服务"></p><ul><li><strong>请求目的端口</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_29_2.png" alt="客户端的请求会动态生成源端口号。在这种情况下，客户端 1 使用源端口 49152，客户端 2 使用源端口 51152"></p><ul><li><strong>UDP 请求源端口</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_29_3.png" alt="当服务器响应客户端请求时，它会反转发起请求的目的端口和源端口"></p><ul><li><strong>UDP 响应目的端口</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_29_4.png" alt="在服务器中，对DNS请求的响应目的端口现在是49152，而RADIUS身份验证的响应目的端口现在是51152"></p><ul><li><strong>UDP 响应源端口</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/12_29_5.png" alt="服务器响应中的源端口是发起请求中的原始目的端口"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>数据传输</strong></li></ul><blockquote><p>传输层是应用层与负责网络传输的下层之间的纽带。传输层负责在不同主机上运行的应用程序之间进行逻辑通信。传输层包括 TCP 和 UDP 。传输层协议指定如何在主机之间传输消息，并负责管理会话的可靠性要求。传输层负责跟踪对话（会话）、分段数据和数据段重组、添加报头信息、识别应用程序和会话复用。TCP有状态的、可靠的、确认数据、重新发送丢失的数据，并按顺序传递数据。将 TCP 用于电子邮件和Web。UDP是无状态的、快速、开销低、不需要确认、不重新发送丢失的数据，并按照到达的顺序传递数据。将 UDP 用于 VoIP 和 DNS。</p></blockquote><ul><li><strong>TCP概述</strong></li></ul><blockquote><p>TCP 建立会话、确保可靠性、提供同序传递并支持流量控制。在封装应用层数据时，TCP数据段增加了20字节的开销作为报头信息。TCP报头字段包括源和目的端口、序列号、确认号、报头长度、保留、控制位、窗口大小、校验和和紧急。使用TCP的应用程序有HTTP、FTP、SMTP和Telnet。</p></blockquote><ul><li><strong>UDP概述</strong></li></ul><blockquote><p>UDP按照接收数据的顺序重构数据，不重新发送丢失的数据段，不建立会话，以及UDP不会通知发送方资源可用性。UDP报头字段是源和目的端口、长度和校验和。使用UDP的应用程序有DHCP、DNS、SNMP、TFTP、VoIP和视频会议。</p></blockquote><ul><li><strong>端口号</strong></li></ul><blockquote><p>TCP 和 UDP 传输层协议使用端口号来管理多个同时对话。这就是为什么TCP和UDP报头字段标识源和目的应用程序端口号。源端口和目的端口都被置入分段内，然后分段封装于 IP 数据包内。IP 数据包中含有源 IP 地址和目的 IP 地址。源 IP 地址和源端口号的组合或者目的 IP 地址和目的端口号的组合，称为套接字。套接字用于标识客户端所请求的服务器和服务。端口号的范围是从0到65535。此范围分为几组：公认端口、注册端口、专用端口和/或动态端口。有一些公认端口号保留给常见的应用程序，如 FTP、SSH、DNS、HTTP 和其他应用程序。有些时候，需要了解联网主机中启用并运行了哪些活动 TCP 连接。Netstat 是一种重要的网络实用程序，可用来检验此类连接。</p></blockquote><ul><li><strong>TCP通信过程</strong></li></ul><blockquote><p>在服务器上运行的每个应用程序进程都配置为使用一个端口号。端口号由系统管理员自动分配或手动配置。TCP服务器进程如下:客户端发送TCP请求，请求目的端口，请求源端口，响应目的端口和源端口请求。若要终止 TCP 支持的整个会话过程，需要实施四次交换，以终止两个双向会话。客户端或服务器都可以发起终止。三次握手确定目的设备是否存在于网络上，验证目的设备是否有活动服务，接受发起客户端打算使用的目的端口号上的请求，并通知目的设备源客户端打算在该端口号上建立一个通信会话。六个控制位标志是：URG、ACK、PSH、RST、SYN 和 FIN。</p></blockquote><ul><li><strong>可靠性与流量控制</strong></li></ul><blockquote><p>因此，为了让接收方理解原始消息，必须接收所有数据，并重组这些数据段，使其恢复原有顺序。每个数据包中的数据段报头中都含有序列号。无论网络设计得有多好，数据丢失还是时有发生。TCP 提供了管理数据段丢失的方法。对于未确认的数据，有一种重传数据段的机制。今天的主机操作系统通常采用一种称为选择性确认 (SAK) 的可选 TCP 功能，在三次握手期间协商。如果两个主机都支持SACK，则接收方可以明确地确认接收了哪些数据段(字节)，包括任何不连续的段。因此，发送主机只需要重新传输丢失的数据。流量控制可以调整源和目的地之间的数据流速，有助于保持 TCP 传输的可靠性。为此，TCP 报头包括一个称为“窗口大小”的 16 位字段。目的设备在处理接收的字节并不断调整源设备的发送窗口大小时发送确认的过程被称为滑动窗口。在每个TCP数据段内，源主机可能正在传输 1460 字节的数据。这是目的设备可以接收的典型 MSS。为避免和控制拥塞，TCP 使用了多个拥塞处理机制。源设备在减少其发送的未确认的字节数量，而不是由目的设备来确定窗口大小。</p></blockquote><ul><li><strong>UDP通信</strong></li></ul><blockquote><p>UDP 是一种简单协议，提供基本的传输层功能。当将多个 UDP 数据报发送到目的主机时，它们通常采用不同的路径，到达顺序也可能跟发送时的顺序不同。与 TCP 不同，UDP 不跟踪序列号。UDP 不会对数据报重组，因此也不会将数据恢复到传输时的顺序。UDP 仅仅是将接收到的数据按照先来后到的顺序转发到应用程序。如果数据顺序对应用很重要，应用必须确定正确的顺序并决定如何处理数据。为基于 UDP 的服务器应用程序分配公认或已注册的端口号。当 UDP 收到用于某个端口的数据报时，它就会按照应用的端口号将数据发送到相应的应用。UDP 客户端进程则是从可用端口号中动态挑选一个端口号，用来作为会话的源端口。而目的端口通常都是分配到服务器进程的公认端口号或注册端口号。客户端选定了源端口和目的端口后，通信事务中的所有数据报头都使用相同的端口对。对于从服务器到达客户端的数据来说，数据报头所含的源端口号和目的端口号作了互换。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理 • （三）网络层</title>
      <link href="School-Computer-Network-Technology-3-Network-Layer/"/>
      <url>School-Computer-Network-Technology-3-Network-Layer/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇是对<a href="https://phoenixnest.github.io/Notes-Computer-Network-Technology/">计算机网络原理</a>一文中的<a href="https://phoenixnest.github.io/School-Computer-Network-Technology/#%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88%E7%AC%AC-3-%E5%B1%82%EF%BC%89">网络层</a>的详细介绍。<br>所用教学平台：<a href="%22https://cn.netacad.com/%22">Cisco Networking Academy</a></p></blockquote><hr><h2 id="网络层（第3层）"><a href="#网络层（第3层）" class="headerlink" title="网络层（第3层）"></a>网络层（第3层）</h2><blockquote><p>网络层即 OSI 第 3 层，提供能够让终端设备跨整个网络交换数据的服务。如图所示，IP 版本 4 (IPv4) 和 IP 版本 6 (IPv6) 是主要的网络层通信协议。其他网络层协议包括<strong>路由协议</strong>，如开放式最短路径优先协议(OSPF)，和<strong>消息传递协议</strong>，如<strong>Internet控制消息协议</strong>(ICMP)。</p></blockquote><h3 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h3><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_1.png" alt="网络层"></p><p>为了实现跨网络边界的端到端通信，<code>网络层协议执行四个基本操作</code>:</p><ul><li><p><strong>终端设备编址</strong> - 必须为终端设备配置唯一的 IP 地址，以便在网络上进行识别。</p></li><li><p><strong>封装</strong> - 网络层将来自传输层的<strong>协议数据单元 (PDU)</strong> 封装到数据包中。封装过程中会添加 IP 报头信息，例如来源（发送）和目的（接收）主机的 IP 地址。封装过程由 IP 数据包的源主机执行。</p></li><li><p><strong>路由</strong> - 网络层提供服务，将数据包转发至另一网络上的目的主机。要传送到其他网络，数据包必须经过路由器的处理。路由器的作用是为数据包选择最佳路径，并将其转发至目的主机，该过程称为路由。数据包可能需要经过很多路由器才能到达目的主机。数据包在到达目的主机的过程中经过的每个路由器均称作一跳。</p></li><li><p><strong>解封</strong> - 当数据包到达目的主机的网络层时，主机会检查数据包的 IP 报头。如果在报头中的目的 IP 地址与其自身的 IP 地址匹配，IP 报头将被会从数据包中删除。网络层解封数据包后，后继的第 4 层 PDU 会向上传递到传输层的相应服务。解封过程由 IP 数据包的目的主机执行。</p></li></ul><blockquote><p>传输层（OSI 第 4 层）负责管理每台主机上的运行进程之间的数据传输，而网络层通信协议（即，IPv4和IPv6）则指定从一台主机向另一台主机传送数据时使用的数据包结构和处理过程。网络层工作时无需考虑每个数据包中所携带的数据，这使其能够为多台主机之间的多种类型的通信传送数据包。</p></blockquote><hr><h3 id="IP-封装"><a href="#IP-封装" class="headerlink" title="IP 封装"></a>IP 封装</h3><blockquote><p>IP 通过添加 IP 报头将传输层（网络层之上的层）数据段或其他数据进行封装。IP报头用于将数据包传送到目的主机。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_2.png" alt="网络层 PDU 如何封装传输层 PDU 来创建 IP 数据包"></p><p>逐层封装数据的流程使我们可以开发和扩展位于不同层的服务而不影响其他层。<strong>这意味着传输层数据段可以随时通过 IPv4 或 IPv6 进行封装，或使用未来可能开发出的任何新协议进行封装</strong>。</p><p><code>IP数据包在通过网络传输到其目的地时，会被第3层设备（即路由器和第3层交换机）检查IP报头</code>。需要注意的是，<code>从数据包离开源主机到达目的主机之前，IP编址信息保持不变，除非是由为IPv4执行网络地址转换(NAT)的设备进行转换</code>。</p><blockquote><p>路由器实施路由协议以在网络之间路由数据包。这些中间设备所执行的路由进程会检查数据包报头中的网络层地址。在任何情况下，数据包的数据部分，即封装的传输层 PDU或其他数据，在网络层的各个过程中都保持不变。</p></blockquote><hr><h3 id="IP-特征"><a href="#IP-特征" class="headerlink" title="IP 特征"></a>IP 特征</h3><blockquote><p>IP 被设计为一种低开销协议。它只提供通过互连的网络系统从源主机向目的主机传送数据包所必需的功能。<strong>该协议并不负责跟踪和管理数据包的流动</strong>。<code>这些功能（如果需要）将由其他层的其他协议（主要是第 4 层的 TCP）执行</code>。</p></blockquote><p>这些是IP的基本特征：</p><ul><li><p><strong>无连接</strong> - 发送数据包前不与目的地建立连接。</p></li><li><p><strong>尽力而为</strong> - IP本质上是不可靠的，因为不保证数据包交付。</p></li><li><p><strong>介质无关性</strong> - 其工作与传输数据的介质（即铜缆、光纤或无线）无关。</p></li></ul><hr><h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><blockquote><p>IP 是无连接协议，这意味着发送数据前IP不会创建专用的端到端连接。<code>无连接通信的概念类似于不事先通知收件人就邮寄信件</code>。图中总结了这些要点。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_3_1.png" alt="无连接 - 类比"></p><blockquote><p>无连接数据通信按照同样的原理工作。如图所示，IP 在转发数据包前，并<code>不需要初步交换控制信息来创建端到端连接</code>。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_3_2.png" alt="无连接 - 网络"></p><hr><h3 id="“尽力而为”-Best-Effort"><a href="#“尽力而为”-Best-Effort" class="headerlink" title="“尽力而为”(Best Effort)"></a>“尽力而为”(Best Effort)</h3><blockquote><p><code>IP 也不需要报头中包含其他字段来维持建立的连接</code>。此过程<strong>显著降低了 IP 的开销</strong>。但是，<strong>由于没有预先建立端到端连接，发送数据包时，发送方不知道目的地是否存在和正常运行，同时发送数据包时，也不会知道目的地是否接收数据包，或者，目的设备是否可以访问并读取数据包</strong>。</p></blockquote><p>IP 协议不保证交付的所有数据包都能被收到。图中显示了 IP 协议不可靠或尽力交付的特征。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_4.png" alt="IP 协议不可靠或尽力交付的特征"></p><hr><h3 id="介质无关性"><a href="#介质无关性" class="headerlink" title="介质无关性"></a>介质无关性</h3><blockquote><p><strong>不可靠</strong><code>表示 IP 不具备管理和恢复未送达数据包或已损坏数据包的能力</code>。</p><blockquote><p>这是因为，在根据传输位置信息传输 IP 数据包时，数据包不包含可以经过处理以通知发送方信息交付是否成功的消息。传送到时，数据包可能已经损坏或顺序错乱，或者根本就没有传送成功。<code>如果出错，IP 无法重新传输数据包</code>。</p></blockquote></blockquote><blockquote><p>如果数据包顺序错乱或丢失，则使用数据或上层服务的应用程序必须解决这些问题。这让 IP 可以非常有效地发挥作用。<code>在 TCP/IP 协议簇中，可靠性是TCP协议在传输层的功能</code>。</p></blockquote><p><code>IP 的工作与在协议栈低层传送数据的介质无关</code>。如图所示，IP 数据包既可以作为电信号通过铜缆传送，也可以作为光信号通过光纤传送或作为无线电信号无线传送。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_5.png" alt="可以通过不同介质传送 IP 数据包"></p><p><strong>OSI 数据链路层</strong>负责接收数据包并准备数据包以在通信介质上传输。<code>这就意味着 IP 数据包的交付不限于任何特定的介质</code>。</p><p>但是，网络层会考虑介质的一个重要特征：每种介质可以传输的最大 PDU 大小。此特征称为最大传输单位 (MTU)。数据链路层和网络层之间的部分控制通信就是确定数据包的最大尺寸。数据链路层将 MTU 值向上传送到网络层。网络层会由此确定可以传送的数据包的大小。</p><p>有时，中间设备（通常是路由器），在将<code>IPv4数据包</code>从一个介质转发到具有更小 MTU 的介质时，<code>必须分割数据包</code>。此过程称为数据包分片或分片。<code>分片会导致延迟</code>。<code>IPv6 数据包不能被路由器分片</code>。</p><hr><h2 id="IPv4-数据包"><a href="#IPv4-数据包" class="headerlink" title="IPv4 数据包"></a>IPv4 数据包</h2><h3 id="IPv4-数据包报头"><a href="#IPv4-数据包报头" class="headerlink" title="IPv4 数据包报头"></a>IPv4 数据包报头</h3><blockquote><p>IPv4 是主要网络层通信协议之一。IPv4 数据包报头用于确保此数据包在到达目的地终端设备的路上被传递到其下一站。</p></blockquote><blockquote><p>IPv4 数据包报头是由包含重要数据包信息的字段组成。这些字段中包含的二进制数字由第 3 层进程进行检查。</p></blockquote><hr><h3 id="IPv4-数据包报头字段"><a href="#IPv4-数据包报头字段" class="headerlink" title="IPv4 数据包报头字段"></a>IPv4 数据包报头字段</h3><blockquote><p>每个字段的二进制值均用于确定 IP 数据包的各种设置。协议报头图（从左到右、从上到下阅读）可提供在讨论协议字段时参考的直观图。图中所示的 IP 协议报头图标识了 IPv4 数据包中的字段。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_7.png" alt="IPv4数据包报头中的字段"></p><p><code>两种最常参考的字段是源和目的 IP 地址</code>。<strong>这些字段用于确定数据包的源位置和目的位置</strong>。通常，在从源传输到目的地期间，这些地址不会改变。</p><p><strong>互联网报头长度（IHL）</strong>、<strong>总长度</strong>和<strong>报头校验</strong>和<strong>字段</strong><code>用于识别和验证数据包</code>。</p><blockquote><p><code>其他字段用于重新排列分段的数据包</code>。具体而言，<strong>IPv4 数据包使用标识符、标志和片偏移量字段跟踪分段</strong>。<strong>路由器从一种介质向具有较小 MTU 的另一种介质转发IPv4数据包时必须将它分片</strong>。</p></blockquote><hr><h2 id="IPv6-数据包"><a href="#IPv6-数据包" class="headerlink" title="IPv6 数据包"></a>IPv6 数据包</h2><h3 id="IPv4-的局限性"><a href="#IPv4-的局限性" class="headerlink" title="IPv4 的局限性"></a>IPv4 的局限性</h3><blockquote><p>多年来，为应对新的挑战，已经制定了附加议定书和规程。但是，尽管经历了多次变更，IPv4 仍然有三个重要问题：</p></blockquote><ul><li><strong>IPv4地址耗尽</strong> -  IPv4 的<code>可用唯一公有地址数量有限</code>。尽管<code>有大约 40 亿的 IPv4 地址</code>，但是支持 IP 的新设备数量的不断增加，以及始终在线的连接的增加，和欠发达地区的潜在连接的增加，不断催生更多的地址需求。</li><li><strong>缺乏端到端连接</strong> -  <strong>网络地址转换（NAT）</strong>是 IPv4 网络中经常实施的一项技术。NAT 为多种设备共享单一的公有 IPv4 地址提供方法。但是，因<code>为共享了公有 IPv4 地址，内部网络主机的 IPv4 地址会隐藏起来。这会给需要端到端连接的技术造成难题</code>。</li><li><strong>增加的网络复杂性</strong> - 虽然 NAT 延长了 IPv4 的寿命，但它只是作为一种过渡到 IPv6 的机制。NAT 在其各种实施中增加了网络的复杂性，从而造成延迟并使故障排除更加困难。</li></ul><hr><h3 id="IPv6-概述"><a href="#IPv6-概述" class="headerlink" title="IPv6 概述"></a>IPv6 概述</h3><p>早在 20 世纪 90 年代早期，互联网工程任务组 (IETF) 就增加了对 IPv4 相关问题的关注并开始寻找替代方案。这促使了 IP 版本 6 (IPv6) 的开发。IPv6 解决了 IPv4 的限制并有着显著的功能提升，它能更好地适应当前和可预见的网络需求。</p><blockquote><p>IPv6 的功能提升包括以下：</p></blockquote><ul><li><p><strong>更大的地址空间</strong> - IPv6 地址基于 128 位分层编址，而 IPv4 采用的是 32 位。</p></li><li><p><strong>改进数据包处理过程</strong> - IPv6 报头简化为更少的字段。</p></li><li><p><strong>消除了对 NAT 的需求</strong> - 有了数额如此巨大的公有 IPv6 地址，私有 IPv4 地址和公有 IPv4 地址之间不再需要 NAT。这可避免需要端到端连接的应用程序遇到某些由 NAT 引起的故障。</p></li></ul><p>32 位的 IPv4 地址空间提供大约 4,294,967,296 个地址。IPv6 地址空间提供 340,282,366,920,938,463,463,374,607,431,768,211,456 个或 340 涧（10 的 36 次方）个地址。这大致相当于地球上的每一粒沙子。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_9.png" alt="IPv4 和 IPv6 地址空间的可视比较"></p><hr><h3 id="IPv6数据包报头中的IPv4数据包报头字段"><a href="#IPv6数据包报头中的IPv4数据包报头字段" class="headerlink" title="IPv6数据包报头中的IPv4数据包报头字段"></a>IPv6数据包报头中的IPv4数据包报头字段</h3><blockquote><p>IPv6 较 IPv4 的一个重大改进是简化的 IPv6 报头。</p></blockquote><p>例如，IPv4 报头包含 20 个二进制八位组的可变长度报头（如果使用“选项”字段，则高达 60 字节）和 12 个基本报头字段（不包括“选项”字段和“填充”字段）。</p><blockquote><p>对于 IPv6，某些字段保持不变，某些字段的名称和位置发生了变化，而某些 IPv4 字段不再需要，正如图中突出显示。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_10_1.png" alt="IPv4 数据包报头"></p><blockquote><p>相比而言，下图显示的简化 IPv6 报头包含 40 个二进制八位数的固定长度报头（主要为源和目的 IPv6 地址的长度）。</p></blockquote><p><code>IPv6 简化报头允许更高效地处理 IPv6 报头</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_10_2.png" alt="IPv6 数据包报头"></p><hr><h3 id="IPv6-数据包报头"><a href="#IPv6-数据包报头" class="headerlink" title="IPv6 数据包报头"></a>IPv6 数据包报头</h3><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_11.png" alt="IPv6 数据包报头"></p><blockquote><p>IPv6 数据包还可能包含扩展报头（EH），以便提供可选的网络层信息。扩展报头为可选项，位于 IPv6 报头及负载之间。EH 用于分段、安全性、移动性支持等。</p></blockquote><p><code>与 IPv4 不同，路由器不会对路由的 IPv6 数据包进行分段</code>。</p><hr><h2 id="主机路由方式"><a href="#主机路由方式" class="headerlink" title="主机路由方式"></a>主机路由方式</h2><h3 id="主机转发决策"><a href="#主机转发决策" class="headerlink" title="主机转发决策"></a>主机转发决策</h3><blockquote><p>对于IPv4和IPv6，数据包总是在源主机上创建。源主机必须能够将数据包定向到目的主机。为此，主机终端设备将创建自己的路由表。本主题讨论终端设备如何使用路由表。</p></blockquote><p><strong>网络层的另一个作用是在主机之间转发数据包</strong>。主机可以将数据包发送至如下：</p><ul><li><p><strong>主机自己</strong> - 主机可以通过向特定的地址发送数据包来向自己发起ping测试，这个特定的地址是：IPv4地址127.0.0.1，或者IPv6地址 ::1，它被称为环回接口。对环回接口执行 ping 操作可以测试主机上的 TCP/IP 协议堆栈。</p></li><li><p><strong>本地主机</strong> - 目的主机与发送主机位于同一本地网络。源和目的主机共享同一个网络地址。</p></li><li><p><strong>远程主机</strong> - 这是位于远程网络上的目的主机。源和目的主机不共享同一个网络地址。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_12.png" alt=" PC1 连接到同一网络上的本地主机和位于另一网络上的远程主机"></p><blockquote><p><code>数据包是要发送到本地主机还是远程主机是由源端设备决定的</code>。<strong>源端设备确定目的 IP 地址是否与源设备本身所在的网络相同。确定方法因 IP 版本不同而异</strong>：</p></blockquote><ul><li><p><strong>在 IPv4 中</strong> -源设备使用自己的子网掩码以及自己的 IPv4 地址和目的 IPv4 地址来进行此判断。</p></li><li><p><strong>在 IPv6 中</strong> -本地路由器将本地网络地址（前缀）通告给网络上的所有设备。</p></li></ul><p>在家庭或企业网络中，您可能有若干通过中间设备（<strong>LAN 交换机</strong>和/或<strong>无线接入点（WAP）</strong>等）互联的有线和无线设备。这种中间设备在本地网络上的本地主机之间提供互联服务。本地主机可以互相访问和共享信息，无需任何附加设备。如果主机要将数据包发送到与本主机在同一 IP 网络中的设备，则数据包仅是被转发出主机接口，然后经过中间设备即可直接到达目的设备。</p><p>当然，在大多数情况下我们希望我们的设备不仅仅能够连接本地网段，还能连接其他家庭、企业和互联网。位于本地网段外的设备称为远程主机。<code>如果源设备发送数据包到远程目的设备，则需要借助路由器和路由。路由是确定到达目的地之最佳路径的过程。连接到本地网段的路由器称为默认网关</code>。</p><hr><h3 id="默认网关"><a href="#默认网关" class="headerlink" title="默认网关"></a>默认网关</h3><blockquote><p>默认网关是可以将流量路由到其他网络的网络设备（即，路由器或第3层交换机）。如果把一个网络比作一个房间，那么默认网关就好比是门口。如果要去另一个房间或网络，您就需要找到门口。</p></blockquote><p>在网络上，<code>默认网关通常是</code>具有以下功能的<code>路由器</code>：</p><ul><li><p>它拥有与本地网络其他主机位于相同地址范围的本地 IP 地址。</p></li><li><p>它可以接受数据到本地网络，并将数据转发出本地网络。</p></li><li><p>它向其他网络路由流量。</p></li></ul><blockquote><p>需要使用默认网关来发送本地网络之外的流量。如果没有默认网关、未配置默认网关地址或默认网关关闭，则无法将流量转发到本地网络之外。</p></blockquote><hr><h3 id="主机路由到默认网关"><a href="#主机路由到默认网关" class="headerlink" title="主机路由到默认网关"></a>主机路由到默认网关</h3><p>主机的路由表通常包括默认网关。在IPv4中，主机通过动态主机配置协议 (DHCP) 动态接收默认网关 IPv4 地址，或者通过手动配置。在 IPv6 中，路由器通告默认网关地址，或者可以在主机上手动配置。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_13.png" alt="PC1 和 PC2 均配置了 IPv4 地址 192.168.10.1作为默认网关"></p><p>配置默认网关会在 PC 的路由表中创建一个默认路由。默认路由是计算机尝试联系远程网络时所用的路由或路径。</p><p>PC1 和 PC2 都会使用默认路由将去往远程网络的所有流量发送到 R1。</p><hr><h3 id="主机路由表"><a href="#主机路由表" class="headerlink" title="主机路由表"></a>主机路由表</h3><p>在 Windows 主机上，使用route print或命netstat -r令可以显示主机路由表。这两个命令生成相同的输出。输出可能乍一看很晦涩，但是实际上相当容易理解。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_14.png" alt="PC1 和 PC2 均配置了 IPv4 地址 192.168.10.1作为默认网关"></p><pre><code class="bash"># PC1 的 IPv4 路由表C:\Users\PC1&gt; netstat -r IPv4 Route Table===========================================================================Active Routes:Network Destination Netmask Gateway Interface Metric0.0.0.0 0.0.0.0 192.168.10.1 192.168.10.10 25127.0.0.0 255.0.0.0 On-link 127.0.0.1 306127.0.0.1 255.255.255.255 On-link 127.0.0.1 306127.255.255.255 255.255.255.255 On-link 127.0.0.1 306192.168.10.0 255.255.255.0 On-link 192.168.10.10 281192.168.10.10 255.255.255.255 On-link 192.168.10.10 281192.168.10.255 255.255.255.255 On-link 192.168.10.10 281224.0.0.0 240.0.0.0 On-link 127.0.0.1 306224.0.0.0 240.0.0.0 On-link 192.168.10.10 281255.255.255.255 255.255.255.255 On-link 127.0.0.1 306255.255.255.255 255.255.255.255 On-link 192.168.10.10 281</code></pre><p>输入<strong>netstat -r</strong>命令或等效的<strong>route print</strong>命令，显示有关当前 TCP/IP 网络连接的三个部分：</p><ul><li><p><strong>接口列表</strong> - 列出主机上的介质访问控制（MAC）地址和每个网络接口的已分配接口编号，包括以太网、Wi-Fi 和蓝牙适配器。</p></li><li><p><strong>IPv4 路由表</strong> - 列出所有已知的 IPv4 路由，包括直接连接、本地网络和本地默认路由。</p></li><li><p><strong>IPv6 路由表</strong> - 列出所有已知的 IPv6 路由，包括直接连接、本地网络和本地默认路由。</p></li></ul><hr><h2 id="路由简介"><a href="#路由简介" class="headerlink" title="路由简介"></a>路由简介</h2><h3 id="路由器数据包转发决策"><a href="#路由器数据包转发决策" class="headerlink" title="路由器数据包转发决策"></a>路由器数据包转发决策</h3><blockquote><p>大多数网络还包含作为中间设备的路由器。路由器中也包含路由表。本主题涵盖网络层上路由器的运行。当一台主机发送数据包到另一台主机时，它将查询路由表来确定将数据包发送到哪里。如果目的主机位于远程网络，则数据包会被转发到默认网关，通常是本地路由器。</p></blockquote><blockquote><p>数据包到达路由器接口时，路由器会检查数据包的目的 IP 地址并搜索其路由表以确定将数据包转发到何处。<code>路由表包含所有已知网络地址（前缀）以及数据包转发位置的列表。这些条目称为路由条目或路由</code>。<strong>路由器将使用最佳（最长）匹配的路由条目转发数据包</strong>。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_15.png"><p>下表显示了来自<code>R1路由表</code>的相关信息。</p><table><thead><tr><th align="center">路由</th><th align="center">下一跳或出口接口</th></tr></thead><tbody><tr><td align="center">192.168.10.0 /24</td><td align="center">G0/0/0</td></tr><tr><td align="center">209.165.200.224/30</td><td align="center">G0/0/1</td></tr><tr><td align="center">10.1.1.0/24</td><td align="center">通过 R2</td></tr><tr><td align="center">默认路由 0.0.0.0/0</td><td align="center">通过 R2</td></tr></tbody></table><hr><h3 id="IP-路由器路由表"><a href="#IP-路由器路由表" class="headerlink" title="IP 路由器路由表"></a>IP 路由器路由表</h3><p><code>路由器的路由表包含所有可能的已知目的地网络的路由条目列表。</code></p><p>路由表存储三种类型的路由条目：</p><ul><li><p><strong>直连网络</strong> - 这些网络路由条目是活动的路由器接口。当接口配置了 IP 地址并激活时，路由器会添加直连路由。每个路由器接口均连接到一个不同的网段。在图中，R1 IPv4路由表中的直连网络为192.168.10.0/24和209.165.200.224/30。</p></li><li><p><strong>远程网络</strong> - 这些网络路由条目连接到其他路由器。路由器通过由管理员明确配置或使用动态路由协议交换路由信息来学习远程网络。在图中，R1 IPv4路由表中的远程网络为10.1.1 /24。</p></li><li><p><strong>默认路由</strong> - 像主机一样，大多数路由器还包含默认路由条目，即默认网关。当IP路由表中没有更好(更长)的匹配时，将使用默认路由。在图中，R1 IPv4路由表很可能包含一个将所有数据包转发到路由器R2的默认路由。</p></li></ul><p>该图用于确定路由器 R1 的直连和远程网络。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_16.png"><p>路由器可通过两种方式获知远程网络：</p><ul><li><p><strong>手动</strong> - 使用静态路由将远程网络手动输入到路由表中。</p></li><li><p><strong>动态</strong> - 使用动态路由协议自动学习远程路由。</p></li></ul><hr><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><blockquote><p><strong>静态路由是手动配置的路由条目</strong>。下图显示了在路由器 R1 上手动配置的静态路由的示例。<strong>静态路由包括远程网络地址和下一跳路由器的IP地址</strong>。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_17_1.png"><blockquote><p>如果网络拓扑改变，静态路由不会自动更新，必须手动重新配置静态路由。例如，在图中，R1有一条通过R2到达10.1.1.0/24网络的静态路由。如果该路径不再可用，R1将需要重新配置一个新的静态路由，通过R3到达10.1.1.0/24网络。因此，路由器R3需要在其路由表中有一个路由条目，以便将目的地为10.1.1.0/24的数据包发送到R2。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_17_2.png"><p>静态路由具有以下特征：</p><ul><li><p><code>必须手动配置静态路由</code>。</p></li><li><p>如果拓扑发生变化，且静态路由不再可用，则管理员需要重新配置静态路由。</p></li><li><p>静态路由适用于小型网络且当冗余链路很少或没有冗余链路的情况。</p></li><li><p>静态路由通常与动态路由协议一起用于配置默认路由。</p></li></ul><hr><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><blockquote><p><code>动态路由协议可让路由器从其他路由器那里自动学习远程网络，包括默认路由</code>。如果使用动态路由协议，则路由器无需网络管理员的参与，即可自动与其它路由器共享路由信息并对拓扑结构的变化作出反应。如果网络拓扑发生变化，路由器将使用动态路由协议共享此信息，并自动更新路由表。</p></blockquote><p><code>动态路由协议</code>包括<strong>开放式最短路径优先路由协议（OSPF）</strong>和<strong>增强型内部网关路由协议（EIGRP）</strong>。该图显示了路由器 R1 和 R2 使用路由协议 OSPF 自动共享网络信息的示例。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_18_1.png"><p><code>基本配置只需要网络管理员在动态路由协议中启用直连网络</code>。动态路由协议将自动执行如下操作：</p><ul><li><p>发现远程网络。</p></li><li><p>维护最新路由信息。</p></li><li><p>选择通往目的网络的最佳路径。</p></li><li><p>当前路径无法再使用时尝试找出新的最佳路径。</p></li></ul><p><strong>当使用静态路由手动配置路由器或使用动态路由协议动态学习远程网络时，远程网络地址和下一跳地址将被输入到IP路由表中</strong>。如图所示，如果网络拓扑发生变化，路由器将自动调整并尝试找到新的最佳路径。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_18_2.png"><p>注意: <strong>通常一些路由器会同时使用静态路由和动态路由协议</strong>。</p><hr><h3 id="IPv4-路由表简介"><a href="#IPv4-路由表简介" class="headerlink" title="IPv4 路由表简介"></a>IPv4 路由表简介</h3><blockquote><p>请注意，在图中 R2 连接到了互联网。因此，当路由表中没有与目的IP 地址匹配的特定条目时，管理员将为 R1 配置默认静态路由，将数据包发送到 R2。R1和R2还使用OSPF路由来通告直连的网络。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/6_19.png"><pre><code class="CISCO">R1# show ip routeCodes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area        N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2       E1 - OSPF external type 1, E2 - OSPF external type 2       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2       ia - IS-IS inter area, * - candidate default, U - per-user static route       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP       a - application route       + - replicated route, % - next hop override, p - overrides from PfRGateway of last resort is 209.165.200.226 to network 0.0.0.0S*    0.0.0.0/0 [1/0] via 209.165.200.226, GigabitEthernet0/0/1      10.0.0.0/24 is subnetted, 1 subnetsO        10.1.1.0 [110/2] via 209.165.200.226, 00:02:45, GigabitEthernet0/0/1      192.168.10.0/24 is variably subnetted, 2 subnets, 2 masksC        192.168.10.0/24 is directly connected, GigabitEthernet0/0/0L        192.168.10.1/32 is directly connected, GigabitEthernet0/0/0      209.165.200.0/24 is variably subnetted, 2 subnets, 2 masksC        209.165.200.224/30 is directly connected, GigabitEthernet0/0/1L        209.165.200.225/32 is directly connected, GigabitEthernet0/0/1R1#</code></pre><p>特权 <strong>EXEC</strong> 模式命令 <strong>show ip route</strong> 用于查看<code>思科 IOS 路由器</code>上的 IPv4 路由表。该示例显示了路由器 R1 的 IPv4 路由表。每个路由表条目的开头都有一个代码，用于标识路由的类型或路由的学习方式。常见路由源（代码）包括以下内容：</p><ul><li><p><strong>L</strong> - 直连的本地接口 IP 地址</p></li><li><p><strong>C</strong> - 直连网络</p></li><li><p><strong>S</strong> - 静态路由由管理员手动配置</p></li><li><p><strong>O</strong> - OSPF</p></li><li><p><strong>D</strong> - EIGRP</p></li></ul><p>路由表显示 R1 的所有已知 IPv4 目的地路由。</p><blockquote><p>当路由器接口配置了IP地址信息并激活时，将自动创建直连路由。该路由器添加了两个带有代码C(即所连接的网络)，和L(即连接网络的本地接口IP地址)的路由条目。路由条目还标识用于到达网络的出口接口。</p></blockquote><p>本示例中的两个直连网络分别为192.168.10.0/24 和 209.165.200.224/30。</p><p>路由器 R1 和 R2 还使用 OSPF 动态路由协议交换路由器信息。在示例路由表中，R1 具有 10.1.1.0/24 网络的路由条目，它通过 OSPF 路由协议从路由器 R2 中动态学习到该条目。</p><p>默认路由具有全都是零的网络地址。例如，IPv4 网络地址为 0.0.0.0。路由表中的静态路由条目以 S\ * 的代码开头，如示例中突出显示的那样。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>网络层特征</li></ul><blockquote><p>网络层（OSI 第 3 层），提供能够让终端设备跨整个网络交换数据的服务。IPv4 和 IPv6 是主要的网络层通信协议。网络层还包括路由协议 OSPF 和消息传递协议（如 ICMP）。网络层协议执行四个基本操作：寻址终端设备、封装、路由和解封。IPv4和IPv6指定从一台主机向另一台主机传送数据时使用的数据包结构和处理过程。IP 通过添加 IP 报头来封装传输层数据段，以便传输到目的主机。第3层设备（即路由器）在通过网络传输到其目的地时，会检查IP报头。IP 的特点是它是无连接的、尽最大努力的，并且独立于介质。IP 是无连接协议，这意味着发送数据前IP不会创建专用的端到端连接。IP 协议不保证交付的所有数据包都能被收到。这就是“不可靠”或“尽最大努力”的定义。IP 的运作与在协议栈低层传送数据的介质无关。</p></blockquote><ul><li>IPv4数据包</li></ul><blockquote><p>IPv4 数据包报头是由包含数据包信息的字段组成。这些字段中包含的二进制数字由第 3 层进程进行检查。每个字段的二进制值均用于确定 IP 数据包的各种设置。IPv6报头中的重要字段包括:版本、DS、报头校验和、TTL、协议以及源和目的IPv4地址。</p></blockquote><ul><li>IPv6数据包</li></ul><blockquote><p>IPv6 旨在克服 IPv4 的局限性，包括：IPv4 地址耗尽、缺乏端到端连接以及网络复杂性增加。IPv6 增加了可用的地址空间，改进了数据包处理，并且消除了对 NAT 的需求。IPv6数据包报头中的字段包括：版本、流量类别、流标签、负载长度、下一个报头、跳数限制，以及源IPv6地址和目的IPv6地址。</p></blockquote><ul><li>主机如何路由</li></ul><blockquote><p>主机可以向自己、另一个本地主机和远程主机发送数据包。在 IPv4 中，源设备使用自己的子网掩码以及自己的 IPv4 地址和目的 IPv4 地址确定目的主机是否位于同一网络上。在 IPv6 中，本地路由器将本地网络地址（前缀）通告给网络上的所有设备，以做出此决定。默认网关是可以将流量路由到其他网络的网络设备（即路由器）。在网络上，默认网关通常是一个路由器，它的本地IP地址与本地网络上的其他主机位于相同的地址范围内，可以将数据接收到本地网络并将数据转发到本地网络之外，并将流量路由到其他网络。主机的路由表通常包括默认网关。在IPv4中，主机通过DHCP动态接收默认网关 IPv4 地址，或者通过手动配置。在 IPv6 中，路由器通告默认网关地址，或者可以手动配置主机。在 Windows 主机上，使用route print或命netstat -r令可以显示主机路由表。</p></blockquote><ul><li>路由简介</li></ul><blockquote><p>当一台主机发送数据包到另一台主机时，它将查询路由表来确定将数据包发送到哪里。如果目的主机位于远程网络，则数据包会转发到默认网关。当数据包到达路由器接口时会发生什么? 路由器检查数据包的目的 IP 地址并搜索其路由表以确定将数据包转发到何处。路由表包含所有已知网络地址（前缀）以及数据包转发位置的列表。这些条目称为路由条目或路由。路由器将使用最佳（最长）匹配的路由条目转发数据包。路由器的路由表存储三种类型的路由条目：直连的网络、远程网络和默认路由。路由器通常以动态方式使用路由协议或以手动方式使用静态路由来学习远程网络。静态路由是手动配置的路由条目。静态路由包括远程网络地址和下一跳路由器的IP地址。OSPF 和 EIGRP 是两种动态路由协议。特权 EXEC 模式命令 show ip route 用于查看思科 IOS 路由器上的 IPv4 路由表。IPv4路由表的开头都有一个代码，用于标识路由的类型或路由的学习方式。</p></blockquote><p>常见路由源（代码）包括：</p><ol><li><strong>L</strong> - 直连的本地接口 IP 地址</li><li><strong>C</strong> - 直连网络</li><li><strong>S</strong> - 静态路由由管理员手动配置</li><li><strong>O</strong> - 开放最短路径优先 (OSPF)</li><li><strong>D</strong> - 增强型内部网关路由协议 (EIGRP)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理 • （二）数据链路层</title>
      <link href="School-Computer-Network-Technology-2-Data-Link-Layer/"/>
      <url>School-Computer-Network-Technology-2-Data-Link-Layer/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇是对<a href="https://phoenixnest.github.io/Notes-Computer-Network-Technology/">计算机网络原理</a>一文中的<a href="https://phoenixnest.github.io/School-Computer-Network-Technology/#%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88%E7%AC%AC-3-%E5%B1%82%EF%BC%89">数据链路层</a>的详细介绍。<br>所用教学平台：<a href="%22https://cn.netacad.com/%22">Cisco Networking Academy</a></p></blockquote><hr><h2 id="数据链路层（第2层）"><a href="#数据链路层（第2层）" class="headerlink" title="数据链路层（第2层）"></a>数据链路层（第2层）</h2><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_1.png" alt="层级示意图"></p><blockquote><p>OSI模型的数据链路层（第2层）为物理网络准备网络数据。数据链路层负责网络接口卡（NIC）到网络接口卡的通信。数据链路层执行以下操作：</p></blockquote><ul><li><p>允许上层访问介质。上层协议完全不知道用于转发数据的介质类型。</p></li><li><p>接受数据，通常是第 3 层数据包（即 IPv4 或 IPv6），并将它们封装到第 2 层帧中。</p></li><li><p>控制数据在介质上的放置和接收方式，</p></li><li><p>通过网络介质在终端之间交换帧。</p></li><li><p>接收封装的数据，通常是第 3 层数据包，并将它们定向到适当的上层协议。</p></li><li><p>执行错误检测并拒绝任何损坏的帧。</p></li></ul><hr><p>在计算机网络中，<code>节点是可以沿通信路径接收、创建、存储或转发数据的设备</code>。节点可以是笔记本电脑或移动电话等终端设备，也可以是中间设备如以太网交换机。</p><p>如果没有数据链路层，则网络层协议（如：IP）必须提供连接到传输路径中可能存在的各种类型介质所需的连接。此外，<code>每当开发出一种新的网络技术或介质时，IP必须做出相应调整</code>。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_1_1.png"><hr><h3 id="IEEE-802LAN-MAN-数据链路子层"><a href="#IEEE-802LAN-MAN-数据链路子层" class="headerlink" title="IEEE 802LAN/MAN 数据链路子层"></a>IEEE 802LAN/MAN 数据链路子层</h3><blockquote><p>IEEE 802 LAN/MAN 标准专用于以太网局域网、无线局域网（WLAN）、无线个人区域网（WPAN）和其他类型的局域网和城域网。IEEE 802 LAN/MAN 数据链路层由以下两个子层组成：</p></blockquote><ul><li><strong>逻辑链路控制（LLC）</strong> - 这个 IEEE 802.2 子层在上层的网络软件与下层的设备硬件之间进行通信。它放入帧中的信息用于确定帧所使用的网络层协议。此信息允许多个第 3 层协议（如 IPv4 和 IPv6）使用相同的网络接口和介质。</li><li><strong>介质访问控制（MAC）</strong> - 在硬件上实现这个子层（IEEE 802.3、802.11 或 802.15）。它负责数据封装和介质访问控制。它提供数据链路层寻址，并与各种物理层技术集成。</li></ul><hr><p>该图显示了数据链路层的两个子层（LLC 和 MAC）。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_2.png" alt="数据链路子层"></p><blockquote><p>LLC 子层获取网络协议数据（通常是 IPv4 或 IPv6数据包）并加入第2层控制信息，帮助将数据包传送到目的节点。</p></blockquote><p>MAC 子层控制网卡和负责在有线或无线LAN/MAN介质上发送和接收数据的其他硬件。</p><p>MAC 子层提供数据封装：</p><ul><li><p><strong>帧定界</strong> - 在成帧过程中提供重要的定界符，用来标识帧中的字段。这些定界符位可以在发送节点与接收节点之间提供同步。</p></li><li><p><strong>编址</strong> - 提供源和目的编址，用于在同一共享介质上的设备之间传输第 2 层帧。</p></li><li><p><strong>错误检测</strong> - 包含一个帧尾，用于检测传输错误。</p></li></ul><p>MAC 子层还提供介质访问控制，允许多个设备通过共享（半双工）介质进行通信。全双工通信不需要访问控制。</p><hr><h3 id="提供介质访问"><a href="#提供介质访问" class="headerlink" title="提供介质访问"></a>提供介质访问</h3><blockquote><p>在数据包从本地主机传送到远程主机的过程中，其遇到的各种网络环境可能具有不同的特性。</p></blockquote><p>例如，以太网 LAN 通常由许多争用网络介质访问的主机组成。</p><p>MAC 子层解决了这个问题。对于串行链路，访问方法可能只包括两个设备之间的直接连接，通常是两个路由器。因此，它们不需要 IEEE 802 MAC 子层所使用的技术。</p><blockquote><p>路由器接口将数据包封装到适当的帧中。使用合适的介质访问控制方法来访问每个链路。在任意指定的网络层数据包交换过程中，可能存在多次数据链路层和介质的转换。</p></blockquote><p>在路径上的每一跳，路由器都执行以下第 2 层功能：</p><ol><li>从介质接受帧</li><li>解封帧</li><li>将数据包重新封装到新帧中</li><li>从适合该物理网络网段的介质转发新帧</li></ol><hr><h3 id="数据链路层（第2层）标准"><a href="#数据链路层（第2层）标准" class="headerlink" title="数据链路层（第2层）标准"></a>数据链路层（第2层）标准</h3><blockquote><p>与 TCP/IP 的上层协议不同，数据链路层协议通常不是由征求意见 (RFC) 文档定义的。互联网工程任务组 (IETF) 虽然维护着 TCP/IP 协议簇上层的工作协议和服务，但它没有定义TCP/IP模型的网络接入层的功能和操作。</p></blockquote><p>定义适用于网络接入层（即，OSI的物理和数据链路层）的开放标准和协议的工程组织包括：</p><ul><li><p><strong>电气电子工程师协会 (IEEE)</strong></p></li><li><p><strong>国际电信联盟 (ITU)</strong></p></li><li><p><strong>国际标准化组织 (ISO)</strong></p></li><li><p><strong>美国国家标准学会 (ANSI)</strong></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_3.png" alt="工程组织徽标"></p><hr><h2 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h2><h3 id="物理和逻辑拓扑"><a href="#物理和逻辑拓扑" class="headerlink" title="物理和逻辑拓扑"></a>物理和逻辑拓扑</h3><blockquote><p>网络拓扑是指网络设备及它们之间的互连布局或关系。</p></blockquote><p>描述 LAN 和 WAN 网络时使用两种类型的拓扑：</p><p><strong>物理拓扑</strong> - 标识物理连接，以及终端设备和中间设备（即，路由器、交换机和无线接入点）如何互连。这个拓扑还可能包括特定的设备位置，如房间号和设备机架上的位置。物理拓扑通常是点对点拓扑或星型拓扑。</p><p><strong>逻辑拓扑</strong> - 是指网络将帧从一个节点传输到另一节点的方法。此拓扑使用设备接口和第 3 层 IP 寻址方案识别虚拟连接。</p><blockquote><p>在控制对介质的数据访问时，数据链路层“看见”的是网络的逻辑拓扑。正是<strong>逻辑拓扑在影响网络成帧和介质访问控制的类型</strong>。</p></blockquote><table><thead><tr><th align="center"><strong>物理拓补</strong></th><th align="center"><strong>总线拓补</strong></th></tr></thead><tbody><tr><td align="center"><img align="center" style="margin:8px" src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_4_1.png" /></td><td align="center"><img align="center" style="margin:8px" src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_4_2.png" /></td></tr></tbody></table><hr><h3 id="WAN-拓补"><a href="#WAN-拓补" class="headerlink" title="WAN 拓补"></a>WAN 拓补</h3><table><thead><tr><th align="center"><strong>点对点</strong></th><th align="center"><strong>中心辐射型</strong></th><th align="center"><strong>网状</strong></th></tr></thead><tbody><tr><td align="center"><img align="center" style="margin:8px" src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_5_1.png" /></td><td align="center"><img align="center" style="margin:8px" src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_5_2.png" /></td><td align="center"><img align="center" style="margin:8px" src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_5_3.png" /></td></tr></tbody></table><blockquote><p>混合拓扑是任何拓扑的变体或组合。例如，部分网状就是一种混合拓扑，因为其中一些而并非所有的终端设备都是互连的。</p></blockquote><hr><h3 id="点对点-WAN-拓扑"><a href="#点对点-WAN-拓扑" class="headerlink" title="点对点 WAN 拓扑"></a>点对点 WAN 拓扑</h3><blockquote><p>物理点对点拓扑直接连接两个节点。在这种布局中，<strong>两个节点无需与其他主机共享介质</strong>。此外，当使用串行通信协议，如点对点协议(PPP)时，节点无需判定收到的帧是指向它还是指向另一节点。</p></blockquote><p>因此，逻辑数据链路协议将非常简单，因为介质中的所有帧都只去往或来自这两个节点。节点将帧放置到一端的介质上，然后点对点线路另一端的节点从介质取走帧。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_6_1.png"><p>注意：通过以太网进行的点对点连接需要设备确定传入帧是否发往此节点。</p><p>使用多个中间设备，距离较远的源节点和目的节点彼此可以间接相连。但是，在网络中使用物理设备并不会影响逻辑拓扑，如图所示。在图中，添加中间物理连接不会改变逻辑拓扑。逻辑点对点连接相同。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_6_2.png"><hr><h3 id="LAN-拓扑"><a href="#LAN-拓扑" class="headerlink" title="LAN 拓扑"></a>LAN 拓扑</h3><blockquote><p>在多路访问局域网中，终端设备（即节点）使用<code>星型或扩展星型</code>拓扑相互连接，如图所示。在这种类型的拓扑中，终端设备连接到一个中央中间设备，在本例中是一个以太网交换机。扩展星型（扩展星型）通过连接多个以太网交换机来扩展此拓扑。星型和扩展星型拓扑安装简单、扩展性好（易于添加和删除终端设备），而且故障排除容易。早期的星型拓扑使用以太网集线器互连终端设备。</p></blockquote><p>有时可能只有两个设备连接在以太网局域网上。两个相互连接的路由器就是一个例子。</p><p><code>传统LAN拓扑</code></p><blockquote><p>早期的以太网和传统令牌环局域网技术包括另外两种拓扑结构:</p></blockquote><ul><li><p><strong>总线</strong> - <code>所有终端系统都相互连接</code>，并在两端以某种形式端接。终端设备互连时不需要基础设施设备（例如交换机）。传统的以太网络中会使用采用同轴电缆的总线拓扑，因为它<code>价格低廉而且安装简易</code>。</p></li><li><p><strong>环</strong> - <code>终端系统与其各自的邻居相连</code>，形成一个环状。与总线拓扑不同，环拓扑不需要端接。传统的光纤分布式数据接口 (FDDI) 和令牌环网络使用环拓扑。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_7.png" alt="物理拓扑"></p><hr><h3 id="半双工与全双工通信"><a href="#半双工与全双工通信" class="headerlink" title="半双工与全双工通信"></a>半双工与全双工通信</h3><blockquote><p>半双工通信</p></blockquote><p>两台设备都可以通过该介质发送和接收，但<code>无法同时执行</code>这两个操作。WLAN和带有以太网集线器的传统总线拓扑使用半双工模式。半双工<code>每次只允许一台设备</code>通过共享介质发送或接收。</p><blockquote><p>全双工通信</p></blockquote><p>两台设备都可以在共享介质上<code>同时发送和接收</code>。数据链路层假定介质随时可供两个节点实现传输。默认情况下，以太网交换机在全双工模式下运行，<code>但是如果与以太网集线器等设备连接，它们则可以在半双工模式下运</code>行。</p><blockquote><p>总之，<strong>半双工通信限制为每次在一个方向进行数据交换</strong>。<strong>全双工允许同时发送和接收数据</strong>。两个互连设备，比如一个主机网卡和以太网交换机上的一个接口，必须采用同一双工模式运行。否则，将会出现双工不匹配，导致链路效率低下和延时。</p></blockquote><hr><h3 id="访问控制方法"><a href="#访问控制方法" class="headerlink" title="访问控制方法"></a>访问控制方法</h3><blockquote><p>以太网 LAN 和 WLAN 都是多路访问网络的示例。多路访问网络是指可能有两个或多个终端设备同时试图访问网络的网络。</p><p>某些多路访问网络需要使用规则来管理设备共享物理介质的方式。对于共享介质，有两种基本的访问控制方法：</p></blockquote><ul><li><p><strong>基于竞争的访问</strong></p><blockquote><p>在基于竞争的多路访问网络中，<code>所有节点都工作在半双工方式，争夺介质的使用</code>。然而，<code>一次只有一台设备能够发送</code>。因此，当多台设备同时传输时，会使用一个处理过程。</p></blockquote><p>基于竞争的访问方法示例如下：</p><ul><li>在传统总线拓扑以太网局域网上使用载波侦听多路访问/冲突检测 (CSMA/CD)</li><li>在无线局域网上使用载波侦听多路访问/冲突避免 (CSMA/CA)</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_9_1.png" alt="基于竞争的访问"></p><ul><li><p><strong>受控访问</strong></p><blockquote><p>在基于控制的多路访问网络中，<code>每个节点都有自己的时间来使用介质</code>。这种确定性的传统网络类型效率很低，因为设备必须等到轮到自己才能访问介质。使用受控访问的多路访问网络的示例包括：</p></blockquote><ul><li>传统令牌环</li><li>传统ARCNET</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_9_2.png" alt="受控访问"></p><blockquote><p>注意: <strong>如今，以太网网络以全双工方式运行，不需要访问方法。</strong></p></blockquote><hr><h3 id="基于竞争的访问-CSMA-CD"><a href="#基于竞争的访问-CSMA-CD" class="headerlink" title="基于竞争的访问 - CSMA/CD"></a>基于竞争的访问 - CSMA/CD</h3><p>基于竞争的访问网络示例如下：</p><ul><li><p>无线局域网（使用 CSMA/CA）</p></li><li><p>传统总线拓扑以太网局域网（使用 CSMA/CD）</p></li><li><p>使用集线器的传统以太网局域网（使用 CSMA/CD）</p></li></ul><p>这些网络在<code>半双工模式</code>下运行，意味着<code>一台设备一次只能发送或接收</code>。这<code>需要有一个进程来管理设备何时可以发送以及当多台设备同时发送时会发生什么情况</code>。</p><p>如果两台设备<code>同时传输</code>，则会发生<code>冲突</code>。<strong>对于传统以太网局域网，两台设备将会检测到网络上的冲突。这就是 CSMA/<code>CD</code> 的冲突检测（<code>CD</code>）部分。</strong>网卡通过比较传输的数据与接收的数据，或通过识别介质中的信号振幅是否高于正常状况来实现。<code>两台设备发送的数据会损坏且需重新发送</code>。</p><blockquote><p>PC1 有一个以太网帧要发送给 PC3。PC1 的网卡需要确定是否有设备正在通过介质传输。如果它没有检测到载波信号，也就是说，它没有收到来自其他设备的传输，则假定网络可用于发送。</p><p>当介质可用时，PC1 NIC 发送以太网帧，如图所示。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_10_1.png" alt="PC1发送帧"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_10_2.png" alt="集线器接收帧"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_10_3.png" alt="集线器发送帧"></p><hr><h3 id="基于竞争的访问-CSMA-CA"><a href="#基于竞争的访问-CSMA-CA" class="headerlink" title="基于竞争的访问 - CSMA/CA"></a>基于竞争的访问 - CSMA/CA</h3><p><strong>IEEE 802.11 WLAN</strong> 所使用的另一种 CSMA 形式为载波侦听多路访问/冲突避免 (CSMA/<code>CA</code>)。</p><p>CMSA/<code>CA</code> 采用一种与 CSMA/CD 类似的方法来检测介质是否空闲。CMSA/<code>CA</code> 采用其他技术。在无线环境中，设备可能无法检测到冲突。<strong>CMSA/<code>CA</code> 不会检测冲突</strong>，但会通过在传输之前等待来尝试避免冲突。每台设备发送时都会包含传输所需的持续时间。所有其他无线设备都会收到此信息，知道介质将有多长时间不可用。</p><blockquote><p>在图中，如果主机 A 从接入点接收到一个无线帧，那么主机 B 和 C 也会看到该帧以及介质有多久不可用。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_11.png" alt="集线器发送帧"></p><p>当无线设备发送 802.11 帧后，接收方会返回确认，以使发送方知道帧已到达。</p><p>不管是使用集线器的以太网 LAN，还是 WLAN，基于竞争的系统在介质使用率高的情况下都无法很好地扩展。</p><p><code>注意：</code>使用交换机的以太网 LAN 不使用基于竞争的系统，因为交换机和主机网卡在全双工模式下运行。</p><hr><h2 id="数据链路帧"><a href="#数据链路帧" class="headerlink" title="数据链路帧"></a>数据链路帧</h2><h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><blockquote><p>数据链路层通过使用<code>帧头和帧尾</code>将其封装以<code>创建帧</code>，从而<code>准备封装后的数据</code>（通常是IPv4或IPv6数据包），以便在本地介质上进行传输。</p><p>数据链路协议负责<code>同一网络中的网卡间通信</code>。虽然有许多描述数据链路层帧的不同数据链路层协议，但每种帧均有<code>三个基本组成部分</code>：</p></blockquote><ul><li>帧头</li><li>数据</li><li>帧尾</li></ul><p>与其他封装协议不同，<code>数据链路层以帧尾的形式在帧的末尾附加信息</code>。</p><blockquote><p><strong>所有数据链路层协议均将数据封装于帧的数据字段内</strong>。但是，由于协议的不同，帧结构以及帧头和帧尾中包含的字段会存在差异。</p></blockquote><p><strong>没有一种帧结构能满足通过所有类型介质的全部数据传输需求</strong>。根据环境的不同，帧中所需的控制信息量也相应变化，以匹配介质和逻辑拓扑的访问控制需求。例如，WLAN帧必须包含避免冲突的过程，因此与以太网帧相比需要额外的控制信息。</p><p>如图所示，在脆弱的环境下，需要更多控制才能确保送达。<code>由于所需控制信息较多，因此帧头和帧尾字段都较大</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_12.png" alt="帧"></p><hr><h3 id="帧字段"><a href="#帧字段" class="headerlink" title="帧字段"></a>帧字段</h3><blockquote><p>成帧技术将位流拆分成可破解的多个分组，且将控制信息作为不同字段值插入帧头和帧尾中。此格式使物理信号具备能被节点识别且可在目的地解码成数据包的一种结构。</p></blockquote><p>图中显示了<code>通用帧字段</code>。<code>并非所有协议均包含全部此类字段</code>。特定数据链路协议的标准定义了实际帧格式。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_13.png" alt="帧字段"></p><p>数据链路层协议将帧尾添加到各帧结尾处。</p><blockquote><p>在一个叫做<code>错误检测</code>的过程中，帧尾会判断帧是否到达时没有错误。它将组成帧的各个位的逻辑或数学摘要放入帧尾中。要将错误检测添加到数据链路层，因为介质中的信号可能遭受干扰、失真或丢失，从而大幅更改这些信号所代表的位值。</p></blockquote><p>发送节点会创建帧内容的逻辑摘要，称为循环冗余校验（CRC）值。此值将放入帧校验序列（FCS）字段中以代表帧内容。在以太网尾部，FCS 为接收节点提供一种方法，用于确定帧是否出现传输错误。</p><hr><h3 id="第2层地址"><a href="#第2层地址" class="headerlink" title="第2层地址"></a>第2层地址</h3><blockquote><p>数据链路层提供了通过共享本地介质传输帧时要用到的编址。此层中的设备地址称为物理地址。<code>数据链路层地址包含在帧头中</code>，它指定了帧在本地网络中的目的节点。它通常位于帧的开头，因此<code>网卡可以在接受帧的其余部分之前快速确定它是否匹配自己的第 2 层地址</code>。<code>帧头还可能包含帧的源地址</code>。</p></blockquote><p>与分层式第 3 层逻辑地址不同，物理地址不会表示设备位于哪个网络。相反，<code>物理地址对于特定设备是唯一的。即使设备移至另一网络或子网，它将仍使用相同的第 2 层物理地址</code>。因此，<code>第2层地址仅用于在相同的共享介质中，在相同的IP网络上连接设备</code>。</p><p>该图阐述了第 2 层和第 3 层地址的功能。当 IP 数据包从主机到路由器、从路由器到路由器和最终从路由器到主机传输时，沿途中的每个点上都会将 IP 数据包封装到新的数据链路帧中。每个数据链路帧包含发送帧的网卡的源数据链路地址和接收帧的网卡的目的数据链路地址。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_14_1.png" alt="主机到路由器 - 源主机将第 3 层IP数据包封装成第 2 层帧。在帧头中，主机将其第 2 层地址添加为源地址，R1 的第 2 层地址添加为目的地址。"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_14_2.png" alt="路由器到路由器 - R1 将第 3 层IP数据包封装成新的第 2 层帧。在帧头中，R1 将其第 2 层地址添加为源地址，R2 的第 2 层地址添加为目的地址。"></p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/4_14_3.png" alt="路由器到主机 - R2 将第 3 层IP数据包封装成新的第 2 层帧。在帧头中，R2 将其第 2 层地址添加为源地址，服务器的第 2 层地址添加为目的地址。"></p><p>数据链路层地址仅用于本地传送。该层地址在本地网络之外无任何意义。将它与第 3 层进行比较，我们发现在第 3 层中，无论途中有多少个网络跳点，数据包报头中的地址都会从源主机传送到目的主机。</p><blockquote><p>如果数据必须传递到另一网段上，则需要使用中间设备，比如路由器。路由器必须<code>根据物理地址接受帧并解封帧，以便检查分层地址，即 IP 地址</code>。路由器使用 IP 地址可以确定目的设备的网络地址以及到达该地址的最佳路径。当知道要将数据包转发到何处时，路由器会为数据包创建一个新帧，并将新帧发送到通往最终目的地的下一网段。</p></blockquote><hr><h3 id="LAN-和-WAN-上的帧"><a href="#LAN-和-WAN-上的帧" class="headerlink" title="LAN 和 WAN 上的帧"></a>LAN 和 WAN 上的帧</h3><blockquote><p><code>以太网协议由有线局域网使用。无线通信属于无线局域网（IEEE 802.11）协议范围</code>。这些协议都是<code>为多路访问网络而设计</code>的。</p></blockquote><p>WAN 传统上在各种类型的点对点、中心辐射和全网状拓扑中使用其他类型的协议。多年来，一些<code>常见的广域网协议</code>包括：</p><ul><li><p><strong>点对点协议 (PPP)</strong></p></li><li><p><strong>高级数据链路控制 (HDLC)</strong></p></li><li><p><strong>帧中继</strong></p></li><li><p><strong>异步传输模式 (ATM)</strong></p></li><li><p><strong>X.25</strong></p></li></ul><blockquote><p>这些第2层协议现在正在被以太网在广域网中取代。</p></blockquote><p>在 TCP/IP 网络中，<code>所有 OSI 第 2 层协议都与 OSI 第 3 层的 IP 一起使用</code>。但是，所用的第 2 层协议取决于逻辑拓扑和物理介质。</p><p>每个协议执行指定第 2 层逻辑拓扑的介质访问控制。这意味着在执行这些协议时，有很多种不同的网络设备都可以充当运行在数据链路层上的节点。这些设备包括计算机上的网卡以及路由器和第 2 层交换机上的接口。</p><p><code>用于特定网络拓扑的第 2 层协议取决于实施该拓扑的技术。所使用的技术取决于网络规模（根据主机数量和地理范围判断）以及通过网络提供的服务</code>。</p><p><code>LAN 通常使用能支持大量主机的高带宽技术</code>。由于 LAN 的地理范围相对较小（单个建筑物或多个建筑物的园区），用户的密集度高，因此这种技术比较节约成本。</p><p>但是，对于服务范围较广（例如一个城市或多个城市）的 WAN，使用高带宽技术通常不够经济。长距离物理链路的成本以及长距离传送信号的技术一般都会使带宽容量降低。</p><p><code>带宽差异常会导致 LAN 和 WAN 使用不同的协议</code>。</p><p>数据链路层协议包括：</p><ul><li><p><strong>以太网</strong></p></li><li><p><strong>802.11 无线</strong></p></li><li><p><strong>点对点协议 (PPP)</strong></p></li><li><p><strong>高级数据链路控制 (HDLC)</strong></p></li><li><p><strong>帧中继</strong></p></li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>数据链路层的用途</li></ul><blockquote><p>OSI模型的数据链路层(第2层)为物理网络准备网络数据。数据链路层负责网络接口卡 (NIC) 到网络接口卡的通信。如果没有数据链路层，则网络层协议（如 IP）必须提供连接到传输路径中可能存在的各种类型介质所需的连接。IEEE 802 LAN/MAN 数据链路层由以下两个子层组成：LLC和MAC。MAC子层通过帧定界符、编址和错误检测提供数据封装。路由器接口将数据包封装到适当的帧中。使用合适的介质访问控制方法来访问每个链路。定义适用于数据链路层的开放标准和协议的工程组织包括： IEEE、ITU、ISO和ANSI。</p></blockquote><ul><li>拓扑</li></ul><blockquote><p>局域网和广域网中使用的两种拓扑是物理拓扑和逻辑拓扑。在控制对介质的数据访问时，数据链路层“看见”的是网络的逻辑拓扑。逻辑拓扑影响所使用的网络成帧和介质访问控制的类型。三种常见的物理 WAN 拓扑类型是：点对点、中心辐射以及网状。物理点对点拓扑直接连接两个终端设备(节点)。添加中间物理连接不会改变逻辑拓扑。在多路访问局域网中，节点使用星型或扩展星型拓扑相互连接。在这种类型的拓扑中，节点连接到一个中央中间设备。物理局域网拓扑包括：星型、扩展星型、总线和环型。半双工通信每次在一个方向进行数据交换。全双工同时发送和接收数据。两个相互连接的接口必须使用相同的双工模式，否则将出现双工不匹配，从而导致链路上的效率低下和延迟。以太网 LAN 和 WLAN 都是多路访问网络的示例。多路访问网络是指可能有多个节点同时访问网络的网络。某些多路访问网络需要使用规则来管理设备共享物理介质的方式。共享介质有两种基本访问控制方法：基于竞争的访问和受控访问。在基于竞争的多路访问网络中，所有节点都以半双工形式运行。当多台设备同时传输时，会使用一个进程。基于竞争的访问方法的示例包括：用于总线拓扑以太网局域网的 CSMA/CD 和用于 WLAN 的 CSMA/CA。</p></blockquote><ul><li>数据链路层帧</li></ul><blockquote><p>数据链路层通过使用帧头和帧尾进行封装以创建帧，从而准备封装后的数据（通常是IPv4或IPv6数据包），以便在本地介质上进行传输。数据链路层协议负责同一网络中的网卡间通信。有许多描述数据链路层帧的不同数据链路层协议，但每种帧均有三个基本组成部分：帧头、数据和帧尾。与其他封装协议不同，数据链路层在帧尾中附加信息。没有一种帧结构能满足通过所有类型介质的全部数据传输需求。根据环境的不同，帧中所需的控制信息量也相应变化，以匹配介质和逻辑拓扑的访问控制需求。帧字段包括：帧起始和停止标志、编址、类型、控制、数据和错误检测。数据链路层提供了通过共享本地介质传输帧时要用到的编址。此层中的设备地址是物理地址。数据链路层地址包含在帧头中，它指定了帧在本地网络中的目的节点。数据链路层地址仅用于本地传送。在 TCP/IP 网络中，所有 OSI 第 2 层协议都与 OSI 第 3 层的 IP 一起使用。但是，所用的第 2 层协议取决于逻辑拓扑和物理介质。每个协议执行指定第 2 层逻辑拓扑的介质访问控制。用于特定网络拓扑的第 2 层协议取决于实施该拓扑的技术。数据链路层协议包括：以太网、802.11 无线、PPP、HDLC 和帧中继。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理 • （一）物理层</title>
      <link href="School-Computer-Network-Technology-1-Physical-Layer/"/>
      <url>School-Computer-Network-Technology-1-Physical-Layer/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇是对<a href="https://phoenixnest.github.io/Notes-Computer-Network-Technology/">计算机网络原理</a>一文中的<a href="https://phoenixnest.github.io/School-Computer-Network-Technology/#%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%88%E7%AC%AC-1-%E5%B1%82%EF%BC%89">物理层</a>的详细介绍。<br>所用教学平台：<a href="%22https://cn.netacad.com/%22">Cisco Networking Academy</a></p></blockquote><hr><h2 id="物理层（第1层）"><a href="#物理层（第1层）" class="headerlink" title="物理层（第1层）"></a>物理层（第1层）</h2><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/3_1.png" alt="层级示意图"></p><blockquote><p>OSI物理层通过网络介质传输构成数据链路层帧的比特（位）。该层从数据链路层接收完整的帧，并将这些帧编码为一系列信号，传输到本地介质上。帧由经过编码的比特（位）构成，这些位可以被终端设备或中间设备接收。</p></blockquote><hr><h2 id="物理层的特征"><a href="#物理层的特征" class="headerlink" title="物理层的特征"></a>物理层的特征</h2><h3 id="物理层标准"><a href="#物理层标准" class="headerlink" title="物理层标准"></a>物理层标准</h3><blockquote><p>OSI上层的协议及操作是使用软件工程师和计算机科学家设计的软件来执行的。TCP/IP 协议簇中的服务和协议是由互联网工程任务组（IETF）定义的。</p></blockquote><p><code>物理层由工程师开发的电子电路、介质和连接器组成</code>。因此，由相关的电气和通信工程组织定义管制该硬件的标准是很合适的。</p><p>在物理层标准的制定和维护中涉及许多不同的国际和国家组织、政府监管机构和私营企业。例如，物理层硬件、介质、编码和信令标准由以下组织定义和管理：</p><ul><li><p><strong>国际标准化组织（ISO）</strong></p></li><li><p><strong>电信工业协会/电子工业协会（TIA/EIA）</strong></p></li><li><p><strong>国际电信联盟（ITU）</strong></p></li><li><p><strong>美国国家标准学会（ANSI）</strong></p></li><li><p><strong>电气电子工程师协会（IEEE）</strong></p></li><li><p><strong>国家级电信管理局：包括美国联邦通信委员会（FCC）和欧洲电信标准协会 (ETSI）</strong></p></li></ul><p>除了这些组织之外，通常还有<code>地方性布线标准组织</code>，例如 <strong>CSA：（加拿大标准协会）</strong>、<strong>CENELEC（欧洲电工标准化委员会）</strong>和 <strong>JSA/JIS（日本标准协会）</strong>，开发<code>本地规范</code>。</p><hr><h3 id="物理组件"><a href="#物理组件" class="headerlink" title="物理组件"></a>物理组件</h3><p>物理层标准管理三个功能区：</p><ul><li><p><strong>物理组件</strong></p></li><li><p><strong>编码</strong></p></li><li><p><strong>信令</strong></p></li></ul><blockquote><p>物理组件</p><blockquote><p>物理组件是电子硬件设备、介质和其他连接器，它们用于传输用于表示位的信号。网卡、接口和连接器、线缆材料以及线缆设计等硬件组件均按照物理层的相关标准进行规定。Cisco 1941 路由器上的各种端口和接口也属于物理组件，根据标准使用特定连接器和引脚。</p></blockquote></blockquote><hr><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><blockquote><p>编码或线路编码是一种将数据位流转换为预先定义“代码”的方法。这些代码就是位的编组，用于提供一种可预测模式，以便发送者和接收者均能识别。换句话说，<strong>编码是用于表示数字信息的方法或模式</strong>。这类似于摩尔斯电码如何使用一系列点和短划线编码消息。</p></blockquote><p>例如，<code>曼彻斯特编码的0位表示为从高到低的电压转换，而1位表示为从低到高的电压转换</code>。曼彻斯特编码的一个示例如图所示。转换在每个位周期的中间进行。这种类型的编码用于10Mbps的以太网。更快的数据速率需要更复杂的编码。</p><p>曼彻斯特编码用于较旧的以太网标准，如：10BASE-T（双绞线以太网）。 以太网 100BASE-TX使用4B/5B编码。1000BASE-T使用8B/10B编码。</p><p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/3_2.png" alt="曼彻斯提编码"></p><hr><h3 id="信令"><a href="#信令" class="headerlink" title="信令"></a>信令</h3><blockquote><p>物理层必须在介质上生成代表“1”和“0”的电信号、光信号或无线信号。<strong>表示位的方法称为信令方法</strong>。物理层标准必须定义哪种类型的信号代表“1”，而哪种类型的信号代表“0”。这可以简单到只是改变电信号或光脉冲的级别。例如，长脉冲可能代表 1，而短脉冲可能代表 0。</p></blockquote><p>这类似于莫尔斯电码中使用的信令方法，可以使用一系列开关音、灯或点击通过电话线或在海上船舶之间发送文本。</p><ul><li>铜缆</li></ul><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/3_3_1.png"><ul><li>光缆</li></ul><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/3_3_2.png"><ul><li>无线介质</li></ul><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Notes/Computer%20Network%20Technology/3_3_3.png"><hr><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>不同的物理介质所支持的位传输速率不同。数据传输的讨论通常都会提及带宽。</p><p><strong>带宽是介质承载数据的能力。</strong></p><blockquote><p>数字带宽可以测量在给定时间内从一个位置流向另一个位置的数据量。带宽通常使用千位每秒（kbps）、兆位每秒（Mbps）或千兆位每秒（Gbps）来度量。有时带宽被认为是位传输的速度，而这是不准确的。例如，在 10Mbps 和 100Mbps 的以太网上，都以电的速率发送位。不同的是每秒传输的位的数量。</p></blockquote><p>多种因素的结合，决定了网络的实际带宽：</p><p>物理介质的属性</p><ul><li><p>信令和检测网络信号所选用的技术</p></li><li><p>物理介质属性、当前技术和物理法则共同扮演确定可用带宽的角色。</p></li></ul><table><thead><tr><th align="center">带宽单位</th><th align="center">缩写</th><th align="left">单位</th></tr></thead><tbody><tr><td align="center">位/秒</td><td align="center">bps</td><td align="left">1 bps = 带宽的基本单位</td></tr><tr><td align="center">千位/秒</td><td align="center">Kbps</td><td align="left">1 Kbps = 1,000 bps = 10^3bps</td></tr><tr><td align="center">兆位/秒</td><td align="center">Mbps</td><td align="left">1 Mbps = 1,000,000 bps = 10^6 bps</td></tr><tr><td align="center">千兆位/秒</td><td align="center">Gbps</td><td align="left">1 Gbps = 1,000,000,000 bps = 10^9 bps</td></tr><tr><td align="center">兆兆位/秒</td><td align="center">Tbps</td><td align="left">1 Tbps = 1,000,000,000,000 bps = 10^12 bps</td></tr></tbody></table><hr><h3 id="带宽术语"><a href="#带宽术语" class="headerlink" title="带宽术语"></a>带宽术语</h3><p>用来衡量带宽质量的术语包括:</p><ul><li><p><strong>延迟</strong></p></li><li><p><strong>吞吐量</strong></p></li><li><p><strong>实际吞吐量</strong></p></li></ul><hr><h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><blockquote><p>延迟是指数据从一个给定点传送到另一给定点所用的时间，包括时延。</p></blockquote><p>在拥有多个网段的网际网络或网络中，<code>吞吐量不能超过从源到目的地之间路径的最低链路</code>。纵使这些网段全部或多数具备高速带宽，它也只使用那段低速率路径的吞吐量，这就会造成整个网络的吞吐量瓶颈。</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><blockquote><p>吞吐量是给定时段内通过介质传输的位的量度。</p></blockquote><p>由于各种因素的影响，吞吐量经常与物理层实施中指定的带宽不符。吞吐量通常低于带宽。影响吞吐量的因素有很多:</p><ul><li><p>流量大小</p></li><li><p>流量类型</p></li><li><p>从源通往目的地的过程中遇到的网络设备数量所造成的延时。</p></li></ul><h3 id="实际吞吐量"><a href="#实际吞吐量" class="headerlink" title="实际吞吐量"></a>实际吞吐量</h3><blockquote><p>用于评估可用数据传输的第三个测量标准称为实际吞吐量。实际吞吐量是在给定时间段内传输的有用数据的衡量标准。</p></blockquote><p>实际吞吐量就是<code>吞吐量减去建立会话、确认、封装和重传所产生的流量开销</code>。</p><p>实际吞吐量总是低于吞吐量，而吞吐量通常低于带宽。</p><hr><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><h3 id="频分复用-FDM"><a href="#频分复用-FDM" class="headerlink" title="频分复用 FDM"></a>频分复用 FDM</h3><blockquote><p>所有用户在同样的时间占用不同的带宽资源。</p></blockquote><h3 id="时分复用-TDM"><a href="#时分复用-TDM" class="headerlink" title="时分复用 TDM"></a>时分复用 TDM</h3><blockquote><p>又称<code>同步时分复用</code>，即所有用户在不同的时间占用同样的频带宽度。</p></blockquote><h3 id="统计时分复用-STDM"><a href="#统计时分复用-STDM" class="headerlink" title="统计时分复用 STDM"></a>统计时分复用 STDM</h3><blockquote><p>又称<code>异步时分复用</code>，是一种改进的时分复用，能明显提高信道的利用率。集中器常使用。</p><p>各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入 STDM 帧中。</p><p><code>对没有数据的缓存就跳过去</code>。</p><p><code>当一个帧的数据满了，就发送出去</code>。</p><blockquote><p><strong>从平均角度看，异步时分复用与同步时分复用二者是平衡的</strong>。</p></blockquote></blockquote><hr><h3 id="波分复用-WDM"><a href="#波分复用-WDM" class="headerlink" title="波分复用 WDM"></a>波分复用 WDM</h3><blockquote><p>光的频分复用。</p></blockquote><hr><h3 id="码分复用-CDM"><a href="#码分复用-CDM" class="headerlink" title="码分复用 CDM"></a>码分复用 CDM</h3><blockquote><p>码分多址（CDMA），使每一个用户可以在同样的时间使用同样的频带进行通信，由于用户通过使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</p><p>使用码分复用的每一个站被指派一个唯一的码片序列。</p></blockquote><!-- ---## 宽带接入技术 --><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>物理层的用途</li></ul><blockquote><p>在进行网络通信之前，必须在本地网络上建立一个物理连接。物理连接可以通过电缆进行有线连接，也可以通过无线电波进行无线连接。网络接口卡 (NIC) 将设备连接到网络。以太网网卡用于有线连接，而 WLAN（无线局域网）网卡用于无线连接。OSI 物理层通过网络介质传输构成数据链路层帧的位。该层从数据链路层接收完整的帧，并将这些帧编码为一系列信号，传输到本地介质上。经过编码的位构成了帧，这些位可以被终端设备或中间设备接收。</p></blockquote><ul><li>物理层的特种</li></ul><blockquote><p>物理层由工程师开发的电子电路、介质和连接器组成。物理层标准负责三个功能区：物理组件、编码和信令。带宽是介质承载数据的能力。数字带宽可以测量在给定时间内从一个位置流向另一个位置的数据量。吞吐量是给定时段内通过介质传输的位的量度，通常低于带宽。延迟是指数据从一个给定点传送到另一给定点所用的时间，包括时延。实际吞吐量是在给定时间段内传输的有用数据的衡量标准。</p></blockquote><p>物理层为每种介质制定的位的表示方式及分组如下：</p><ol><li><strong>铜缆</strong> - 信号为电脉冲模式。</li><li><strong>光缆</strong> - 信号为光模式。</li><li><strong>无线</strong> - 信号为微波传输模式。</li><li><strong>铜缆布线</strong></li></ol><blockquote><p>网络使用铜介质是因为其价格低廉、易于安装、对电流的电阻低。但是，铜介质受到距离和信号干扰的限制。电脉冲的时间和电压值易受两个干扰源的干扰：电磁干扰和串扰。有三种类型的铜缆布线：UTP、STP 和同轴电缆。UTP的外套可保护铜线免受物理损坏，线对扭绞可保护信号免受干扰，彩色编码的塑料绝缘层可将线彼此电气隔离并识别每对线。STP 电缆使用四对电线，每一对使用金属箔包裹，然后整体再用金属编织网或金属箔包裹。同轴电缆，或简称同轴，由于它的两根导线分享同一个轴而得名。同轴用于将天线连接到无线设备上。有线电视互联网供应商在其客户场所内使用同轴电缆。</p></blockquote><ul><li>UTP布线</li></ul><blockquote><p>UTP电缆由四对有彩色标记的铜线组成。这些铜线扭绞在一起，并用软塑料套包裹。UTP 电缆并不使用屏蔽层来对抗 EMI 和 RFI 的影响。相反，电缆设计者发现他们可以通过以下方式来减少串扰的负面影响：抵消和变化每个线对的扭绞次数。UTP 布线遵循由 TIA/EIA 共同制定的标准。电气电子工程师协会 (IEEE) 定义了铜缆的电特征。UTP 电缆的端头通常为 RJ-45 连接器。通过使用特定的接线约定可获得的主要电缆类型为“以太网直通”和“以太网交叉”。思科拥有专有的 UTP 电缆，称为全反电缆，将工作站连接到路由器控制台端口。</p></blockquote><ul><li>光纤布线</li></ul><blockquote><p>与其他网络介质相比，光缆能够以更远的距离和更高的带宽传输数据。光缆传输信号的衰减比铜缆更少，并且完全不受 EMI 和 RFI 影响。光纤是一种由非常纯的玻璃制成的极细透明的弹性线束，和人的头发差不多大。通过光缆传输时，位会被编码成光脉冲。光纤布线目前正在四类行业中使用：企业网络、FTTH、长距离网络和海底电缆网络。光纤连接器有四种类型：ST、SC、LC 和双工多模 LC。光纤接插线包括 SC-SC 多模、LC-LC 单模、ST-LC 多模和 SC-ST 单模。在大多数企业环境中，光纤主要用作数据分布层设备间的高流量点对点连接和拥有多栋建筑物的校园建筑物互连的主干布线。</p></blockquote><ul><li>无线介质</li></ul><blockquote><p>无线介质使用无线电或微波频率来承载代表数据通信二进制数字的电磁信号。无线确实有一些限制，包括：覆盖范围、干扰、安全性以及任何共享介质都会出现的问题。无线标准包括：Wi-Fi（IEEE 802.11）、蓝牙（IEEE 802.15）、WiMAX（IEEE 802.16）和 Zigbee（IEEE 802.15.4）。无线局域网 (WLAN) 需要无线 AP 和无线网卡适配器。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="School-DataStructure/"/>
      <url>School-DataStructure/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>对实际问题进行<code>缜密解析</code>，并辅以<code>优雅的代码</code>进行编写。<br>本篇整理了我学习数据结构与算法时的一些笔记，相关源码已上传<code>Github</code>托管。</p></blockquote><ul><li><p><a href="https://github.com/PhoenixNest/Hello-C">C • Github</a></p></li><li><p><a href="https://github.com/PhoenixNest/Hello-C-Plus-Plus">C++ • Github</a></p></li></ul><hr><h2 id="Program-Data-Structure-Algorithm"><a href="#Program-Data-Structure-Algorithm" class="headerlink" title="Program = Data Structure + Algorithm"></a>Program = Data Structure + Algorithm</h2><blockquote><p>“程序 = 数据结构 + 算法”，这句出自Nicklaus Wirth教授的经典名言，使其一举夺得计算机界的诺贝尔奖 - 图灵奖，该公式对于计算机科学的影响几乎等同于Albert Einstein最为著名的质能等价理论：”E = mc²”，通过这短短的一个公式，便展露出程序的本质。</p></blockquote><hr><h2 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h2><blockquote><p>“数据结构(Data Structure)”是计算机程序设计的<code>重要理论基础</code>，是计算机专业最为<code>核心</code>的一门专业课程，同是也是一门<code>考研课程</code>。本篇将介绍我在进行数据结构学习时，所学习的第一个章节：数据结构的基本概念和术语。</p></blockquote><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><blockquote><p>数据是<code>信息的载体</code>，是<code>描述客观事物</code>的数字、字符，以及<code>所有能输入计算机中</code>的、<code>被计算机程序识别和处理的符号</code>的集合。包括<code>数值型数据</code>：整数、实数等，与<code>非数值型数据</code>：文字、图像、图形、声音等。</p></blockquote><h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><blockquote><p>数据元素是<code>数据中的一个&quot;个体&quot;</code>，是数据的<code>基本单位</code>。在有些情况下，数据元素也被称为<code>元素</code>、<code>结点</code>、<code>顶点</code>、<code>记录</code>等。数据元素<code>用于完整地描述一个对象</code>。如：一个学生记录、一张图片、图的一个顶点等。</p></blockquote><h3 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h3><blockquote><p>数据项是<code>组成数据元素</code>的有特定意义的<code>不可分割的最小单位</code>。如构成一个数据元素的<code>字段</code>、<code>域</code>、<code>属性</code>等都可称之为数据项。数据元素<code>是数据项的集合</code>。</p><p>简而言之，如上述举例中若要<code>组成一个学生记录</code>，那么<code>一个学生</code>可能包含有<code>学号</code>、<code>姓名</code>、<code>性别</code>、<code>班级</code>等属性，这些学号、姓名就是<code>构成一个学生记录的数据项</code>。</p></blockquote><h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><blockquote><p>数据对象是具有<code>相同性质</code>的数据元素的<code>集合</code>，是<code>数据的一个子集</code>。</p><p>如：计算机专业的全体学生(其中<code>全体学生</code>为一个<code>集合</code>，<code>计算机专业</code>为每个学生个体的<code>相同性质</code>)。</p></blockquote><hr><h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><blockquote><p>数据的<code>逻辑结构</code>讨论的是<code>元素之间的逻辑关系</code>，<code>与存储结构无关</code>，是<code>独立于计算机</code>的。常见的逻辑结构有：</p></blockquote><ul><li><p><code>集合结构</code></p></li><li><p><code>线性结构</code> – (1 : 1)</p></li><li><p><code>树结构(层次结构)</code> – (1 : n)</p></li><li><p><code>图结构</code> – (n : m)</p></li></ul><hr><h3 id="数据的存储结构-物理结构"><a href="#数据的存储结构-物理结构" class="headerlink" title="数据的存储结构(物理结构)"></a>数据的存储结构(物理结构)</h3><blockquote><p>数据的存储结构(物理结构)研究的是数据及其逻辑关系<code>如何在计算机中存储与实现</code>。常见的存储结构有：</p></blockquote><ul><li>顺序存储结构 (Sequential storage structure)</li></ul><blockquote><p>借助元素在存储器中的<code>相对位置</code>表示数据元素之间的关系，通常用<code>数组</code>来实现。</p></blockquote><table><thead><tr><th align="center">数组下标</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td align="center">数组元素</td><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center">D</td></tr></tbody></table><ul><li>链式存储结构</li></ul><blockquote><p>借助<code>表示数据元素存储地址的指针</code>显式地指出数据元素之间的逻辑关系。</p></blockquote><ul><li>散列(哈希)存储方式 (Hash (hash) storage method)</li></ul><blockquote><p>是<code>专用于集合</code>的数据存储方式。<code>用一个哈希函数</code>将数据元素<code>按关键字</code>和<code>一个唯一的存储位置</code>关联起来。</p></blockquote><ul><li>索引存储方式</li></ul><blockquote><p>数据元素被<code>排成一个序列</code>：d1,d2,d3,…,dn，每个结点di在序列里都有<code>相应的位序i</code>(1 &lt;= i &lt;= n&gt;)，<code>位序</code>可以作为<code>结点的索引</code>存储在索引表中。检索时<code>利用结点的顺序号i来确定结点</code>的存储地址。(类似图书的<code>目录</code>。)</p></blockquote><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><blockquote><p>算法是<code>指令的有限序列</code>，是对特定问题<code>求解步骤的描述</code>。算法具有下列五种<code>特性</code>：</p></blockquote><ul><li>(1) 有穷性</li></ul><blockquote><p>步骤<code>有限</code>，执行时间<code>有限</code>。</p></blockquote><ul><li>(2) 确定性</li></ul><blockquote><p>有<code>确切</code>的含义，<code>无二义性</code>，算法只有<code>唯一</code>的一条执行路径。</p></blockquote><ul><li>(3) 可行性</li></ul><blockquote><p>可以通过<code>已经实现</code>的基本运算<code>执行有限次</code>来实现。</p></blockquote><ul><li>(4) 输入</li></ul><blockquote><p>算法具有<code>0个</code>或<code>多个</code>输入。</p></blockquote><ul><li>(5) 输出</li></ul><blockquote><p>算法具有<code>1个</code>或<code>多个</code>输出。(一个算法不能没有输出。)</p></blockquote><pre><code class="C++">int sum(int num)&#123;    int result = 0;    for (int i = 1; i &lt;= num; i++)        result += i;    return result;&#125;</code></pre><p><code>算法与程序</code>十分类似，但也有<code>区别</code>：</p><ul><li>在<code>执行时间上</code>：</li></ul><blockquote><p><code>算法</code>所描述的步骤是<code>一定有限</code>的，但<code>程序</code>可以<code>无限执行</code>下去。如：一个操作系统是在一个无限循环中执行的，而不是一个算法。</p></blockquote><ul><li>在<code>语言描述上</code>：</li></ul><blockquote><p><code>程序</code>必须采用<code>规定的程序设计语言</code>来实现，而<code>算法没</code>有这种<code>限制</code>。</p></blockquote><hr><h3 id="算法的设计要求"><a href="#算法的设计要求" class="headerlink" title="算法的设计要求"></a>算法的<code>设计要求</code></h3><ul><li>正确性</li></ul><blockquote><p>算法应该能<code>正确</code>地<code>实现预定功能</code>；</p></blockquote><ul><li>易读性</li></ul><blockquote><p>算法应<code>易于阅读</code>和<code>理解</code>，以<code>便与调试</code>、<code>修改</code>和<code>扩充</code>；</p></blockquote><ul><li>健壮性</li></ul><blockquote><p>当<code>环境发生变化</code>(如非法输入)时，能<code>正确作出反应</code>或<code>进行处理</code>，<code>不产生</code>不正确的运算结果；</p></blockquote><ul><li>高效性</li></ul><blockquote><p>算法应<code>有效地使用存储空间</code>并且<code>有较高的时间效率</code>。</p></blockquote><hr><h3 id="算法效率的衡量方法"><a href="#算法效率的衡量方法" class="headerlink" title="算法效率的衡量方法"></a>算法效率的衡量方法</h3><ul><li>事前分析法</li></ul><blockquote><p>在<code>忽略计算机硬件、软件的因素后</code>，一个特定算法”工作量”的大小，只<code>依赖于问题的规模</code>。</p></blockquote><ul><li>事后统计法(后期估算)</li></ul><blockquote><p>通过<code>编写实际操作代码</code>，并将其<code>在计算机上进行运行</code>，通过<code>计算机的时钟</code>进行算法执行时间的统计。但由于时间统计<code>依赖于硬件与软件环境</code>，容易掩盖算法本身的优劣。</p></blockquote><hr><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote><p>O(N)是指该<code>算法的时间耗费</code>，是其所求解问题规模N的函数。当问题规模N趋于无穷大时，不考虑具体的运行时间函数，<code>只考虑运行时间函数的数量级(阶)</code>，这称为算法的渐进时间复杂度。</p></blockquote><p>即：<code>忽略</code>低阶部分，只<code>保留</code>高阶部分，并<code>忽略</code>系数。</p><ul><li>常量阶</li></ul><pre><code class="C++">&#123;   ++x; s = 0; // 选取++x为基本操作，语句频度1，则时间复杂度O(n) = 1，即常量阶。&#125;</code></pre><pre><code class="C++">for (j = 1; j &lt;= 10000; ++j)    &#123;        ++x; // 选取++x为基本操作，语句频度为10000(即：1 * 10000)，但需要忽略系数，则时间复杂度为O(n) = 1，即常量阶。        s += x;    &#125;</code></pre><hr><ul><li>对数阶</li></ul><pre><code class="C++">s = 0;for (int j = 1; j &lt;= n; j *= 2)    ++x;// 选取++x为基本操作，语句频度为log2n(以2为底的对数阶)，则时间复杂度为O(log2n)，即对数阶。</code></pre><hr><ul><li>线性阶</li></ul><pre><code class="C++">for (int i = 1; i &lt;= 2 * n; ++i)    &#123;        ++x;// 选取++x为基本操作，则语句频度为2 * n，但需要忽略系数，则时间复杂度为O(n)，即线性阶。        s += x;    &#125;</code></pre><hr><ul><li>平方阶</li></ul><pre><code class="C++">for (j = 1; j &lt;= n; ++j)    &#123;// n + 1        for (k = 1; k &lt;= n / 4; ++k)        &#123;            // n * (n/4 + 1)            ++x;// 选取++x为基本操作，则语句频度为n * n/4，忽略系数1/4，则时间复杂度为O(n^2)，即平方阶。            s += x;        &#125;    &#125;</code></pre><hr><ul><li>线性对数阶</li></ul><pre><code class="C++">for (int j = 1; j &lt;= n; j *= 2)    &#123;// 执行log2n次        for (int k = 1; k &lt;= n; ++k)        &#123;            ++x;// 选取++x为基本操作，则时间复杂度为O(nlog2n)，即线性对数阶。            s += x;        &#125;    &#125;</code></pre><hr><ul><li>立方阶</li></ul><pre><code class="C++">for (int i = 1; i &lt;= n; i++)    &#123;// 执行n次        for (int j = 1; j &lt;= n; j++)        &#123;// 执行n^2次            c[i][j] = 0;            for (int k = 1; k &lt;= n; k++)            &#123;// 执行n^3次，语句频度为n * n^2 * n^ 3，但只取最高阶，即时间复杂度为O(n^3)，即立方阶。                c[i][j] = c[i][j] + a[i][k] * b[k][j];            &#125;        &#125;    &#125;</code></pre><hr><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><blockquote><p>如果<code>所需额外空间</code>相对于<code>输入数据量</code>来说只是一个<code>常数</code>，则称此算法为<code>&quot;原地工作&quot;</code>，此时的空间复杂度为O(1)。</p></blockquote><p>例：问题<code>规模</code>为n，</p><p>(1)若使用<code>大小为n</code>的辅助一唯数组，则空间复杂度为：O(n)</p><p>(2)若使用<code>大小为n * n</code>的辅助一唯数组，则空间复杂度为：O(n^2)</p><p>(3)若使用了<code>100个</code>辅助变量，则空间复杂度为：O(1),即”原地工作”</p><hr><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><blockquote><p>抽象数据类型和高级语言中的数据类型实质上<code>是一个概念</code>，抽象数据类型包含一般数据类型的概念，但<code>含义比一般数据类型更广、更抽象</code>。</p></blockquote><p>抽象类型的<code>伪代码</code>定义格式如：</p><pre><code class="ADT">ADT 抽象数据类型名 &#123;    数据对象 D: &lt;数据对象的定义&gt;    数据对象 R: &lt;数据对象的定义&gt;    数据对象 P: &lt;数据对象的定义&gt;&#125; ADT 抽象数据类型名</code></pre><hr><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><blockquote><p>线性表(List)，作为<code>最简单</code>、<code>最基本</code>，也是<code>最常用</code>的一种<code>线性结构</code>。线性表是<code>n个</code>数据<code>元素的有限序列</code>。元素可以是<code>各种各样</code>的，但<code>必须有相同性质</code>，属于<code>同一种</code>数据对象。</p></blockquote><p>例，XX学校设有n个学院，可用<code>线性表表示</code>如下：</p><p>{ “数学学院” , “外国语学院” , “声乐学院” , “计算机学院” , … }</p><p>表中的元素<code>都是</code>文本类型的<code>字符型值</code>，<code>不允许</code>出现<code>非文本类型</code>的数据。</p><p>当需要使用线性表<code>存储较为复杂的数据</code>时，一个<code>元素</code>也<code>可有多个数据项构成</code>，这种元素在线性表中<code>通常被称为&quot;记录 (record)&quot;</code></p><p>例，XX学校计算机学院的<code>学生成绩表</code>可表示为：</p><table><thead><tr><th align="center">ID</th><th align="center">Name</th><th align="center">Data Structure</th><th align="center">Software Engineering</th><th align="center">Discrete Mathematics</th><th align="center">Computer Network</th><th align="center">…</th></tr></thead><tbody><tr><td align="center">001</td><td align="center">Mike</td><td align="center">95</td><td align="center">90</td><td align="center">85</td><td align="center">80</td><td align="center">…</td></tr><tr><td align="center">002</td><td align="center">Jack</td><td align="center">90</td><td align="center">85</td><td align="center">80</td><td align="center">75</td><td align="center">…</td></tr><tr><td align="center">003</td><td align="center">Alice</td><td align="center">85</td><td align="center">80</td><td align="center">75</td><td align="center">70</td><td align="center">…</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr></tbody></table><p>该线性表中的<code>每一个元素</code>都是<code>一个学生</code>的成绩，也可看成<code>一个记录</code>，由<code>n个</code>科目成绩的<code>数据项构成</code>。从表中可以看出，每个<code>元素</code>都<code>有相同的数据项</code>，而各个<code>数据项</code>都<code>有自己的数据类型</code>。</p><hr><h3 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的<code>抽象数据类型</code></h3><pre><code class="C++">template &lt;class T&gt;class List&#123;public:    virtual void clear() = 0;                          //* 清空顺序表    virtual bool empty() const = 0;                    //* 判空，空为true，非空false    virtual int size() const = 0;                      //* 表长    virtual void insert(int position, const T &amp;value); //* 在position位置插入值为value的元素    virtual void remove(int position) = 0;             //* 删除第position的位置的元素    virtual int search(const T &amp;value);                //* 查找传入值value在顺序表中的位置    virtual T visit(int position) const = 0;           //* 查找position位置的元素的值    virtual void traverse() const = 0;                 //* 遍历当前顺序表    virtual void inverse() = 0;                        //* 逆置当前顺序表    virtual ~List()&#123;&#125;;&#125;;</code></pre><h3 id="自定义的异常处理类"><a href="#自定义的异常处理类" class="headerlink" title="自定义的异常处理类"></a>自定义的<code>异常处理类</code></h3><pre><code class="C++">class outOfRange : public exception&#123;public:    //* 检查范围有效性    const char *checkRange() const throw()    &#123;        return &quot;OUT of RANGE&quot;;    &#125;&#125;;class errorSize : public exception&#123;public:    //* 检查长度有效性    const char *checkSize() const throw()    &#123;        return &quot;ERROR size&quot;;    &#125;&#125;;</code></pre><hr><h3 id="线性表的【顺序】表示"><a href="#线性表的【顺序】表示" class="headerlink" title="线性表的【顺序】表示"></a>线性表的【顺序】表示</h3><blockquote><p>线性表 (List) 在计算机内部有多种表示方法，最简单最<code>常用</code>的<code>方法</code>即用<code>顺序表示</code>。即在内存中用<code>地址连续</code>的一块<code>有限</code>的<code>表空间</code>，<code>存储</code>线性表的<code>各种元素</code>，这种形式存储的线性表称为<code>顺序表</code>。</p><p>顺序表用<code>物理</code>上的<code>相邻</code>(即内存中的<code>地址</code>是<code>连续</code>的，如：同一批产品的生产序号)<code>实现</code>元素之间的<code>逻辑相邻</code>关系。</p></blockquote><p>假定顺序表中的<code>每个元素占k个存储单元</code>(如：一个元素占8个存储单元)，若知道<code>第一个元素</code>的地址(如：1000，即基地址)为<code>Loc(a0)</code>，则<code>位序为i的元素的地址</code>为：</p><p><code>Loc(ai) = Loc(a0) + i * k (0 &lt;= i &lt;= n-1)</code></p><p>此时<code>查找位序为i的元素</code>的<code>时间复杂度为O(1)</code>，可得顺序表具有<code>按元素位序</code>，进行<code>随机存取</code>的特点。</p><pre><code class="C++">template &lt;class T&gt;class seqList : public List&lt;T&gt;&#123;private:    T *data;       //* 动态数组    int length;    //* 当前顺序表表长    int maxSize;   //* 顺序表最大长度    void resize(); //* 表满时扩大表空间public:    seqList(int initSize = 10);   //* 构造函数    seqList(seqList &amp;list);       //* 拷贝构造    ~seqList() &#123; delete[] data; &#125; //* 析构函数    void clear() &#123; length = 0; &#125;               //* 置空    bool empty() const &#123; return length == 0; &#125; //* 判空    int size() const &#123; return length; &#125;        //* 返回表长    void traverse() const;                     //* 遍历当前表    void inverse();                            //* 逆置当前表    void insert(int position, const T &amp;value); //* 在position位置插入值为value的元素    void remove(int position);                 //* 删除位于position的元素，length - 1    int search(const T &amp;value) const;          //* 查找值为value的元素在表中的值    T visit(int position) const;               //* 访问position位置元素的值    bool Union(seqList&lt;T&gt; &amp;list);&#125;;</code></pre><hr><h3 id="顺序表的运算"><a href="#顺序表的运算" class="headerlink" title="顺序表的运算"></a>顺序表的运算</h3><ul><li>构造函数</li></ul><pre><code class="C++">template &lt;class T&gt;seqList&lt;T&gt;::seqList(int initSize)&#123;    if (initSize &lt;= 0)        throw errorSize();    maxSize = initSize;    data = new T[maxSize];    length = 0;&#125;</code></pre><hr><ul><li>拷贝构造函数(动态分配存储空间)</li></ul><pre><code class="C++">template &lt;class T&gt;seqList&lt;T&gt;::seqList(seqList &amp;seqList)&#123;    maxSize = seqList.maxSize;    length = seqList.length;    data = new T[maxSize];    for (int i = 0; i &lt; length; ++i)        data[i] = seqList.data[i];&#125;</code></pre><hr><ul><li><code>遍历</code>顺序表</li></ul><blockquote><p>依次输出顺序表的所有元素。</p></blockquote><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><pre><code class="C++">template &lt;class T&gt;void seqList&lt;T&gt;::traverse() const&#123;    if (empty())    &#123;        cout &lt;&lt; &quot;Empty List&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;current Element: &quot; &lt;&lt; endl;        for (int i = 0; i &lt; maxSize; i++)            cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    &#125;&#125;</code></pre><hr><ul><li><code>查找</code>运算</li></ul><blockquote><p>在顺序表中查找值为value的元素的下标。</p></blockquote><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><p>平均<code>期望值</code>：<code>(n+1)/2</code>，其中n为顺序表的元素个数。</p><pre><code class="C++">template &lt;class T&gt;int seqList&lt;T&gt;::search(const T &amp;value) const&#123;    for (int i = 0; i &lt; length; i++)        if (value == data[i])            return i;    return -1;&#125;</code></pre><hr><ul><li><code>插入</code>运算</li></ul><blockquote><p>在顺序表下标为position的位置插入值为value的元素。</p></blockquote><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><p>平均移动元素次数<code>(期望值)</code>：<code>n/2</code>，其中n为顺序表的元素个数。</p><pre><code class="C++">template &lt;class T&gt;void seqList&lt;T&gt;::insert(int position, const T &amp;value)&#123;    if (position &lt; 0 || position &gt; length)        //* 判断是否越界        throw outOfRange();    if (length == maxSize)        //* 当表满时，扩大表容量        resize();    for (int j = length; j &gt; position; j--)        //* 向后移动在插入位置position之后的所有元素        //* 注意此处移动的第一个元素下标为表尾元素下标        data[j] = data[j - 1];    //* 在空出位置插入值为value的元素    data[position] = value;    //* 表长 +1    ++length;&#125;</code></pre><hr><ul><li><code>删除</code>运算</li></ul><blockquote><p>删除在顺序表下标为position的元素。</p></blockquote><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><p>平均移动元素次数<code>(期望值)</code>：<code>(n-1)/2</code>，其中n为顺序表的元素个数。</p><pre><code class="C++">template &lt;class T&gt;void seqList&lt;T&gt;::remove(int position)&#123;    if (position &lt; 0 || position &gt; length - 1)        //* 判断是否越界        throw outOfRange();    for (int j = position; j &lt; length - 1; j++)        //* 前移在删除位置position之后的所有元素        //* 注意此处移动的第一个元素下标为待删除元素的下标        data[j] = data[j + 1];    //* 表长 -1    --length;&#125;;</code></pre><hr><ul><li><code>逆置</code>顺序表</li></ul><blockquote><p>调整线性表的顺序，可用于倒序输出顺序表元素。</p></blockquote><p>如：原顺序表为5，4，3，2，1，逆置后顺序表为1，2，3，4，5</p><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><p>平均移动元素次数<code>(期望值)</code>：<code>n/2</code>，其中n为顺序表的元素个数。</p><pre><code class="C++">template &lt;class T&gt;void seqList&lt;T&gt;::inverse()&#123;    T temp;    for (int i = 0; i &lt; length / 2; i++) //* 控制交换次数    &#123;        temp = data[i];        data[i] = data[length - i - 1];        data[length - i - 1] = temp;    &#125;&#125;</code></pre><hr><ul><li><code>扩大</code>表空间</li></ul><blockquote><p>算法思想：<br>由于数组空间在内存中<code>必须</code>是<code>连续</code>的，因此，<code>扩大</code>数组<code>空间</code>的操作需要：<code>(1)</code>重新申请一个更大规模的新数组，<code>(2)</code>将原有数组的内容复制到新数组中，<code>(3)</code>释放原有数组空间，<code>(4)</code>将新数组作为线性表的存储区。</p></blockquote><p><code>时间</code>复杂度：<code>O(n)</code></p><pre><code class="C++">template &lt;class T&gt;void seqList&lt;T&gt;::resize()&#123;    T *p = data;           //* 指针p指向原顺序表空间    maxSize *= 2;          //* 扩大2倍表空间    data = new T[maxSize]; //* 将旧的数据指向新的表空间    for (int i = 0; i &lt; length; ++i) //* 复制元素至扩大后的新表        data[i] = p[i];    delete[] p;&#125;</code></pre><hr><h3 id="线性表的【链式】表示"><a href="#线性表的【链式】表示" class="headerlink" title="线性表的【链式】表示"></a>线性表的【链式】表示</h3><blockquote><p><code>链式存储线性表</code>时，不需要使用地址连续的存储单元，即<code>不需要逻辑上相邻的元素在物理位置上也相邻</code>，它通过“链”建立起数据元素之间的逻辑关系，因此<code>插入和删除操作不需要移动元素</code>，则<code>只需要修改指针</code>，但<code>会失去</code>顺序表<code>随机存储</code>的特点。</p></blockquote><pre><code class="C++">template &lt;class T&gt;class linkList : public List&lt;T&gt;&#123;private:    struct Node    &#123;        T data;     //* 结点数据域        Node *next; //* 结点指针域        Node(const T value, Node *p = NULL)        &#123;            data = value;            next = p;        &#125;        Node(Node *p = NULL)        &#123;            next = p;        &#125;    &#125;;    Node *head; //* 单链表头指针    Node *tail; //* 单链表尾指针    int length; //* 单链表表长    Node *getPosition(int position) const; //* 返回指向position元素的指针    void traverseRecursive(Node *p);    void traverseNonRecursive1();    void traverseNonRecursive2();    void traverseNonRecursive3();public:    linkList();  //* 构造函数    ~linkList(); //* 析构函数    void clear();                                     //* 清空单链表，使其成为空表    bool empty() const &#123; return head-&gt;next == NULL; &#125; //* 判空    int size() const &#123; return length; &#125;               //* 返回单链表的当前实际长度    void insert(int position, const T &amp;value);        //* 在位置position上插入一个新元素，表长+1    void remove(int position);                        //* 删除位于position的元素    int search(const T &amp;value) const;                 //* 查找值为value的元素在单链表中第一次出现的位置    T visit(int position) const;                      //* 访问在position位置上的单链表的值    void traverse() const;           //* 遍历单链表    void inverse();                  //* 逆置单链表    void headCreate();               //* 头插法创建单链表    void tailCreate();               //* 尾插法创建单链表    int prior(const T &amp;value) const; //* 查找值为value的元素的前驱结点    linkList *Union(linkList&lt;T&gt; *list);    void outPut();&#125;;</code></pre><hr><h3 id="单链表的运算"><a href="#单链表的运算" class="headerlink" title="单链表的运算"></a><code>单链表</code>的运算</h3><ul><li>构造函数</li></ul><pre><code class="C++">//** 时间复杂度：O(1)template &lt;class T&gt;linkList&lt;T&gt;::linkList()&#123;    head = tail = new Node();    length = 0;&#125;</code></pre><hr><ul><li>析构函数</li></ul><p><code>时间</code>复杂度：<code>O(n)</code></p><pre><code class="C++">template &lt;class T&gt;linkList&lt;T&gt;::~linkList()&#123;    clear();    delete head;&#125;</code></pre><hr><ul><li><code>清空</code>单链表</li></ul><blockquote><p>清空链表中所有元素。</p></blockquote><p><code>时间</code>复杂度：<code>O(n)</code></p><pre><code class="C++">template &lt;class T&gt;void linkList&lt;T&gt;::clear()&#123;    Node *p, *temp;   //* p为工作指针，指向首元结点    p = head-&gt;next;   //* 防止意外修改头指针    while (p != NULL) //* 等效于：while(p)&#123;&#125;    &#123;        temp = p;        p = p-&gt;next; //* 指针后移        delete temp;    &#125;    head-&gt;next = NULL; //* 头结点指针域置空    tail = head;       //* 头尾指针均指向头结点    length = 0;&#125;</code></pre><hr><ul><li>求表长</li></ul><blockquote><p>算法思想：<br>与<code>遍历单链表</code>类似，均需要从第一个元素开始遍历并记录临时存储的长度，直到最后一个元素结束。</p></blockquote><p><code>时间</code>复杂度：<code>O(n)</code></p><pre><code class="C++">template &lt;class T&gt;int linkList&lt;T&gt;::size() const&#123;    return length; //* 直接返回length&#125;*** 若单链表中未设置变量length存储当前表长，则需要遍历整个单链表以计算表长template &lt;class T&gt;int linkList&lt;T&gt;::size() const&#123;    Node *p = head-&gt;next; //* 从头到尾遍历整个单链表    int count = 0;    while (p != NULL)    &#123;        count++;        p = p-&gt;next;    &#125;    return count;&#125;</code></pre><hr><ul><li><code>遍历</code>单链表</li></ul><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><pre><code class="C++">template &lt;class T&gt;void linkList&lt;T&gt;::traverse() const&#123;    Node *p = head-&gt;next;    cout &lt;&lt; &quot;traverse: &quot;;    while (p != NULL)    &#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        p = p-&gt;next;    &#125;    cout &lt;&lt; endl;&#125;</code></pre><hr><ul><li><code>头插法</code>创建单链表，<code>可用于逆置链表</code></li></ul><p><code>Example</code>：根据线性表(5,4,3,2,1)创建单链表，则读入数据的顺序应为：1,2,3,4,5，和线性表中的逻辑顺序<code>正好相反</code>。</p><blockquote><p>元素插入在链表头部，从后往前插入元素。</p></blockquote><p><code>时间</code>复杂度：<code>O(n)</code></p><pre><code class="C++">template &lt;class T&gt;void linkList&lt;T&gt;::headCreate()&#123;    Node *p;    T value, flag;    cout &lt;&lt; &quot;input Elements, ended with: &quot;;    cin &gt;&gt; flag; //* 输入结束标志    while (cin &gt;&gt; value, value != flag)    &#123;        p = new Node(value, head-&gt;next);        head-&gt;next = p;   //* 结点p插入到头结点后面        if (head == tail) //* 原链表为空，则结点p为尾结点            tail = p;        length++;    &#125;&#125;</code></pre><hr><ul><li><code>尾插法</code>创建单链表</li></ul><p><code>Example</code>：根据线性表(1,2,3,4,5)创建单链表，则读入顺序应为：1,2,3,4,5，读入顺序与单链表的结点<code>顺序相同</code></p><blockquote><p>元素依次从尾部插入。</p></blockquote><p><code>时间</code>复杂度：<code>O(n)</code></p><pre><code class="C++">template &lt;class T&gt;void linkList&lt;T&gt;::tailCreate()&#123;    Node *p;    T value, flag;    cout &lt;&lt; &quot;input Elements, ended with: &quot;;    cin &gt;&gt; flag; //* 输入结束标志    while (cin &gt;&gt; value, value != flag)    &#123;        p = new Node(value, NULL);        tail-&gt;next = p; //* 给尾指针的指针域赋值新的元素，结点p插入到尾结点的后面        tail = p;       //* 结点p成为新的尾结点        length++;    &#125;&#125;</code></pre><hr><ul><li><code>查找</code>位于position位置的元素（<code>按序号</code>查找）</li></ul><p><code>时间</code>复杂度：<code>O(n)</code></p><pre><code class="C++">template &lt;class T&gt;typename linkList&lt;T&gt;::Node *linkList&lt;T&gt;::getPosition(int position) const&#123;    Node *p = head; //* 查找指针p初始指向头节点    int count = 0;    if (position &lt; -1 || position &gt; length - 1) //* 合法查找位置为(-1..n-1)        return NULL;                            //* 当要查找的position非法时返回NULL    while (count &lt;= position)    &#123;        p = p-&gt;next;        count++;    &#125;    return p; //* 返回位于position位置的结点的指针&#125;</code></pre><hr><ul><li><code>查找</code>值为value的元素（<code>按值</code>查找）</li></ul><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><pre><code class="C++">template &lt;class T&gt;int linkList&lt;T&gt;::search(const T &amp;value) const&#123;    Node *p = head-&gt;next; //* 从头结点开始扫描链表    int count = 0;    //* 当p不为空与p所指向的data域的值不等于value时，继续扫描链表    //* 结束循环条件：指针p为NULL 或 指针p的数据域不等于期望值value    while (p != NULL &amp;&amp; p-&gt;data != value)    &#123;        p = p-&gt;next;        count++;    &#125;    if (p == NULL) //* 当p为空时(空表)，直接返回非法值        return -1;    else        return count; //* 返回value在链表中的位置&#125;</code></pre><hr><ul><li>在单链表的position位置<code>插入</code>值为value的元素，<code>挂链</code></li></ul><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><blockquote><p>算法思想：<br>s为指向新结点的指针，p为指向position-1位置元素的指针<br>(1) s-&gt;next = p-&gt;next<br>(2) p-&gt;next = s</p><blockquote><p>上述也可表示为：<br>p指向当前结点，pre表示前一个结点的指针，在<em>p前（</em>pre后）插入元素q<br>(1) q-&gt;next = pre-&gt;next<br>(2) pre-&gt;next = q</p></blockquote></blockquote><pre><code class="C++">template &lt;class T&gt;void linkList&lt;T&gt;::insert(int position, const T &amp;value)&#123;    Node *p, *q;    if (position &lt; 0 || position &gt; length) //* 合法位置(0..n)        throw outOfRange();    p = getPosition(position - 1); //* p为指向position-1位置的指针    q = new Node(value, p-&gt;next);  //* 生成新结点    p-&gt;next = q;                   //* q结点插入到p结点的后面    if (p == tail)                 //* 若在表尾插入        tail = q;                  //* 则修改表尾指针即可    length++;&#125;</code></pre><hr><ul><li>在单链表中<code>删除</code>位于position位置的元素（按序号删除）</li></ul><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><blockquote><p>算法思想：<br>p指向当前结点(即待删除结点)，pre表示前一个结点的指针<br>(1) pre-&gt;next = p-&gt;next || 也可写成：pre-&gt;next = pre-&gt;next-&gt;next，其中将pre-&gt;next看成一个结点(即待删除结点)指针<br>(2) delete p</p></blockquote><pre><code class="C++">template &lt;class T&gt;void linkList&lt;T&gt;::remove(int position)&#123;    Node *pre, *p;    if (position &lt; 0 || position &gt; length - 1)        throw outOfRange();    pre = getPosition(position - 1); //* pre为指向position-1位置，即待删除元素的前一个元素的指针    p = pre-&gt;next;                   //* p为指向pre指针的下一个结点的指针，即指向待删除结点    if (p == tail)                   //* 若删除元素位于表尾    &#123;        tail = pre;       //* 则直接修改表尾        pre-&gt;next = NULL; //* 并将待删除元素的前一个元素的指针域指向NULL        delete p;         //* 释放待删除结点    &#125;    else //* 若删除元素位于表间    &#123;        pre-&gt;next = p-&gt;next; //* 将待删除结点的next指针交付给前一个结点的指针域        delete p;            //* 释放待删除结点    &#125;    length--;&#125;</code></pre><hr><ul><li><code>逆置</code>单链表（<code>头插法</code>实现）</li></ul><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><blockquote><p>算法思想：</p><ol><li>断开链接，构造空链表</li><li><code>将原链表中元素用头插法重新插入head链表</code></li></ol></blockquote><pre><code class="C++">template &lt;class T&gt;void linkList&lt;T&gt;::inverse()&#123;    Node *p, *temp;    //* p用于遍历单链表，temp用于保存后继结点    p = head-&gt;next;    //* 指向首元结点    head-&gt;next = NULL; //* 头结点指针域置空，构成空链表    if (p)        tail = p; //* 更新尾结点    while (p)    &#123;        temp = p-&gt;next;       //* 暂存p的后继        p-&gt;next = head-&gt;next; //* 修改首元结点        head-&gt;next = p;       //* 修改头结点        p = temp;             //* 处理下一结点    &#125;&#125;</code></pre><hr><ul><li><code>查找</code>值为value的<code>前驱</code>（按值查找）</li></ul><pre><code class="C++">template &lt;class T&gt;int linkList&lt;T&gt;::prior(const T &amp;value) const&#123;    Node *p = head-&gt;next;    Node *pre = NULL;    int count = -1;    while (p &amp;&amp; p-&gt;data != value)    &#123;        pre = p;        p = p-&gt;next;        count++;    &#125;    if (p == NULL)        return -1;    else        return count;&#125;</code></pre><!-- ---### 双链表`单链表`中只有一个指向后继的指针，使得单链表只能从头结点依次顺序地向后遍历。`要访问某个结点的前驱结点（插入、删除操作时），只能从头开始遍历`，访问后继结点的时间复杂度为：O(1)，访问前驱结点的时间复杂度为：O(n)。为了克服单链表的上述缺点，引入了双链表，`双链表结点中有两个指针prior和next，分别指向其前驱和后继结点`。```C// 定义双链表结点类型typedef struct DNode{    ElemType data;              // 数据域    struct DNode *prior,*next;  // 前驱和后继指针}DNode, *DLinkList```---### 双链表的运算+ 插入原：(p)->(c)后：(p)->(s)->(c)> 算法思想：> 1. 先将待插入结点挂链> 2. 解除插入元素前驱与后继关联（断链），并将其指向新结点。```C// 将结点 *s 插入到 结点 *p 之后s->next = p->next;p->next->prior = s;s->prior = p;p->next =s;```---+ 删除原：(p)->(q)->(c)后：(p)->(c)> 算法思想：> 1. 将待删除结点q的后继指针赋值给前驱结点p中的后继指针> 2. 修改待删除结点的后继结点c中的前驱指针，使其指向前一结点p```Cp->next = q->next;q->next->prior = p;free(q);``` --><hr><h3 id="顺序表、链表的比较"><a href="#顺序表、链表的比较" class="headerlink" title="顺序表、链表的比较"></a>顺序表、链表的比较</h3><table><thead><tr><th align="center"><strong>数据结构</strong></th><th><strong>存取（读写）方式</strong></th><th><strong>逻辑结构与物理结构</strong></th><th><strong>查找、插入和删除操作</strong></th><th><strong>空间分配</strong></th></tr></thead><tbody><tr><td align="center">顺序存储</td><td>顺序存取、随机存取（O(1)）</td><td>逻辑相邻，物理相邻</td><td>按值查找：无序（O(n)），有序（折半查找，O(log2n)）；按序查找：随机访问，O(1)</td><td>预分配空间，易出现空间浪费与溢出</td></tr><tr><td align="center">链式存储</td><td>从头顺序存取（O(n)）</td><td>逻辑相邻，物理不一定相邻</td><td>按值查找：O(n)；按序查找：O(n)</td><td>动态分配，但插入删除需要移动大量元素，操作效率低</td></tr></tbody></table><hr><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><table><thead><tr><th align="center"><strong>数据结构</strong></th><th><strong>基于存储考虑</strong></th><th><strong>基于运算考虑</strong></th><th><strong>基于环境考虑</strong></th></tr></thead><tbody><tr><td align="center">顺序存储</td><td>未知存储规模时，不宜采用顺序表</td><td>按序号访问时优于链式存储结构，时间复杂度：O(1)；但在插入与删除操作时劣于链式存储，需要移动大量元素，且平均移动一半元素</td><td>实现较为简单，任何高级语言中都有数组类型，适合稳定存储的线性表</td></tr><tr><td align="center">链式存储</td><td>动态分配存储空间，但存储密度低</td><td>按序号访问时，时间复杂度：O(n)；插入删除时优于顺序存储，虽要先查找位置，但总体优于顺序存储</td><td>基于指针，适合动态性较强（插入删除操作频繁）的线性表</td></tr></tbody></table><hr><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="基本定义-1"><a href="#基本定义-1" class="headerlink" title="基本定义"></a>基本定义</h3><blockquote><p>栈 (Stack) 是只允许在一端进行插入或删除操作的<code>线性表</code>。</p><p>首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。</p><p>栈的规律类似手枪的弹夹，羽毛球桶。</p></blockquote><p>栈顶：指线性表允许进行插入删除的一端</p><p>栈底：固定的，不允许进行插入删除的另一端</p><p>栈规则：<code>后进先出</code></p><hr><h3 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的<code>抽象数据类型</code></h3><pre><code class="C++">template &lt;class T&gt;class Stack&#123;public:    virtual bool empty() const = 0;        //* 判栈空    virtual int size() const = 0;          //* 返回栈大小    virtual void push(const T &amp;value) = 0; //* 进栈    virtual T pop() = 0;                   //* 出栈    virtual T getTop() const = 0;          //* 返回栈顶元素    virtual void clear() = 0;              //* 清空栈    virtual ~Stack()&#123;&#125;;&#125;;</code></pre><hr><h3 id="自定义的异常处理类-1"><a href="#自定义的异常处理类-1" class="headerlink" title="自定义的异常处理类"></a>自定义的异常处理类</h3><pre><code class="C++">class outOfRange : public exception&#123;public:    const char *what() const throw()    &#123;        return &quot;OUT of RANGE&quot;;    &#125;&#125;;class errorSize : public exception&#123;public:    const char *what() const throw()    &#123;        return &quot;ERROR size&quot;;    &#125;&#125;;</code></pre><hr><h3 id="栈的【顺序】表示"><a href="#栈的【顺序】表示" class="headerlink" title="栈的【顺序】表示"></a>栈的【顺序】表示</h3><blockquote><p>采用顺序存储的栈称为顺序栈，利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设 top 指针指向当前栈顶元素位置。</p></blockquote><pre><code class="C++">template &lt;class T&gt;class seqStack : public Stack&lt;T&gt;&#123;private:    T *data;       //* 顺序栈中元素的数组    int top;       //* 顺序栈顶指针，指向栈顶元素    int maxSize;   //* 顺序栈的大小    void resize(); //* 扩顺序栈空间public:    //* 构造函数    seqStack(int initSize = 100)    &#123;        if (initSize &lt;= 0)            throw errorSize();        data = new T[initSize]; //* 数组        maxSize = initSize;     //* 当top == maxSize - 1，则表示栈满        top = -1;               //* 初始时top = -1，表示栈空    &#125;    ~seqStack() &#123; delete[] data; &#125;;          //* 析构函数    bool empty() const &#123; return top == -1; &#125; //* 判栈空    int size() const &#123; return top + 1; &#125;     //* 返回顺序栈大小    void clear()                             //* 清空顺序栈    &#123;        //* 直接将top指针初始化即可清空栈        top = -1;    &#125;;    void push(const T &amp;value); //* 顺序栈进栈    T pop();                   //* 顺序栈出栈    T getTop() const;          //* 获取顺序栈栈顶元素&#125;;</code></pre><hr><h3 id="顺序栈的运算"><a href="#顺序栈的运算" class="headerlink" title="顺序栈的运算"></a>顺序栈的运算</h3><ul><li>入栈，进栈</li></ul><blockquote><p>从栈顶依次将元素按后进先出的规则填充入栈。<br>需<code>注意</code>：入栈时，栈顶指针先 +1，后元素入栈。</p></blockquote><p><code>时间</code>复杂度：栈<code>满</code>时：O(n)，栈<code>未满</code>时：O(1)</p><pre><code class="C++">template &lt;class T&gt;void seqStack&lt;T&gt;::push(const T &amp;value)&#123;    //* 当top == maxSize - 1，表示栈满    if (top == maxSize - 1)        resize(); //* 若栈满仍插入，则会导致上溢    // ++top;    // data[top] = value;    //* --- 等效于下方代码 ---    data[++top] = value; //* 修改栈顶指针，元素进栈，先+1后写入&#125;</code></pre><hr><ul><li>出栈，弹栈</li></ul><blockquote><p>将栈顶元素按后进先出的规则依次弹出。<br>需<code>注意</code>：出栈时，元素先出栈，后栈顶元素 -1。</p></blockquote><p><code>时间</code>复杂度：O(1)</p><pre><code class="C++">template &lt;class T&gt;T seqStack&lt;T&gt;::pop()&#123;    if (empty()) //* 空栈无法出栈，即下溢        throw outOfRange();    // --top;    // return data[top]    //* --- 等效于下方代码 ---    return data[top--]; //* 修改栈顶指针，元素出栈，先出栈后-1&#125;</code></pre><hr><ul><li>取栈顶元素</li></ul><blockquote><p>输出栈顶元素的值。</p></blockquote><p><code>时间</code>复杂度：O(1)</p><pre><code class="C++">template &lt;class T&gt;T seqStack&lt;T&gt;::getTop() const&#123;    if (empty())        throw outOfRange();    return data[top]; //* 直接返回栈顶元素&#125;</code></pre><hr><ul><li>扩大栈空间</li></ul><blockquote><p>算法思想：</p><ol><li>遍历旧栈元素并临时存储。</li><li>申请新栈（容量大于旧栈，如申请两倍、三倍空间）。</li><li>将临时存放的旧栈元素依次重新填充进入新栈。</li><li>释放旧栈空间。</li></ol></blockquote><p><code>时间</code>复杂度：O(n)</p><pre><code class="C++">template &lt;class T&gt;void seqStack&lt;T&gt;::resize()&#123;    T *temp = data;                  //* 将旧栈区数据临时存储    data = new T[2 * maxSize];        //* 扩大栈区大小    for (int i = 0; i &lt; maxSize; ++i) //* 将旧栈区的数据赋值到新栈区        data[i] = temp[i];    maxSize *= 2;    delete[] temp; //* 释放旧栈区&#125;</code></pre><hr><h3 id="栈的【链式】表示"><a href="#栈的【链式】表示" class="headerlink" title="栈的【链式】表示"></a>栈的【链式】表示</h3><blockquote><p>链栈的优点是便于<code>多个栈共享存储空间和使用效率</code>，且<code>不存在栈满上溢的现象</code>。<br>链栈通常采用<code>单链表</code>表示，并规定<code>所有操作均在单链表表头进行</code>。</p></blockquote><pre><code class="C++">template &lt;class T&gt;class linkStack : public Stack&lt;T&gt;&#123;private:    struct Node    &#123;        T data;        Node *next;        Node() &#123; next = NULL; &#125;        Node(const T &amp;value, Node *p = NULL)        &#123;            data = value;            next = p;        &#125;    &#125;;    Node *top;public:    linkStack() &#123; top = NULL; &#125;;               //* 初始化空栈    ~linkStack() &#123; clear(); &#125;;                 //* 析构函数    void clear();                              //* 清空栈    bool empty() const &#123; return top == NULL; &#125; //* 判栈空，时间复杂度：O(n)    int size() const;                          //* 返回链栈长度    void push(const T &amp;value);                 //* 进栈    T pop();                                   //* 出栈    T getTop() const;                          //* 返回栈顶元素&#125;;</code></pre><hr><h3 id="链栈的运算"><a href="#链栈的运算" class="headerlink" title="链栈的运算"></a>链栈的运算</h3><ul><li>栈长度</li></ul><p><code>时间</code>复杂度：O(n)</p><pre><code class="C++">template &lt;class T&gt;int linkStack&lt;T&gt;::size() const&#123;    Node *p = top;    int count = 0;    while (p) //* 遍历栈，统计元素个数    &#123;        count++;        p = p-&gt;next;    &#125;    return count;&#125;</code></pre><hr><ul><li>入栈，进栈</li></ul><p><code>时间</code>复杂度：O(1)</p><pre><code class="C++">template &lt;class T&gt;void linkStack&lt;T&gt;::push(const T &amp;value)&#123;    Node *p = new Node(value, top); //* 在栈顶插入元素    top = p;                        //* 更新栈顶指针&#125;</code></pre><hr><ul><li>出栈，弹栈</li></ul><p><code>时间</code>复杂度：O(1)</p><pre><code class="C++">template &lt;class T&gt;T linkStack&lt;T&gt;::pop()&#123;    if (empty())        throw outOfRange();    Node *p = top;    T value = p-&gt;data; //* 保留栈顶元素的值    top = top-&gt;next;   //* 更新栈顶指针至下一个栈顶元素    delete p;          //* 释放出栈的栈顶元素    return value;      //* 返回出栈元素值&#125;</code></pre><hr><ul><li>取栈顶元素</li></ul><p><code>时间</code>复杂度：O(1)</p><pre><code class="C++">template &lt;class T&gt;T linkStack&lt;T&gt;::getTop() const&#123;    if (empty())        throw outOfRange();    return top-&gt;data; //* 返回栈顶元素值&#125;</code></pre><hr><ul><li>清空栈</li></ul><p>时间复杂度：O(n)</p><pre><code class="C++">template &lt;class T&gt;void linkStack&lt;T&gt;::clear()&#123;    Node *p;    while (top != NULL)    &#123;        p = top;         //* p指向当前栈顶元素        top = top-&gt;next; //*top指针依次指向写一个栈顶元素        delete p;        //* 释放p指向的当前元素    &#125;&#125;</code></pre><hr><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基本定义-2"><a href="#基本定义-2" class="headerlink" title="基本定义"></a>基本定义</h3><blockquote><p>队列（Queue），是一种<code>操作受限</code>的线性表，<code>只允许在表的一端进行插入，在表的另一端进行删除</code>。</p><p>向队列中<code>插入</code>元素的操作成为入队或进队。</p><p><code>删除</code>元素称为出队或离队。</p><p>参考现实中排队的例子不难总结队列的规律：<code>先进先出</code></p></blockquote><hr><h3 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h3><pre><code class="C++">template &lt;class T&gt;class Queue&#123;public:    virtual bool empty() const = 0;           //* 判队空    virtual int size() const = 0;             //* 求队长    virtual void clear() = 0;                 //* 清空队列    virtual void enQueue(const T &amp;value) = 0; //* 入队    virtual T deQueue() = 0;                  //* 出队    virtual T getHead() const = 0;            //* 获取队头元素    virtual ~Queue();                         //* 析构函数&#125;;</code></pre><hr><h3 id="自定义的异常处理类-2"><a href="#自定义的异常处理类-2" class="headerlink" title="自定义的异常处理类"></a>自定义的异常处理类</h3><pre><code class="C++">class outOfRange : public exception&#123;public:    const char *what() const throw()    &#123;        return &quot;ERROR, out of range&quot;;    &#125;&#125;;class errorSize : public exception&#123;public:    const char *what() const throw()    &#123;        return &quot;ERROR, error size&quot;;    &#125;&#125;;</code></pre><hr><h3 id="队列的【顺序】表示"><a href="#队列的【顺序】表示" class="headerlink" title="队列的【顺序】表示"></a>队列的【顺序】表示</h3><blockquote><p>队列的顺序实现是指分配一块<code>连续的存储单元</code>存放队列中的元素，并附设两个指针：</p><p><code>队头指针</code> front 指向队头元素</p><p><code>队尾指针</code> rear 指向队尾元素的下一个位置</p></blockquote><pre><code class="C++">template &lt;class T&gt;class seqQueue : public Queue&lt;T&gt;&#123;private:    T *data;       //* 存放数据的数组    int maxSize;   //* 队列大小    int front;     //* 队首指针    int rear;      //* 队尾指针    void resize(); //* 扩大队列容量public:    seqQueue(int size = 100);    ~seqQueue() &#123; delete[] data; &#125;    void clear() &#123; front = rear = 1; &#125;    bool empty() const &#123; return front == rear; &#125;    bool full() const &#123; (rear + 1) % maxSize == front; &#125;    int size() const &#123; return (rear - front + maxSize) % maxSize; &#125;    void enQueue(const T &amp;value);    T deQueue();    T getHead() const;&#125;;</code></pre><hr><h3 id="顺序队列的运算"><a href="#顺序队列的运算" class="headerlink" title="顺序队列的运算"></a>顺序队列的运算</h3><ul><li>初始化</li></ul><pre><code class="C++">template &lt;class T&gt;seqQueue&lt;T&gt;::seqQueue(int initSize)&#123;    if (initSize &lt;= 0)        throw errorSize();    data = new T[initSize];    maxSize = initSize;    front = rear = -1;&#125;</code></pre><hr><ul><li>进队，入队</li></ul><pre><code class="C++">template &lt;class T&gt;void seqQueue&lt;T&gt;::enQueue(const T &amp;value)&#123;    if ((rear + 1) % maxSize == front)        resize();    rear = (rear + 1) % maxSize;    data[rear] = value;&#125;</code></pre><hr><ul><li>出队，离队</li></ul><pre><code class="C++">template &lt;class T&gt;T seqQueue&lt;T&gt;::deQueue()&#123;    if (empty())        throw outOfRange();    front = (front + 1) % maxSize;    return data[front];&#125;</code></pre><hr><ul><li>取队头元素</li></ul><pre><code class="C++">template &lt;class T&gt;T seqQueue&lt;T&gt;::getHead() const&#123;    if (empty())        throw outOfRange();    return data[(front + 1) % maxSize];&#125;</code></pre><hr><ul><li>扩大队列容量</li></ul><pre><code class="C++">template &lt;class T&gt;void seqQueue&lt;T&gt;::resize()&#123;    T *p = data;    data = new T[2 * maxSize];    for (int i = 1; i &lt; maxSize; ++i)        data[i] = p[(front + i) % maxSize];    front = 0;    rear = maxSize - 1;    maxSize *= 2;    delete p;&#125;</code></pre><hr><h3 id="队列的【链式】表示"><a href="#队列的【链式】表示" class="headerlink" title="队列的【链式】表示"></a>队列的【链式】表示</h3><blockquote><p>队列的链式表示成为链队列，它实际上是一个<code>同时带有队头指针和队尾指针的单链表</code>。</p><p><code>头指针</code>指向<code>对头</code>结点</p><p><code>尾指针</code>指向<code>队尾</code>结点</p></blockquote><pre><code class="C++">template &lt;class T&gt;class linkQueue : public Queue&lt;T&gt;&#123;private:    struct Node    &#123;        T data;        Node *next;        Node(const T &amp;value, Node *n = NULL)        &#123;            data = value;            next = n;        &#125;        Node() : next(NULL) &#123;&#125;        ~Node();    &#125;;    Node *front, *rear;public:    linkQueue() &#123; front = rear = NULL; &#125;    ~linkQueue();    void clear();    bool empty() const &#123; return front == NULL; &#125;;    int size() const;    void enQueue(const T &amp;value);    T deQueue();    T getHead() const;&#125;;</code></pre><hr><h3 id="链队列的运算"><a href="#链队列的运算" class="headerlink" title="链队列的运算"></a>链队列的运算</h3><ul><li>析构</li></ul><pre><code class="C++">template &lt;class T&gt;linkQueue&lt;T&gt;::~linkQueue&lt;T&gt;()&#123;    Node *p;    while (front != NULL)    &#123;        p = front;        front = front-&gt;next;        delete p;    &#125;&#125;</code></pre><hr><ul><li>清空链队列</li></ul><pre><code class="C++">template &lt;class T&gt;void linkQueue&lt;T&gt;::clear()&#123;    Node *p;    while (front != NULL)    &#123;        p = front;        front = front-&gt;next;        delete p;    &#125;    rear = NULL;&#125;</code></pre><hr><ul><li>求队长</li></ul><pre><code class="C++">template &lt;class T&gt;int linkQueue&lt;T&gt;::size() const&#123;    Node *p = front;    int count = 0;    while (p)    &#123;        count++;        p = p-&gt;next;    &#125;    return count;&#125;</code></pre><hr><ul><li>入队，进队</li></ul><pre><code class="C++">template &lt;class T&gt;void linkQueue&lt;T&gt;::enQueue(const T &amp;value)&#123;    if (rear == NULL)    &#123;        front = rear = new Node(value);    &#125;    else    &#123;        rear-&gt;next = new Node(value);        rear = rear-&gt;next;    &#125;&#125;</code></pre><hr><ul><li>出队</li></ul><pre><code class="C++">template &lt;class T&gt;T linkQueue&lt;T&gt;::deQueue()&#123;    if (empty())        throw outOfRange();    Node *p = front;    T value = front-&gt;data;    front = front-&gt;next;        if (front == NULL)        rear = NULL;    delete p;    return value;&#125;</code></pre><hr><ul><li>输出队头元素</li></ul><pre><code class="C++">template &lt;class T&gt;T linkQueue&lt;T&gt;::getHead() const&#123;    if (empty())        throw outOfRange();    return front-&gt;data;&#125;</code></pre><hr><h2 id="有关树、图、查找与排序算法请直接参阅-Github-源码"><a href="#有关树、图、查找与排序算法请直接参阅-Github-源码" class="headerlink" title="有关树、图、查找与排序算法请直接参阅 Github 源码"></a>有关树、图、查找与排序算法请直接参阅 Github 源码</h2><ul><li><p><a href="https://github.com/PhoenixNest/Hello-C">C • Github</a></p></li><li><p><a href="https://github.com/PhoenixNest/Hello-C-Plus-Plus">C++ • Github</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试方法和技术</title>
      <link href="School-Software-Testing/"/>
      <url>School-Software-Testing/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇整理了我学习<code>软件测试与方法</code>时的一些笔记。<br>所用教科书：《软件测试方法和技术（第三版）》 – 朱少民 • 清华大学出版社</p></blockquote><hr><h2 id="一-引论"><a href="#一-引论" class="headerlink" title="(一) 引论"></a>(一) 引论</h2><h3 id="1-为什么要开展软件测试活动"><a href="#1-为什么要开展软件测试活动" class="headerlink" title="1.为什么要开展软件测试活动"></a>1.为什么要开展软件测试活动</h3><p>(1) 软件测试是保证软件质量的重要手段，所有软件都会存在或多或少的问题，错误需要测试来发现，同时还需要测试来评估错误密度。</p><p>(2) 软件测试是软件质量保证的关键步骤，越早发现错误代价越低。</p><h3 id="2-什么是软件测试"><a href="#2-什么是软件测试" class="headerlink" title="2.什么是软件测试"></a>2.什么是软件测试</h3><p>软件测试是验证和有效性确认构成的整体。</p><h3 id="3-软件测试和开发的关系"><a href="#3-软件测试和开发的关系" class="headerlink" title="3.软件测试和开发的关系"></a>3.软件测试和开发的关系</h3><p>测试活动在开发之后，测试与开发同步进行，最后再进行总的测试，没有开发就没有测试，不同的软件开发模型中，测试所处位置不同。</p><h3 id="4-软件测试与质量保证的关系"><a href="#4-软件测试与质量保证的关系" class="headerlink" title="4.软件测试与质量保证的关系"></a>4.软件测试与质量保证的关系</h3><p>软件测试和软件质量是对立统一的，软件测试既是找bug的，又能保证软件质量。对软件进行充分的测试才能够有效的保证软件质量，对软件产品进行充分测试，找出其中的缺陷。</p><hr><h2 id="二-软件测试基本概念"><a href="#二-软件测试基本概念" class="headerlink" title="(二) 软件测试基本概念"></a>(二) 软件测试基本概念</h2><h3 id="1-软件质量的定义"><a href="#1-软件质量的定义" class="headerlink" title="1.软件质量的定义"></a>1.软件质量的定义</h3><p>(1) 软件产品满足规定的和隐含的与需求能力有关的全部特征与特性</p><p>(2) 软件各种属性的组合程度</p><p>(3) 用户对软件产品的综合反映程度</p><p>(4) 软件在使用过程中满足用户需求的程度</p><h3 id="2-软件缺陷的定义"><a href="#2-软件缺陷的定义" class="headerlink" title="2.软件缺陷的定义"></a>2.软件缺陷的定义</h3><p>(1)从<code>产品内部</code>看，软件缺陷是<code>软件产品开发和维护过程中所存在的错误、毛病等各种问题</code>。</p><p>(2)从<code>外部</code>看，软件缺陷是<code>系统所需要实现的某种功能的失效或违背</code></p><h4 id="2-1-什么是软件缺陷"><a href="#2-1-什么是软件缺陷" class="headerlink" title="2.1 什么是软件缺陷"></a>2.1 什么是软件缺陷</h4><p>(1) 软件未实现产品说明书要求的功能。</p><p>(2) 软件出现了产品说明书提到不应该的错误。</p><p>(3) 软件实现了产品说明书未提到的功能。</p><p>(4) 软件未实现产品说明书<code>未提到但应实现的目标</code>。</p><p>(5) 软件难以理解、不易使用、运行缓慢等问题。</p><h4 id="2-2-修复-软件缺陷的代价"><a href="#2-2-修复-软件缺陷的代价" class="headerlink" title="2.2 修复.软件缺陷的代价"></a>2.2 修复.软件缺陷的代价</h4><p>软件缺陷随着时间的推移所带来的成本越来越大。</p><h3 id="3-软件测试的分类"><a href="#3-软件测试的分类" class="headerlink" title="3.软件测试的分类"></a>3.软件测试的分类</h3><p>单元测试 -&gt; 集成测试 -&gt; (功能测试) -&gt; 系统测试 -&gt; 验收测试</p><p>按<code>测试层次</code>：</p><p>(1) 底层测试：单元测试。</p><p>(2) 接口层次：集成测试，完成系统内单元之间接口和单元集成为一个完整系统的测试。</p><p>(3) 系统测试：负载测试、压力测试、强壮性测试。</p><p>(4) 用户层次：验收测试，验收用户是否真正所需要的产品特性，验收测试关注用户环境、用户数据，用户也需要参与测试。</p><hr><p>按<code>测试对象</code>：</p><p>(1) 单元测试</p><p>(2) 程序测试</p><p>(3) 系统测试</p><p>(4) 文档测试</p><p>(5) Web应用测试、客户端测试</p><p>(6) 数据库测试、服务器测试</p><hr><p>按<code>测试目的</code>：</p><p>(1) 功能测试：黑盒和白盒测试</p><p>(2) 性能测试</p><p>(3) 压力测试</p><p>(4) 可靠性测试</p><p>(5) 安全性测试</p><p>(6) 兼容性测试</p><p>(7) 回归测试</p><hr><p>按<code>测试阶段</code>：</p><p>(1) 需求评审、设计评审</p><p>(2) 单元测试</p><p>(3) 集成测试</p><p>(4) 系统测试</p><p>(5) 验收测试：α测、β测</p><hr><p>根据系统内部结构和具体实现算法角度分为黑盒测试和白盒测试两类；</p><p>根据测试对象在测试过程中是否发生状态变化分为动态测试和静态测试方法；</p><h3 id="4-测试计划"><a href="#4-测试计划" class="headerlink" title="4.测试计划"></a>4.测试计划</h3><p>(1) 规定<code>测试活动的范围、方法、资源和进度</code>；</p><p>(2) 明确正在测试的<code>项目</code>、要测试的<code>特性</code>、要执行的<code>测试任务</code>、每个任务的<code>负责人</code>以及与计划相关的<code>风险</code>。</p><h3 id="5-测试用例"><a href="#5-测试用例" class="headerlink" title="5.测试用例"></a>5.测试用例</h3><p>有效性、组织性、可复用性、跟踪、测试证实</p><p>(1) 测试用例是为了特定目的而设计的测试数据及其相关的测试规程的一个特定集合，或是有效发现软件缺陷的<code>最小测试执行单元</code>。</p><p>(2) 测试用例是测试工作的指导，是软件测试的必须遵守的准则，更是软件测试质量稳定的根本保障。</p><p>(3) 测试用例是测试执行的基础。</p><hr><h2 id="三-软件测试方法"><a href="#三-软件测试方法" class="headerlink" title="(三) 软件测试方法"></a>(三) 软件测试方法</h2><h3 id="1-基于直觉和经验的方法"><a href="#1-基于直觉和经验的方法" class="headerlink" title="1.基于直觉和经验的方法"></a>1.基于直觉和经验的方法</h3><p>错误推测法：</p><p>基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性地设计测试用例。</p><hr><h3 id="2-基于输入域的方法-黑盒"><a href="#2-基于输入域的方法-黑盒" class="headerlink" title="2.基于输入域的方法(黑盒)"></a>2.基于输入域的方法(黑盒)</h3><h4 id="2-1-等价类划分法"><a href="#2-1-等价类划分法" class="headerlink" title="2.1 等价类划分法"></a>2.1 等价类划分法</h4><p>等价类的分类：<code>有效</code>等价类、<code>无效</code>等价类。</p><p>有效等价类：是有意义的、合理的输入数据，可以检查程序是否实现了规格说明书中所规定的功能和性能。</p><p>无效等价类：不妈祖程序输入要求或无效的输入数据构成的集合。</p><p><code>PS</code>：在规定了输入数据必须遵守的规则的情况下，可确定一个有效等价类和若干个无效等价类。</p><h4 id="2-2-边界值分析法"><a href="#2-2-边界值分析法" class="headerlink" title="2.2 边界值分析法"></a>2.2 边界值分析法</h4><p>边界值分析是一种<code>补充等价类划分</code>的测试用例设计技术。</p><p>设计方法：</p><p>(1) 确定边界情况<code>(选择等价类边界)</code>。</p><p>(2) 选取<code>正好等于、刚刚大于或刚刚小于</code>边界值作为测试数据。</p><hr><h3 id="3-基于逻辑覆盖的方法-白盒"><a href="#3-基于逻辑覆盖的方法-白盒" class="headerlink" title="3.基于逻辑覆盖的方法(白盒)"></a>3.基于逻辑覆盖的方法(白盒)</h3><h4 id="3-3-1-判定覆盖"><a href="#3-3-1-判定覆盖" class="headerlink" title="3.3.1 判定覆盖"></a>3.3.1 判定覆盖</h4><p>使得程序中每个判定至少为True或False各一次。</p><h4 id="3-3-2-条件覆盖"><a href="#3-3-2-条件覆盖" class="headerlink" title="3.3.2 条件覆盖"></a>3.3.2 条件覆盖</h4><p>使得判定中的每个条件获得各种可能的结果。</p><h4 id="3-3-3-判定-条件覆盖"><a href="#3-3-3-判定-条件覆盖" class="headerlink" title="3.3.3 判定-条件覆盖"></a>3.3.3 判定-条件覆盖</h4><p>同时满足判定覆盖和条件覆盖。即使得程序中每个判定至少为True或False各一次，同时使得判定中的每个条件获得各种可能的结果。</p><h4 id="3-3-4-基本路径覆盖"><a href="#3-3-4-基本路径覆盖" class="headerlink" title="3.3.4 基本路径覆盖"></a>3.3.4 基本路径覆盖</h4><p>设计所有的测试用例，覆盖程序中所有可能的、独立的执行路径。</p><hr><p>V(G) = 区域数目</p><p>V(G) = 边界数目 - 节点数目 + 2</p><p>V(G) = 判断节点数 + 1</p><hr><h2 id="四-软件测试流程与规范"><a href="#四-软件测试流程与规范" class="headerlink" title="(四) 软件测试流程与规范"></a>(四) 软件测试流程与规范</h2><h3 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h3><p>测试过程和开发过程贯穿了软件过程的整个生命周期，它们是相辅相成的关系，有以下的关键点：</p><p>(1) 测试过程和开发过程是同时开始，同时结束两者保持同步关系。</p><p>(2) 测试过程是对开发过程中的阶段性结果和产品进行验证的过程，两者相互依赖。</p><p>前期：测试过程依赖于开发过程。</p><p>后期：开发过程更多地依赖于测试过程。</p><p>(3) 测试过程和开发过程的工作重点可能不一样，两者有各自的特点，不论在资源和风险管理中，两者都存在差异。</p><hr><h3 id="敏捷测试"><a href="#敏捷测试" class="headerlink" title="敏捷测试"></a>敏捷测试</h3><p>目标：尽快的交付高质量的软件。</p><p>核心(质量内建的三个关键实践)：测试左移、持续测试、测试驱动开发。</p><p>敏捷测试是一套解决方案、一类测试操作与管理的框架、一组实践或由一定顺序的测试活动构成的特定的测试流程。是不断修正质量指标、正确建立测试策略，确认客户的有效需求能得以圆满实现和确保整个生产的过程安全的、及时的发布最终产品。</p><hr><h3 id="TMM的五个等级"><a href="#TMM的五个等级" class="headerlink" title="TMM的五个等级"></a>TMM的五个等级</h3><h4 id="1-初始级"><a href="#1-初始级" class="headerlink" title="1.初始级"></a>1.初始级</h4><p>(1) 没有正式的文档化和结构化。</p><p>(2) 测试在编码后执行，与调试没有区别。</p><p>(3) 测试的目的被理解为证明软件正常工作。</p><h4 id="2-定义级"><a href="#2-定义级" class="headerlink" title="2.定义级"></a>2.定义级</h4><p>(1) 组织已设定测试方针和目标。</p><p>(2) 引入了测试计划过程。</p><p>(3) 具有基本的测试技术和方法。</p><h4 id="3-集成"><a href="#3-集成" class="headerlink" title="3.集成"></a>3.集成</h4><p>(1) 测试过程和软件开发周期集成在一起。</p><p>(2) 标准、步骤和方法的文档化。</p><p>(3) 相应的监督和控制措施。</p><h4 id="4-管理-amp-度量"><a href="#4-管理-amp-度量" class="headerlink" title="4.管理&amp;度量"></a>4.管理&amp;度量</h4><p>(1) 测试过程可有效地度量、管理。</p><h4 id="5-优化"><a href="#5-优化" class="headerlink" title="5.优化"></a>5.优化</h4><p>(1) 测试过程的数据可以用户防止错误。</p><p>(2) 注意力集中在优化已建立的过程的发生。</p><hr><h2 id="五-单元测试与集成测试"><a href="#五-单元测试与集成测试" class="headerlink" title="(五) 单元测试与集成测试"></a>(五) 单元测试与集成测试</h2><h3 id="1-单元测试的原则"><a href="#1-单元测试的原则" class="headerlink" title="1.单元测试的原则"></a>1.单元测试的原则</h3><p>自动化、独立性、可重复</p><h3 id="2-单元测试的任务"><a href="#2-单元测试的任务" class="headerlink" title="2.单元测试的任务"></a>2.单元测试的任务</h3><p>(1) 单元独立执行路径的测试：检查每一条独立执行路径的测试，保证每条语句至少被执行一次(基本路径测试)</p><p>(2) 单元局部数据结构的测试：检查局部数据结构完整性。</p><p>(3) 单元接口测试：检查模块接口是否正确。</p><p>(4) 单元边界条件的测试：检查临界数据处理的正确性。</p><p>(5) 单元容错性测试：预见、预设的各种出错处理是否正确有效。</p><p>(6) 内存分析</p><h3 id="3-单元测试常用工具"><a href="#3-单元测试常用工具" class="headerlink" title="3.单元测试常用工具"></a>3.单元测试常用工具</h3><p>单元测试工具：(xUnit工具家族)Junit、CppUnit、NUnit、HtmlUnit</p><p>静态检查工具：CheckStyle、PMD、FindBug</p><p>单元性能测试工具：SourceMonitor</p><hr><h3 id="4-静态测试"><a href="#4-静态测试" class="headerlink" title="4.静态测试"></a>4.静态测试</h3><p>包括：<code>需求评审、互查、走查、设计评审</code></p><p>定义：在<code>不执行软件</code>的条件下有条理地仔细审查<code>软件设计、体系结构和代码</code>，从而找出<code>软件缺陷</code>的过程。有时也称为结构分析。</p><p>作用：</p><p>(1) 尽早发现软件缺陷，以找出动态黑盒白盒测试难以揭示或发现的软件缺陷。</p><p>(2) 为接受该软件的黑盒测试员进行测试设计测试案例提供思路，他们不必了解代码细节，但是根据审查备注，可以确定有问题或者容易存在软件缺陷的特性范围。</p><p>问题：认为会减慢软件开发过程。</p><hr><h3 id="5-动态测试"><a href="#5-动态测试" class="headerlink" title="5.动态测试"></a>5.动态测试</h3><h4 id="5-1-驱动程序"><a href="#5-1-驱动程序" class="headerlink" title="5.1 驱动程序"></a>5.1 驱动程序</h4><p>驱动程序/驱动模块(Driver)：用以模拟被测模块的上级模块。</p><p>作用：接受测试数据，把相关的数据传送给被测模块，启动被测模块，并打印出相应的结果。</p><h4 id="5-2-桩程序"><a href="#5-2-桩程序" class="headerlink" title="5.2 桩程序"></a>5.2 桩程序</h4><p>桩程序/桩模块(Stub)：用以模拟被测模块工作过程中所调用的模块。</p><p>作用：由被测模块调用，一般只进行很少的数据处理。例如打印入口和返回，以便于检验被测模块与其下级模块的接口。</p><hr><h3 id="6-自顶向下和自底向上的集成方法"><a href="#6-自顶向下和自底向上的集成方法" class="headerlink" title="6.自顶向下和自底向上的集成方法"></a>6.自顶向下和自底向上的集成方法</h3><p>自顶向下法：类似树的层次遍历，依次结合各个模块。</p><p>自底向上法：从“原子”模块开始集成以进行测试。</p><hr><h2 id="六-系统测试"><a href="#六-系统测试" class="headerlink" title="(六)系统测试"></a>(六)系统测试</h2><h3 id="1-性能测试"><a href="#1-性能测试" class="headerlink" title="1.性能测试"></a>1.性能测试</h3><p>性能测试就是为了发现系统性能问题或获取系统性能相关指标(如运行速度、响应时间、资源使用率等)</p><h3 id="1-1-性能测试指标"><a href="#1-1-性能测试指标" class="headerlink" title="1.1 性能测试指标"></a>1.1 性能测试指标</h3><h4 id="系统资源"><a href="#系统资源" class="headerlink" title="系统资源"></a>系统资源</h4><p>CPU、内存占用率等。</p><h4 id="系统行为"><a href="#系统行为" class="headerlink" title="系统行为"></a>系统行为</h4><p>(1) 请求响应时间</p><p>客户端向服务器提交一个请求到收到响应之间的间隔时间。</p><p>(2) 事务响应时间</p><p>事务由一系列请求组成，事务的响应时间就是这些请求完成处理所花费的时间。</p><p>(3) 数据吞吐量</p><p>单位时间内客户端和服务器之间网络上传输的数据量。</p><h3 id="1-2-系统负载及其模式"><a href="#1-2-系统负载及其模式" class="headerlink" title="1.2 系统负载及其模式"></a>1.2 系统负载及其模式</h3><h4 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h4><p>并发用户并发数量 + 思考时间 + 每次请求发送的数据量 + 负载模式</p><p>(1) 在线用户：通过浏览器访问登录Web应用系统后没有退出该应用系统的用户。</p><p>(2) 并发用户：严格意义上，这些用户选择在同一时间做同一事情或同一操作；不严格地说，并发用户同时在线并操作系统，但可以是不相同操作。</p><p>(3) 用户并发数量：上述并发用户的数量，近似于同时在线的用户数量，但不等于在线用户数。</p><p>(4) 思考时间：浏览器在收到响应后到提交下一个请求之间的间隔时间。</p><p>负载模式：一次加载、递增加载、高低突变加载、随即加载等方式。</p><h3 id="2-软件兼容性测试"><a href="#2-软件兼容性测试" class="headerlink" title="2.软件兼容性测试"></a>2.软件兼容性测试</h3><p>是指验证软件之间是否正确地交互和共享信息。</p><p>要考虑的问题：</p><p>何种平台、何种应用软件、何种标准或规范、何种数据。</p><h3 id="3-向前和向后兼容"><a href="#3-向前和向后兼容" class="headerlink" title="3.向前和向后兼容"></a>3.向前和向后兼容</h3><p>向后兼容指的是可以使用软件的以前版本。</p><p>向前兼容指的是可以使用软件的未来版本。</p><hr><h2 id="七-验收测试"><a href="#七-验收测试" class="headerlink" title="(七)验收测试"></a>(七)验收测试</h2><h3 id="1-进行验收测试的条件，通过标准"><a href="#1-进行验收测试的条件，通过标准" class="headerlink" title="1.进行验收测试的条件，通过标准"></a>1.进行验收测试的条件，通过标准</h3><p>验收测试是在软件产品完成了功能测试和系统测试之后、产品发布之前所进行的软件测试活动。</p><p>标准：</p><p>(1) 完全执行了验收测试计划中的每个测试用例。</p><p>(2) 在验收测试中发现的错误已经得到修改并通过了测试或经过评估留到下一版本中修改。</p><p>(3) 完成验收测试报告。</p><h3 id="2-如何进行产品说明书的验证"><a href="#2-如何进行产品说明书的验证" class="headerlink" title="2.如何进行产品说明书的验证"></a>2.如何进行产品说明书的验证</h3><p>测试人员根据产品说明书，逐字逐句地验证产品每一项特征，并在验证结束时提交基于产品规格说明书地验证报告。</p><h3 id="3-用户界面测试有哪些要素"><a href="#3-用户界面测试有哪些要素" class="headerlink" title="3.用户界面测试有哪些要素"></a>3.用户界面测试有哪些要素</h3><p>(1) 符合标准和规范</p><p>(2) 直观性</p><p>(3) 一致性</p><p>(4) 灵活性</p><p>(5) 舒适性</p><p>(6) 正确性</p><p>(7) 实用性</p><hr><h2 id="八-软件本地化测试"><a href="#八-软件本地化测试" class="headerlink" title="(八)软件本地化测试"></a>(八)软件本地化测试</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><h4 id="1-1-G11N-I18N-L10N"><a href="#1-1-G11N-I18N-L10N" class="headerlink" title="1.1 G11N = I18N + L10N"></a>1.1 G11N = I18N + L10N</h4><p>软件全球化 = 软件国际化 + 软件本地化</p><h4 id="1-2-软件国际化-Internationlization-I18N"><a href="#1-2-软件国际化-Internationlization-I18N" class="headerlink" title="1.2 软件国际化(Internationlization, I18N)"></a>1.2 软件国际化(Internationlization, I18N)</h4><p>是在软件设计和文档开发过程中，使得功能和代码设计能处理多种语言和文化传统。创建不要语言版本时，不需要重新设计源程序代码的软件工程方法。</p><h4 id="1-3-软件本地化-Localization-L10N"><a href="#1-3-软件本地化-Localization-L10N" class="headerlink" title="1.3 软件本地化(Localization, L10N)"></a>1.3 软件本地化(Localization, L10N)</h4><p>是将一个软件产品按特定国家/地区或语言市场的需要进行<code>全面定制</code>的过程。</p><h3 id="2-I18N与L10N的关系"><a href="#2-I18N与L10N的关系" class="headerlink" title="2. I18N与L10N的关系"></a>2. I18N与L10N的关系</h3><p>(1) 国际化是本地化的基础和前提，为本地化做准备，使本地化过程不需要对代码进行改动就能完成。</p><p>(2) 本地化是国际化向特定本地语言环境的转换，本地化要适应国际化的规定。</p><p>(3) 国际化软件，或在应用软件运行时可以动态切换语言，或在软件启动前或启动时可以设置语言。</p><hr><h2 id="九-测试自动化"><a href="#九-测试自动化" class="headerlink" title="(九)测试自动化"></a>(九)测试自动化</h2><h3 id="1-手工测试和自动化测试的区别"><a href="#1-手工测试和自动化测试的区别" class="headerlink" title="1.手工测试和自动化测试的区别"></a>1.手工测试和自动化测试的区别</h3><p>(1) 自动运行的速度更快、执行效率高，是手工无法相比的。</p><p>(2) 手工测试会感觉累，但机器不会感觉累，可以不间断工作。</p><p>(3) 测试结果准确。</p><p>(4) 可靠。人可以撒谎，但机器不会。</p><p>(5) 可复用性。一旦完成所用脚本，可多次执行。</p><p>(6) 特别能力。当需要模拟大量并发的时候，人工测试显然是不现实的，但机器则可以模拟大量的并发量。</p><h3 id="2-测试自动化实现中，关键的技术是什么？"><a href="#2-测试自动化实现中，关键的技术是什么？" class="headerlink" title="2.测试自动化实现中，关键的技术是什么？"></a>2.测试自动化实现中，关键的技术是什么？</h3><p>识别用户界面的元素以及捕获键盘、鼠标的输入，将操作过程转换为测试工具可执行的脚本；然后，对脚本进行修改和优化，加入测试的验证点；最后通过测试工具运行测试脚本，将实际输出与期望结果进行比对，确定是否存在差异。</p><hr><h2 id="十-部署测试环境"><a href="#十-部署测试环境" class="headerlink" title="(十) 部署测试环境"></a>(十) 部署测试环境</h2><h3 id="1-测试环境的定义"><a href="#1-测试环境的定义" class="headerlink" title="1.测试环境的定义"></a>1.测试环境的定义</h3><h4 id="1-1-设计环境"><a href="#1-1-设计环境" class="headerlink" title="1.1 设计环境"></a>1.1 设计环境</h4><p>设计环境指编制测试计划、说明、报告及与测试有关的文件所基于的软、硬件设备和支持。</p><h4 id="1-2-实施环境"><a href="#1-2-实施环境" class="headerlink" title="1.2 实施环境"></a>1.2 实施环境</h4><p>实施环境指对软件系统进行各项测试所基于的软、硬件设备和支持。</p><h4 id="1-3-管理环境"><a href="#1-3-管理环境" class="headerlink" title="1.3 管理环境"></a>1.3 管理环境</h4><p>管理环境指管理测试资源所基于的软、硬件设备和支持。</p><h3 id="2-要素"><a href="#2-要素" class="headerlink" title="2.要素"></a>2.要素</h3><h4 id="1-软件"><a href="#1-软件" class="headerlink" title="(1) 软件"></a>(1) 软件</h4><p>操作系统、网络协议和应用程序。</p><h4 id="2-硬件"><a href="#2-硬件" class="headerlink" title="(2) 硬件"></a>(2) 硬件</h4><p>网络设备、服务器、测试用机。</p><h4 id="3-网络环境"><a href="#3-网络环境" class="headerlink" title="(3) 网络环境"></a>(3) 网络环境</h4><p>相关网络设备、网络系统软件及配置。</p><h4 id="4-数据准备"><a href="#4-数据准备" class="headerlink" title="(4) 数据准备"></a>(4) 数据准备</h4><p>测试数据、要尽可能的取得大量真实数据。</p><h4 id="5-测试工具"><a href="#5-测试工具" class="headerlink" title="(5) 测试工具"></a>(5) 测试工具</h4><p>自动化及测试管理软件，监控诊断的使用工具等。</p><hr><h2 id="十一-测试执行、缺陷报告与跟踪"><a href="#十一-测试执行、缺陷报告与跟踪" class="headerlink" title="(十一)测试执行、缺陷报告与跟踪"></a>(十一)测试执行、缺陷报告与跟踪</h2><h3 id="1-软件缺陷的生命周期"><a href="#1-软件缺陷的生命周期" class="headerlink" title="1.软件缺陷的生命周期"></a>1.软件缺陷的生命周期</h3><p>发现 -&gt; 打开 -&gt; 修复 -&gt; 关闭</p><p>“新打开的”：发现 -&gt; 打开</p><p>“已修正的”：打开 -&gt; 修复</p><p>“已关闭的”：修复 -&gt; 关闭</p><p>生命周期的概念是一个物种从诞生到消亡经历了不同的生命阶段，软件缺陷生命周期指的是一个软件缺陷被发现、报告到这个缺陷被修复、验证直到最后关闭的完整过程。</p><h3 id="2-软件缺陷的等级"><a href="#2-软件缺陷的等级" class="headerlink" title="2.软件缺陷的等级"></a>2.软件缺陷的等级</h3><h4 id="2-1-严重性"><a href="#2-1-严重性" class="headerlink" title="2.1 严重性"></a>2.1 严重性</h4><p>分类：</p><p>(1) 致命：系统崩溃、数据丢失、数据毁坏、安全性被破坏。</p><p>(2) 严重：功能或特性没有实现，主要功能部分丧失，次要功能部分丧失或致命错误声明。</p><p>(3) 一般：系统的部分功能没有完全实现，但不影响用户的正常使用。例如：提示信息不太准确；用户界面差；操作时间长等一些问题。</p><p>(4) 较小：小问题，对功能几乎没有影响。</p><h4 id="2-2-优先级"><a href="#2-2-优先级" class="headerlink" title="2.2 优先级"></a>2.2 优先级</h4><p>分类：</p><p>(1) 立即修复(P1)：缺陷导致系统几乎不能使用或测试不能继续，需立即修复。</p><p>(2) 高优先级(P2)：缺陷严重，影响测试，需优先考虑。</p><p>(3) 正常排队(P3)：缺陷正常排队等待修复。</p><p>(4) 低优先级(P4)：即使有此缺陷产品也能发布，可在开发人员有时间的时候纠正。</p><h3 id="3-如何有效描述软件缺陷"><a href="#3-如何有效描述软件缺陷" class="headerlink" title="3.如何有效描述软件缺陷"></a>3.如何有效描述软件缺陷</h3><p>基本原则：</p><p>(1) 单一准确：尽量一个报告只针对一个软件缺陷。</p><p>(2) 可再现：提供精确步骤，可再现并修复缺陷。</p><p>(3) 完整统一：完整前后统一的软件缺陷。</p><p>(4) 短小简练：只给出事实和演示软件缺陷必须的细节。</p><p>(5) 特点条件；通常情况下软件没有问题，而是在特点条件下出现，所以缺陷描述时不要忽视这些特定条件</p><p>(6) 对缺陷跟踪到底：从发现Bug开始，要保证它被正确的报告直至修复的全过程。</p><p>(7) 不要评价缺陷。</p><h3 id="4-缺陷报告"><a href="#4-缺陷报告" class="headerlink" title="4.缺陷报告"></a>4.缺陷报告</h3><p>组成：</p><p>一份优秀的缺陷报告记录不仅包括了期望结果、实际结果和必要的附件，还提供必要的数据、测试环境或条件，以及简单的分析。</p><!-- 缺陷分布报告、缺陷趋势报告、缺陷年龄报告、缺陷结果进度报告 -->]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 软件测试方法和技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu Desktop • Optimization</title>
      <link href="Ubuntu-Desktop-Optimization/"/>
      <url>Ubuntu-Desktop-Optimization/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇将介绍最近对<code>Ubuntu Desktop 20.04LTS</code>优化的一些笔记分享。<br>本文将<code>不定期</code>更新。</p></blockquote><blockquote><p>Ubuntu是一个以桌面应用为主的Linux操作系统，其名称来自非洲南部祖鲁语或豪萨语的“ubuntu”一词，意思是“人性”“我的存在是因为大家的存在”，是非洲传统的一种价值观。Ubuntu基于Debian发行版和Gnome桌面环境，而从11.04版起，Ubuntu发行版放弃了Gnome桌面环境，改为Unity。从前人们认为Linux难以安装、难以使用，在Ubuntu出现后这些都成为了历史。Ubuntu也拥有庞大的社区力量，用户可以方便地从社区获得帮助。自Ubuntu 18.04 LTS起，Ubuntu发行版又重新开始使用GNOME3桌面环境。</p></blockquote><hr><h2 id="一些实用的-APT-工具"><a href="#一些实用的-APT-工具" class="headerlink" title="一些实用的 APT 工具"></a>一些实用的 APT 工具</h2><pre><code class="bash"># neofetch - 系统信息sudo apt install neofetch# htop - 性能监视器sudo apt install htop# Vim - 大名鼎鼎的文本编辑器sudo apt install vim# Thunderbird - 邮箱管理sudo apt install thunderbird# Remmina - Linux下不输给XShell的远程连接工具sudo apt install remmina</code></pre><hr><h2 id="Ubuntu-Cleaner-Ubuntu-清理工具"><a href="#Ubuntu-Cleaner-Ubuntu-清理工具" class="headerlink" title="Ubuntu Cleaner - Ubuntu 清理工具"></a>Ubuntu Cleaner - Ubuntu 清理工具</h2><pre><code class="bash">sudo add-apt-repository ppa:gerardpuig/ppasudo apt updatesudo apt install ubuntu-cleaner</code></pre><hr><h2 id="Nvidia-驱动"><a href="#Nvidia-驱动" class="headerlink" title="Nvidia 驱动"></a>Nvidia 驱动</h2><pre><code class="bash"># 检查适合系统的NAVIDIA版本nvidia-detector # 安装推荐的显卡驱动 - xxx为你的推荐显驱sudo apt install nvidia-driver-xxx# 检测安装是否成功nvidia-smi# 查看NVIDIA显卡型号lspci |grep -i nvidia# 查看NVIDIA驱动版本sudo dpkg --list | grep nvidia-*</code></pre><h3 id="卸载-Nidia-驱动"><a href="#卸载-Nidia-驱动" class="headerlink" title="卸载 Nidia 驱动"></a>卸载 Nidia 驱动</h3><pre><code class="bash">sudo apt-get --purge remove nvidia*sudo apt-get --purge remove &quot;*nvidia*&quot;sudo apt-get --purge remove &quot;*cublas*&quot; &quot;cuda*&quot;sudo apt autoremove</code></pre><hr><!-- ## 亮度调节[How do I change the backlight intensity / brightness of external display ASUS Screenpad](https://askubuntu.com/questions/1200391/how-do-i-change-the-backlight-intensity-brightness-of-external-display-asus-sc)```bashecho 255 | sudo tee '/sys/class/leds/asus::screenpad/brightness'``````bashsudo add-apt-repository ppa:apandada1/brightness-controllersudo apt updatesudo apt install brightness-controller```--- --><h2 id="UI-美化"><a href="#UI-美化" class="headerlink" title="UI 美化"></a>UI 美化</h2><h3 id="gnome-tweaks-整体调整工具"><a href="#gnome-tweaks-整体调整工具" class="headerlink" title="gnome-tweaks - 整体调整工具"></a>gnome-tweaks - 整体调整工具</h3><pre><code class="bash">sudo apt install gnome-tweaks</code></pre><p><a href="https://extensions.gnome.org/">Gnome Extensions</a></p><ul><li><p>Dash To Dock</p></li><li><p>NetSpeed - 顶栏网速监控</p></li><li><p>Blyr - 控制台虚化</p></li></ul><p><a href="https://www.gnome-look.org/browse/cat/">Download Gnome Theme</a></p><h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><pre><code class="bash">sudo apt install sassc optipng libcanberra-gtk-module libglib2.0-dev libxml2-utils </code></pre><hr><h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><h3 id="从-NodeSource-中安装-Node-js-和-npm"><a href="#从-NodeSource-中安装-Node-js-和-npm" class="headerlink" title="从 NodeSource 中安装 Node.js 和 npm"></a>从 NodeSource 中安装 Node.js 和 npm</h3><blockquote><p><a href="https://nodesource.com/">NodeSource</a> 是一个公司，聚焦于提供企业级的 Node 支持。它维护了一个 APT 软件源，其中包含了很多 Node.js 版本。如果你的应用需要指定版本的Node.js 版本，使用这个软件源。</p></blockquote><ul><li>以 sudo 用户身份运行下面的命令，下载并执行 NodeSource 安装脚本：</li></ul><pre><code class="bash">curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -</code></pre><p>这个脚本将会添加 NodeSource 的签名 key 到你的系统，创建一个 apt 源文件，安装必备的软件包，并且刷新 apt 缓存。</p><p>如果你需要另外的 Node.js 版本，例如12.x，将setup_14.x修改为setup_12.x。</p><ul><li>一旦 NodeSource 源被启用，安装 Node.js 和 npm:</li></ul><pre><code class="bash">sudo apt install nodejs</code></pre><p>nodejs 软件包同时包含node和npm二进制包。</p><ul><li>验证 Node.js 和 npm 是否正确安装。</li></ul><pre><code class="bash">node -vnpm -v</code></pre><hr><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><pre><code class="bash">sudo apt install git</code></pre><h3 id="Github-Desktop"><a href="#Github-Desktop" class="headerlink" title="Github Desktop"></a>Github Desktop</h3><p><a href="https://meshworld.in/install-github-desktop-on-ubuntu-20-04-or-ubuntu-based-distributions/">install-github-desktop-on-ubuntu-20-04-or-ubuntu-based-distributions</a></p>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu Desktop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDS • Snort</title>
      <link href="IDS-Snort/"/>
      <url>IDS-Snort/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇将介绍我在工作期间，对办公室的一台<code>测试用服务器</code>部署<code>IDS（Intrusion ddetection System）入侵检测系统</code>时的一些笔记分享。</p></blockquote><blockquote><p>在1998年，Martin Roesch用C语言开发了开放源代码(Open Source)的入侵检测系统Snort。直至今天，Snort已发展成为一个具有多平台(Multi-Platform)、<code>实时(Real-Time)流量分析</code>、<code>网络IP数据包(Pocket)记录</code>等特性的强大的网络入侵检测/防御系统(Network Intrusion Detection/Prevention System)，即<code>NIDS/NIPS</code>。Snort符合通用公共许可(GPL——GNU General Pubic License)，在网上可以通过免费下载获得Snort，并且只需要几分钟就可以安装并开始使用。</p></blockquote><hr><h2 id="一-部署Snort"><a href="#一-部署Snort" class="headerlink" title="(一) 部署Snort"></a>(一) 部署Snort</h2><pre><code class="bash">sudo apt-get install libpcap-dev bison flexsudo apt-get install snort</code></pre><h2 id="二-嗅探"><a href="#二-嗅探" class="headerlink" title="(二) 嗅探"></a>(二) 嗅探</h2><h3 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1. 基础用法"></a>1. 基础用法</h3><pre><code class="bash">sudo snort -v</code></pre><h3 id="2-展示数据内容"><a href="#2-展示数据内容" class="headerlink" title="2. 展示数据内容"></a>2. 展示数据内容</h3><pre><code class="bash">sudo snort -vd</code></pre><h2 id="三-网络IP数据包记录"><a href="#三-网络IP数据包记录" class="headerlink" title="(三) 网络IP数据包记录"></a>(三) 网络IP数据包记录</h2><pre><code class="bash">sudo mkdir snortLogssudo snort -d -l snortLogs</code></pre><p>以上命令将会在snortLogs文件夹(用户可自行选择日志文件保存位置)下创建一个<code>.log.xxxxxx</code>结尾的日志文件，要查看该文件，可直接通过<a href="https://www.wireshark.org/download.html">WireShark</a>打开，或使用以下命令：</p><pre><code class="bash">snort -d -v -r your-log-file-name.log.xxxxxx</code></pre><h2 id="四-NIDS"><a href="#四-NIDS" class="headerlink" title="(四) NIDS"></a>(四) NIDS</h2><p>未完待续…</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.snort.org/">Snort Official</a></p></li><li><p><a href="https://linuxhint.com/snort-ubuntu-tutorial/">LinuxHint • Snort Ubuntu Tutorial</a></p></li><li><p><a href="https://www.wireshark.org/">WireShark</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> IDS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Command Manual</title>
      <link href="Linux-Command-Manual/"/>
      <url>Linux-Command-Manual/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇将介绍我在学习有关<code>Linux终端使用</code>的一些笔记分享。</p><p>必要时请使用<code>sudo</code>权限，但<code>不建议</code>所有命令均使用sudo。</p></blockquote><blockquote><p>Linux，全称GNU/Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。Linux有上百种不同的发行版，如基于社区开发的debian、archlinux，和基于商业开发的Red Hat Enterprise Linux、SUSE、Oracle Linux等。</p></blockquote><hr><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="获取所有网卡的IP地址"><a href="#获取所有网卡的IP地址" class="headerlink" title="获取所有网卡的IP地址"></a>获取所有网卡的IP地址</h3><pre><code class="bash"># get the IP address of all interfacesnetworkctl status</code></pre><h3 id="显示所有主机的IP地址"><a href="#显示所有主机的IP地址" class="headerlink" title="显示所有主机的IP地址"></a>显示所有主机的IP地址</h3><pre><code class="bash"># display all IP addresses of the hosthostname -I</code></pre><h3 id="开启-关闭某个网络接口"><a href="#开启-关闭某个网络接口" class="headerlink" title="开启/关闭某个网络接口"></a>开启/关闭某个网络接口</h3><pre><code class="bash"># enable/disable interfaceip link set &lt;interface&gt; upip link set &lt;interface&gt; down</code></pre><h3 id="防火墙规则"><a href="#防火墙规则" class="headerlink" title="防火墙规则"></a>防火墙规则</h3><pre><code class="bash"># enable firewall:sudo ufw enable# list rules:sudo ufw status# allow port:sudo ufw allow &lt;port&gt;# sudo ufw allow 22# deny port:sudo ufw deny &lt;port&gt;</code></pre><h3 id="SSH远程连接"><a href="#SSH远程连接" class="headerlink" title="SSH远程连接"></a>SSH远程连接</h3><pre><code class="bash"># connect remotely through SSHssh &lt;user&gt;@&lt;host IP&gt;</code></pre><hr><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="查看当前登录账户"><a href="#查看当前登录账户" class="headerlink" title="查看当前登录账户"></a>查看当前登录账户</h3><pre><code class="bash"># show which users are logged inw</code></pre><h3 id="查看用户密码逾期时间"><a href="#查看用户密码逾期时间" class="headerlink" title="查看用户密码逾期时间"></a>查看用户密码逾期时间</h3><pre><code class="bash"># Get password expiration date for &lt;user&gt;chage -l &lt;user&gt;</code></pre><h3 id="设置用户密码逾期时间"><a href="#设置用户密码逾期时间" class="headerlink" title="设置用户密码逾期时间"></a>设置用户密码逾期时间</h3><pre><code class="bash"># Set password expiration date for &lt;user&gt;sudo chage &lt;user&gt;</code></pre><h3 id="锁定用户"><a href="#锁定用户" class="headerlink" title="锁定用户"></a>锁定用户</h3><pre><code class="bash"># lock a user accountsudo passwd -l &lt;user&gt;</code></pre><h3 id="解锁用户"><a href="#解锁用户" class="headerlink" title="解锁用户"></a>解锁用户</h3><pre><code class="bash"># unlock a user accountsudo passwd -u &lt;user&gt;</code></pre><h3 id="列出开放的端口与其关联的进程"><a href="#列出开放的端口与其关联的进程" class="headerlink" title="列出开放的端口与其关联的进程"></a>列出开放的端口与其关联的进程</h3><pre><code class="bash"># List open ports and associated processessudo netstat -tulpn</code></pre><h3 id="自动检测并禁止危险IP"><a href="#自动检测并禁止危险IP" class="headerlink" title="自动检测并禁止危险IP"></a>自动检测并禁止危险IP</h3><pre><code class="bash"># automatically detect and ban abusive IP addressessudo apt install fail2ban# show banned IP addressessudo fail2ban-client statussudo fail2ban-client status &lt;jail&gt;</code></pre><h3 id="内核热更新"><a href="#内核热更新" class="headerlink" title="内核热更新"></a>内核热更新</h3><pre><code class="bash"># visit ubuntu.com/livepatch to get a free token for up to 3 machines.sudo snap install canonical-livepatchsudo canonical-livepatch enable &lt;token&gt;</code></pre><hr><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件列表"><a href="#文件列表" class="headerlink" title="文件列表"></a>文件列表</h3><pre><code class="bash"># List filesls# List files with permissions and datesls -al</code></pre><h3 id="文件间操作"><a href="#文件间操作" class="headerlink" title="文件间操作"></a>文件间操作</h3><pre><code class="bash"># create empty:touch &lt;filename&gt;# create with content:echo &quot;&lt;content&gt;&quot; &gt; &lt;filename&gt;# append content:echo &quot;&lt;content&gt;&quot; &gt;&gt; &lt;filename&gt;# display a text file:cat &lt;file&gt;# copy:cp &lt;file&gt; &lt;target filename&gt;# move/rename:mv &lt;file&gt; &lt;target directory/filename&gt;# delete:rm &lt;file&gt;# find files modified in the last n minutesfind &lt;directory&gt; -mmin -&lt;n&gt; -type f# eg. find . -mmin -5 -type f# display file paginatedless &lt;filename&gt;# display first n lineshead -n &lt;n&gt; &lt;filename&gt;# display last n linetail -n &lt;n&gt; &lt;filename&gt;# follow file content as it inncreasestail -f &lt;filename&gt;</code></pre><h3 id="压缩文件操作"><a href="#压缩文件操作" class="headerlink" title="压缩文件操作"></a>压缩文件操作</h3><pre><code class="bash"># Pack a directory into an archive# zip: zip -r &lt;target&gt; &lt;source dir&gt;# tar.gz: tar cvzf &lt;target&gt;.tar.gz &lt;source dir&gt;# Unpack an archive# zip: unzip &lt;zip file&gt;# tar.gz: tar xf &lt;tar.gz file&gt;</code></pre><h3 id="远程服务器文件操作"><a href="#远程服务器文件操作" class="headerlink" title="远程服务器文件操作"></a>远程服务器文件操作</h3><pre><code class="bash"># Copy file to remote serverscp &lt;filename&gt; &lt;user@server&gt;:&lt;destination&gt;# eg. scp config.yaml admin@192.0.0.0:/config# Copy directory recursively from remote serverscp -r &lt;user@server&gt;:&lt;source&gt; &lt;destination&gt;# eg. scp -r admin@192.0.0.0:/config /tmp</code></pre><h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><pre><code class="bash"># create a directorymkdir &lt;directory&gt;# create directories recursivelymkdir -p &lt;directory1&gt;&lt;directory2&gt;...# delete a directory recursivelyrm -r &lt;directory1&gt;&lt;directory2&gt;...</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><pre><code class="bash"># quick file searchlocate &lt;q&gt;# search string in filegrep &lt;string&gt; &lt;filename&gt;# search string recursively in directorygrep -Iris &lt;string&gt; &lt;directory&gt;</code></pre><hr><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><h3 id="软-硬件信息"><a href="#软-硬件信息" class="headerlink" title="软/硬件信息"></a>软/硬件信息</h3><pre><code class="bash"># display kernel versionuname -r# get disk usagedf -h# get memory usagecat /proc/meminfo</code></pre><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><pre><code class="bash"># get system timetimedatectl status# set system timezonetimedatectl list-timezonessudo timedatectl set-timezone &lt;zone&gt;</code></pre><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><pre><code class="bash"># monitor new logs for a servicejournalctl -u &lt;service&gt; --since now -f</code></pre><h3 id="登录记录"><a href="#登录记录" class="headerlink" title="登录记录"></a>登录记录</h3><pre><code class="bash"># get the list of recent loginslast</code></pre><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><pre><code class="bash"># display running processessudo apt install htophtop</code></pre><h3 id="服务-进程-任务管理"><a href="#服务-进程-任务管理" class="headerlink" title="服务/进程/任务管理"></a>服务/进程/任务管理</h3><pre><code class="bash"># get all running servicessystemctl --state running# start or stop a serviceservice &lt;service&gt; start/stop# kill process by idkill &lt;process id&gt;# kill process by namepkill &lt;process name&gt;# run command in the background&lt;command&gt; &amp;# display background commandsjobs# bring command &lt;n&gt; to the foregroundfg &lt;n&gt;</code></pre><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://cdn.jsdelivr.net/gh/PhoenixNest/Warehouse@master/Notes/The%20Linux%20Command%20Line.pdf">The Linux Command Line</a></p></li><li><p><a href="https://cdn.jsdelivr.net/gh/PhoenixNest/Warehouse@master/Notes/Ubuntu%20Server%20CLI%20pro%20tips.pdf">Ubuntu Server CLI pro tips</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenStack</title>
      <link href="OpenStack-Manual/"/>
      <url>OpenStack-Manual/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇将介绍最近在<code>Ubuntu Sever 20.04LTS</code>上折腾 <code>OpenStack</code>时的一些笔记分享。</p></blockquote><blockquote><p>OpenStack是一个开源的云计算管理平台项目，是一系列软件开源项目的组合。由NASA(美国国家航空航天局)和Rackspace合作研发并发起，以Apache许可证（Apache软件基金会发布的一个自由软件许可证）授权的开源代码项目。<br>OpenStack为私有云和公有云提供可扩展的弹性的云计算服务。项目目标是提供实施简单、可大规模扩展、丰富、标准统一的云计算管理平台。</p></blockquote><hr><p>在对OpenStack进行部署前，你需要执行👇：</p><pre><code class="bash"># refresh software listsudo apt-get update# [Optional] Upgrade your local softwaresudo apt-get upgrade# install MicroStack# --devmode 将不会收到更新sudo snap install microstack --beta --devmode# Once installed, you should see the following message on the terminal:microstack (beta) stein from Canonical✓ installed</code></pre><hr><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><blockquote><p>自动初始化</p></blockquote><pre><code class="bash">sudo microstack init --auto --control</code></pre><blockquote><p>生成登录密钥</p></blockquote><p>登录端口： <span><a href="http://10.20.20.1/">http://10.20.20.1/</a></span></p><pre><code class="bash">sudo snap get microstack config.credentials.keystone-password</code></pre><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://ubuntu.com/openstack/install">Canonical • Install OpenStack yourself</a></p></li><li><p><a href="https://discourse.charmhub.io/t/microstack-install-error/4047/3">OpenStack • Microstack install error</a></p></li><li><p><a href="https://docs.openstack.org/newton/install-guide-ubuntu/">OpenStack • Installation Tutorial for Ubuntu</a></p></li><li><p><a href="https://docs.openstack.org/image-guide/ubuntu-image.html">OpenStack • Example: Ubuntu image</a></p></li><li><p><a href="https://docs.openstack.org/horizon/queens/install/install-ubuntu.html">OpenStack • Install and configure for Ubuntu</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cloud-Serving </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenStack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu Server • MySQL</title>
      <link href="Ubuntu-Server-MySQL/"/>
      <url>Ubuntu-Server-MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇将介绍最近在<code>Ubuntu Server 20.04LTS</code>上折腾 <code>MySQL</code>时的一些笔记分享。</p></blockquote><blockquote><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。<br>MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。<br>MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。</p></blockquote><hr><p>在对MySQL进行部署与配置前，你需要执行👇：</p><pre><code class="bash"># refresh software listsudo apt-get update# [Optional] Upgrade your local softwaresudo apt-get upgrade# install MySQLsudo apt-get install mysql-server</code></pre><hr><h2 id="（一）修改MySQL数据源Data文件夹位置"><a href="#（一）修改MySQL数据源Data文件夹位置" class="headerlink" title="（一）修改MySQL数据源Data文件夹位置"></a>（一）修改MySQL数据源Data文件夹位置</h2><p><code>Tips:</code> 原有MySQL的Data路径为/var/lib/mysql/，当我们进行长期存储时，硬盘空间将会持续吃紧，故本章介绍如何迁移MySQL中的Data路径以将MySQL的数据保存更换到新硬盘。</p><h3 id="Step1-关闭MySQL服务"><a href="#Step1-关闭MySQL服务" class="headerlink" title="Step1: 关闭MySQL服务"></a>Step1: 关闭MySQL服务</h3><pre><code class="bash"># 检查原有Data目录位置，默认的MySQL中Data文件夹位置位于 /var/lib/mysql/sudo mysql# 输出结果：Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 8Server version: 8.0.21-0ubuntu0.20.04.3 (Ubuntu)Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; select @@datadir;+-------------------+| @@datadir         |+-------------------+| /var/lib/mysql/ |+-------------------+1 row in set (0.00 sec)# 关闭MySQL服务sudo systemctl stop mysql</code></pre><hr><h3 id="Step2-检查MySQL运行状况"><a href="#Step2-检查MySQL运行状况" class="headerlink" title="Step2: 检查MySQL运行状况"></a>Step2: 检查MySQL运行状况</h3><pre><code class="bash">sudo systemctl status mysql# 输出结果：• mysql.service - MySQL Community Server     Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)     Active: inactive (dead) since Mon 2020-08-03 03:32:37 UTC; 1h 55min ago   Main PID: 5065 (code=exited, status=0/SUCCESS)     Status: &quot;Server shutdown complete&quot;Aug 03 03:06:59 ubuntu-server systemd[1]: Starting MySQL Community Server...Aug 03 03:07:00 ubuntu-server systemd[1]: Started MySQL Community Server.Aug 03 03:32:35 ubuntu-server systemd[1]: Stopping MySQL Community Server...Aug 03 03:32:37 ubuntu-server systemd[1]: mysql.service: Succeeded.Aug 03 03:32:37 ubuntu-server systemd[1]: Stopped MySQL Community Server.</code></pre><hr><h3 id="Step3-迁移原MySQL数据文件"><a href="#Step3-迁移原MySQL数据文件" class="headerlink" title="Step3: 迁移原MySQL数据文件"></a>Step3: 迁移原MySQL数据文件</h3><p><code>Tips:</code> 假定待迁移Data目录为: /data/test</p><pre><code class="bash">sudo rsync -av /var/lib/mysql /data/test</code></pre><hr><h3 id="Step4-备份原MySQL数据文件"><a href="#Step4-备份原MySQL数据文件" class="headerlink" title="Step4: 备份原MySQL数据文件"></a>Step4: 备份原MySQL数据文件</h3><pre><code class="bash">sudo mv /var/lib/mysql /var/lib/mysql.bak</code></pre><hr><h3 id="Step5-交接目标目录权限"><a href="#Step5-交接目标目录权限" class="headerlink" title="Step5: 交接目标目录权限"></a>Step5: 交接目标目录权限</h3><pre><code class="bash">sudo chown -R mysql:mysql /data/test</code></pre><hr><h3 id="Step6-修改MySQL配置文件"><a href="#Step6-修改MySQL配置文件" class="headerlink" title="Step6: 修改MySQL配置文件"></a>Step6: 修改MySQL配置文件</h3><pre><code class="bash">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><p><code>Tips:</code> 修改[mysqld]组中datadir的属性值，新增一行datadir键值。</p><pre><code class="bash">······[mysqld]## * Basic Settings#user            = mysql# pid-file      = /var/run/mysqld/mysqld.pid# socket        = /var/run/mysqld/mysqld.sock# port          = 3306# datadir       = /var/lib/mysql  datadir       = /data/test/mysql······</code></pre><hr><h3 id="Step7-修改apparmor的别名配置文件"><a href="#Step7-修改apparmor的别名配置文件" class="headerlink" title="Step7: 修改apparmor的别名配置文件"></a>Step7: 修改apparmor的别名配置文件</h3><pre><code class="bash">sudo vim /etc/apparmor.d/tunables/alias</code></pre><p><code>Tips:</code> 新增一项别名，并指向目标位置。</p><pre><code class="bash"># Alias rules can be used to rewrite paths and are done after variable# resolution. For example, if &#39;/usr&#39; is on removable media:# alias /usr/ -&gt; /mnt/usr/,## Or if mysql databases are stored in /home:# alias /var/lib/mysql/ -&gt; /home/mysql/,  alias /var/lib/mysql/ -&gt; /data/test/mysql/,</code></pre><hr><h3 id="Step8-重启系统apparmor服务"><a href="#Step8-重启系统apparmor服务" class="headerlink" title="Step8: 重启系统apparmor服务"></a>Step8: 重启系统apparmor服务</h3><pre><code class="bash">sudo invoke-rc.d apparmor reloadsudo systemctl restart apparmor</code></pre><hr><h3 id="Step9-越过MySQL检查"><a href="#Step9-越过MySQL检查" class="headerlink" title="Step9: 越过MySQL检查"></a>Step9: 越过MySQL检查</h3><pre><code class="bash">sudo mkdir /var/lib/mysql/mysql -p</code></pre><hr><h3 id="Step10-重启MySQL服务"><a href="#Step10-重启MySQL服务" class="headerlink" title="Step10: 重启MySQL服务"></a>Step10: 重启MySQL服务</h3><pre><code class="bash">sudo systemctl start mysqlsudo systemctl status mysql# 输出结果：● mysql.service - MySQL Community Server     Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)     Active: active (running) since Mon 2020-08-03 05:42:18 UTC; 7s ago    Process: 10205 ExecStartPre=/usr/share/mysql/mysql-systemd-start pre (code=exited, status&gt;   Main PID: 10228 (mysqld)     Status: &quot;Server is operational&quot;      Tasks: 39 (limit: 2249)     Memory: 334.7M     CGroup: /system.slice/mysql.service             └─10228 /usr/sbin/mysqldAug 03 05:42:17 ubuntu-server systemd[1]: Starting MySQL Community Server...Aug 03 05:42:18 ubuntu-server systemd[1]: Started MySQL Community Server.</code></pre><hr><h3 id="End-修改后的MySQL中Data位置"><a href="#End-修改后的MySQL中Data位置" class="headerlink" title="End: 修改后的MySQL中Data位置"></a>End: 修改后的MySQL中Data位置</h3><pre><code class="bash">sudo mysql# 输出结果：Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 8Server version: 8.0.21-0ubuntu0.20.04.3 (Ubuntu)Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; select @@datadir;+-------------------+| @@datadir         |+-------------------+| /data/test/mysql/ |+-------------------+1 row in set (0.00 sec)</code></pre><hr><h2 id="（二）通过mysqlslap对MySQL进行压力测试"><a href="#（二）通过mysqlslap对MySQL进行压力测试" class="headerlink" title="（二）通过mysqlslap对MySQL进行压力测试"></a>（二）通过mysqlslap对MySQL进行压力测试</h2><h3 id="mysqlLslap"><a href="#mysqlLslap" class="headerlink" title="mysqlLslap"></a>mysqlLslap</h3><p>先来看看MySQL官方对mysqlslap工具的介绍：mysqlslap is a diagnostic program designed to emulate client load for a MySQL server and to report the timing of each stage. It works as if multiple clients are accessing the server.</p><p><code>简明概括</code>就是mysqlslap是MySQL5.1.4之后<code>自带</code>的benchmark<code>基准测试</code>工具，该工具可以模拟多个客户端同时<code>并发</code>的向服务器发出查询更新，给出了<code>性能测试</code>数据而且提供了<code>多种引擎的性能比较</code>。</p><p>该工具有诸多可选项可供选择以实现大部分场景下对MySQL<code>模拟</code>进行压力测试。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/UbuntuServer/MySQL/mysqlslap.png"><hr><h3 id="Tips-以下是常用的部分参数"><a href="#Tips-以下是常用的部分参数" class="headerlink" title="Tips: 以下是常用的部分参数"></a><code>Tips:</code> 以下是常用的部分参数</h3><pre><code class="bash"># 连接到的MySQL服务器的主机名(或IP地址)，默认为本地localhost--host=host_name# 连接MySQL服务时用的用户名(如：root)--user=root# 连接MySQL服务时用的密码(如：root)--password# 指定测试时生成的临时数据库名称(如：test)--create-schema=test# 工具自动生成测试用SQL语句--auto-generate-sql# 选择生成的SQL语句的格式(write, read, update, mixed)--auto-generate-sql-load-type=write# 执行的SQL总数量--number-of-queries=100000# 并发数，模拟多少个客户端同时执行query--concurrency=200# 引擎(如：myisam,innodb)--engines=innodb# 迭代的实验次数--iterations=100</code></pre><hr><h3 id="以下是我的机器上对MySQL进行一组压力测试的结果"><a href="#以下是我的机器上对MySQL进行一组压力测试的结果" class="headerlink" title="以下是我的机器上对MySQL进行一组压力测试的结果"></a>以下是我的机器上对MySQL进行一组压力测试的结果</h3><p><code>写入:</code></p><pre><code class="bash"># 写入脚本sudo mysqlslap --user=root --password=root --create-schema=test --auto-generate-sql --auto-generate-sql-load-type=write --concurrency=20 --number-of-queries=1000 --iterations=100# 结果mysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark    Average number of seconds to run all queries: 0.205 seconds    Minimum number of seconds to run all queries: 0.173 seconds    Maximum number of seconds to run all queries: 0.395 seconds    Number of clients running queries: 20    Average number of queries per client: 50</code></pre><hr><p><code>读取:</code></p><pre><code class="bash"># 读取脚本sudo mysqlslap --user=root --password=root --create-schema=test --auto-generate-sql --auto-generate-sql-load-type=read --concurrency=20 --number-of-queries=1000 --iterations=100# 结果mysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark    Average number of seconds to run all queries: 0.132 seconds    Minimum number of seconds to run all queries: 0.120 seconds    Maximum number of seconds to run all queries: 0.191 seconds    Number of clients running queries: 20    Average number of queries per client: 50</code></pre><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.digitalocean.com/community/tutorials/how-to-move-a-mysql-data-directory-to-a-new-location-on-ubuntu-16-04">Digital Ocean - How To Move a MySQL Data Directory to a New Location on Ubuntu</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/89427540?utm_source=wechat_session">知乎 • MySQL骨灰级性能优化</a></p></li><li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/mysqlslap.html">mysqlslap — A Load Emulation Client</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu Server </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu Server • Initialization</title>
      <link href="Ubuntu-Server-Initialization/"/>
      <url>Ubuntu-Server-Initialization/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇将介绍最近在Dell PowerEdge R420服务器上折腾<code>Ubuntu Server 20.04LTS</code>的一些笔记分享。</p></blockquote><blockquote><p>Ubuntu是一个以<code>桌面应用</code>为主的Linux操作系统，其名称来自非洲南部祖鲁语或豪萨语的“ubuntu”一词，意思是“人性”“我的存在是因为大家的存在”，是非洲传统的一种价值观。<br>Ubuntu基于<code>Debian发行版</code>和Gnome桌面环境，而从11.04版起，Ubuntu发行版放弃了Gnome桌面环境，改为Unity。从前人们认为Linux难以安装、难以使用，在Ubuntu出现后这些都成为了历史。<br>Ubuntu也拥有庞大的社区力量，用户可以方便地从社区获得帮助。自Ubuntu 18.04 LTS其，Ubuntu发行版又重新开始使用GNOME3桌面环境。</p></blockquote><hr><p>在对服务器进行配置与操作前，你需要准备👇：</p><ul><li><p>下载<a href="http://releases.ubuntu.com/20.04/">Ubuntu Server 20.04LTS</a>镜像并将其<a href="https://rufus.ie/zh_CN.html">刷入U盘</a></p></li><li><p><code>(建议)</code>在<code>有网络</code>连接的情况下安装Ubuntu Server 20.04LTS</p></li></ul><hr><h2 id="（一）-安装Ubuntu-Server"><a href="#（一）-安装Ubuntu-Server" class="headerlink" title="（一）. 安装Ubuntu Server"></a>（一）. 安装Ubuntu Server</h2><h3 id="Step1-选择语言"><a href="#Step1-选择语言" class="headerlink" title="Step1: 选择语言"></a>Step1: 选择语言</h3><p><code>Tips:</code> Ubuntu Server无简中，本章节将介绍英文版安装。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/UbuntuServer/install_1.png"><hr><h3 id="Step2-选择键盘布局"><a href="#Step2-选择键盘布局" class="headerlink" title="Step2: 选择键盘布局"></a>Step2: 选择键盘布局</h3><p><code>Tips:</code> 该处使用美式键盘布局即可，通用大部分的键盘布局。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/UbuntuServer/install_2.png"><hr><h3 id="Step3-网络设置"><a href="#Step3-网络设置" class="headerlink" title="Step3: 网络设置"></a>Step3: 网络设置</h3><p><code>Tips:</code> 建议在安装过程中联网进行安装，这样既能在后续的安装过程中同步升级软件包。如果选择离线安装，后续官方虽然说可以在安装后进行配置，但在多次配置ip却仍旧无法联网，不知道是20.04版本的小Bug还是其他原因。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/UbuntuServer/install_3.png"><hr><h3 id="Step4-代理设置"><a href="#Step4-代理设置" class="headerlink" title="Step4: 代理设置"></a>Step4: 代理设置</h3><p><code>Tips:</code> 有的话可以填写，本章节暂不进行配置。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/UbuntuServer/install_4.png"><hr><h3 id="Step5-镜像源配置"><a href="#Step5-镜像源配置" class="headerlink" title="Step5: 镜像源配置"></a>Step5: 镜像源配置</h3><p><code>Tips:</code> Ubuntu Server软件下载镜像源可以在安装时进行修改，本篇建议修改为<a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源软件镜像</a>：<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a></p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/UbuntuServer/install_5.png"><hr><h3 id="Step6-引导空间配置"><a href="#Step6-引导空间配置" class="headerlink" title="Step6: 引导空间配置"></a>Step6: 引导空间配置</h3><p><code>Tips:</code> 可根据需求对引导空间进行调整，本章节暂不进行配置。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/UbuntuServer/install_6.png"><hr><h3 id="Step7-分区配置"><a href="#Step7-分区配置" class="headerlink" title="Step7: 分区配置"></a>Step7: 分区配置</h3><p><code>Tips:</code> Linux对于分区较为敏感，类如：/usr /bin /home /efi等等分区都有及其重要的作用，使用时稍有不慎对系统分区进行错误操作将造成毁灭性的严重后果，此处暂不展开分析系统分区的规则与建议，有兴趣的读者可自行前往<a href="https://www.linux.org/">Linux官方网站</a>学习。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/UbuntuServer/install_7.png"><hr><h3 id="Step8-Ubuntu-Server账号配置"><a href="#Step8-Ubuntu-Server账号配置" class="headerlink" title="Step8: Ubuntu Server账号配置"></a>Step8: Ubuntu Server账号配置</h3><p><code>Tips:</code> 设置一个账号用以登录系统，此处要注意username的命名限制。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/UbuntuServer/install_9.png"><hr><h3 id="Step9-SSH设置"><a href="#Step9-SSH设置" class="headerlink" title="Step9: SSH设置"></a>Step9: SSH设置</h3><p><code>Tips:</code> Ubuntu Server默认不开放SSH，但配置SSH能使工程师远程连接服务器，本章勾选并下载OpenSSH Server客户端。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/UbuntuServer/install_10.png"><hr><h3 id="Step10-等待Ubuntu-Server安装结束"><a href="#Step10-等待Ubuntu-Server安装结束" class="headerlink" title="Step10: 等待Ubuntu Server安装结束"></a>Step10: 等待Ubuntu Server安装结束</h3><p><code>Tips:</code> 若用户在联网状态下安装Ubuntu Server时，安装过程中将会自动检测并下载对应软件包更新。系统安装后需要去除安装介质(U盘\移动硬盘\光驱安装)，并单击Enter键重启，即安装完毕。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/UbuntuServer/install_11.png"><hr><h3 id="End-登录系统"><a href="#End-登录系统" class="headerlink" title="End: 登录系统"></a>End: 登录系统</h3><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/UbuntuServer/install_end.png"><hr><h2 id="（二）-远程连接Ubuntu-Server"><a href="#（二）-远程连接Ubuntu-Server" class="headerlink" title="（二）. 远程连接Ubuntu Server"></a>（二）. 远程连接Ubuntu Server</h2><h3 id="Step1-安装net-tools用以查看ip"><a href="#Step1-安装net-tools用以查看ip" class="headerlink" title="Step1: 安装net-tools用以查看ip"></a>Step1: 安装net-tools用以查看ip</h3><pre><code class="bash">sudo apt updatesudo apt upgrade# 若前期安装过程中未联网或未启用ssh的话，需要先下载openssh-serversudo apt install openssh-server# 安装net-tools工具sudo apt install net-tools</code></pre><hr><h3 id="Step2-查看本机ip"><a href="#Step2-查看本机ip" class="headerlink" title="Step2: 查看本机ip"></a>Step2: 查看本机ip</h3><pre><code class="bash">sudo ifconfig</code></pre><hr><h3 id="Step3-修改远程访问权限"><a href="#Step3-修改远程访问权限" class="headerlink" title="Step3: 修改远程访问权限"></a>Step3: 修改远程访问权限</h3><pre><code class="bash"># 修改该文件中PermitRootLogin的值为yesvim /etc/ssh/sshd_config</code></pre><hr><h3 id="Step4-使用指令查看ip"><a href="#Step4-使用指令查看ip" class="headerlink" title="Step4: 使用指令查看ip"></a>Step4: 使用指令查看ip</h3><pre><code class="bash">sudo ifconfig# 查看ip地址ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.116.134  netmask 255.255.255.0  broadcast 192.168.116.255        inet6 fe80::20c:29ff:fecb:6b67  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:0c:29:cb:6b:67  txqueuelen 1000  (Ethernet)        RX packets 47090  bytes 68633562 (68.6 MB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 6040  bytes 421820 (421.8 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 190  bytes 16652 (16.6 KB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 190  bytes 16652 (16.6 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><hr><h3 id="Step5-使用远程链接工具链接"><a href="#Step5-使用远程链接工具链接" class="headerlink" title="Step5: 使用远程链接工具链接"></a>Step5: 使用远程链接工具链接</h3><p><code>Tips:</code> 本章节选用<code>XShell</code>进行远程连接。</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/UbuntuServer/ubuntu_ssh.png"><hr><h2 id="（三）-Server常用命令"><a href="#（三）-Server常用命令" class="headerlink" title="（三）. Server常用命令"></a>（三）. Server常用命令</h2><pre><code class="bash"># Scan local disksudo fdisk -l# Check disk informationsudo df -HT# Create test dirsudo mkdir xxx# Eg: that you can create a test foldersudo mkdir /test# Mount a HDD/SDD to your systemsudo mount xxxxxx xxxxxx# Eg: you can mount /dev/nvme0n1 with you localDir with /datasudo mount /dev/nvme0n1 /data# Change filesystem to xfssudo mkfs.xfs xxxxxx# Eg: you can make the default change to the disk into xfs filesystem or the other filesystem you want to change(eg: ext4, ext3, ntfs)sudo mkfs.xfs /dev/nvme0n1# If you want to set the block size to another big one, try to add &#39;-b size=8k&#39;sudo mkfs.xfs -b size=xx xxxxxx# Eg: you can change the /dev/nvme0n1 into xfs with it&#39;s blocksize=8k# NOTICE: disk blocksize can not bigger than system default page sizesudo mkfs.xfs -b size=8k /dev/nvme0n1# Get default system pagesizesudo getconf PAGESIZE# Reboot the computer immediatelysudo reboot -h now# Shut down the computer immediatelysudo shutdown -h now</code></pre><hr><h2 id="（四）-通过”dd”关键字对硬盘进行读写测试"><a href="#（四）-通过”dd”关键字对硬盘进行读写测试" class="headerlink" title="（四）. 通过”dd”关键字对硬盘进行读写测试"></a>（四）. 通过”dd”关键字对硬盘进行读写测试</h2><pre><code class="bash"># R/W Test# The server&#39;s write file size is usually 4k and 8K, here the disk will be written test from 4K, 8K, 64K, 1M order, and after the memory cache is cleared, the 1M file on the disk will be read and deleted.# Create Tiny Size Test File &amp;&amp;  Start Write Speed Testsudo dd if=/dev/zero of=./largefile bs=4k count=1024# Create Small Size Test File &amp;&amp;  Start Write Speed Testsudo dd if=/dev/zero of=./largefile bs=8k count=1024# Create Middle Size Test File &amp;&amp;  Start Write Speed Testsudo dd if=/dev/zero of=./largefile bs=64k count=1024# Create Large Size Test File &amp;&amp;  Start Write Speed Testsudo dd if=/dev/zero of=./largefile bs=1M count=1024# Remove RAM Cachesudo sh -c &quot;sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches&quot;# Check Read Speedsudo dd if=./largefile of=./null bs=8k</code></pre><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://ubuntu.com/download/server">Download Ubuntu Server</a></p></li><li><p><a href="https://ubuntu.com/tutorials/install-ubuntu-server#1-overview">Install Ubuntu Server</a></p></li><li><p><a href="https://www.tecmint.com/install-ubuntu-20-04-server/">How to Install Ubuntu 20.04 Server</a></p></li><li><p><a href="https://linuxize.com/post/how-to-enable-ssh-on-ubuntu-20-04/#:~:text=%20Perform%20the%20following%20steps%20as%20root%20or,verify%20that%20SSH%20is%20running%20by...%20More%20">How to Enable SSH on Ubuntu 20.04</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序 • 自动化测试</title>
      <link href="MiniProgram-AutoTest/"/>
      <url>MiniProgram-AutoTest/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇将介绍最近在<code>小程序开发</code>项目上所遇到的有关<code>自动化测试</code>的一些笔记分享。</p></blockquote><blockquote><p>微信小程序，小程序的一种，英文名Wechat Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。<br>全面开放申请后，主体类型为企业、政府、媒体、其他组织或个人的开发者，均可申请注册小程序。微信小程序、微信订阅号、微信服务号、微信企业号是并行的体系。<br>微信小程序是一种不用下载就能使用的应用，也是一项创新，经过将近两年的发展，已经构造了新的微信小程序开发环境和开发者生态。微信小程序也是这么多年来中国IT行业里一个真正能够影响到普通程序员的创新成果，已经有超过150万的开发者加入到了微信小程序的开发，与我们一起共同发力推动微信小程序的发展，微信小程序应用数量超过了一百万，覆盖200多个细分的行业，日活用户达到两个亿，微信小程序还在许多城市实现了支持地铁、公交服务。微信小程序发展带来更多的就业机会，2017年小程序带动就业104万人，社会效应不断提升。</p></blockquote><hr><p>在进行小程序自动化测试前，你需要准备👇：</p><ul><li><a href="https://nodejs.org/en/">Node.js</a> - v8.0及以上</li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">微信开发者工具</a> - v1.02.1907232及以上</li><li><a href="https://github.com/wechat-miniprogram/miniprogram-demo">微信官方小程序Demo</a> - 待测试的项目Demo</li></ul><hr><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><h3 id="Step1-项目初始化"><a href="#Step1-项目初始化" class="headerlink" title="Step1: 项目初始化"></a>Step1: 项目初始化</h3><pre><code class="bash">cd miniprogram-demonpm icd miniprogramnpm i</code></pre><h3 id="Step2-引入自动化测试插件与框架"><a href="#Step2-引入自动化测试插件与框架" class="headerlink" title="Step2: 引入自动化测试插件与框架"></a>Step2: 引入自动化测试插件与框架</h3><p>完成上述步骤后，安装miniprogram-automator，这是一款由<code>微信官方</code>推出的小程序自动化测试框架。</p><pre><code class="bash">npm i miniprogram-automator --save-dev</code></pre><p>引入jset测试框架</p><pre><code class="bash">npm i jest</code></pre><p><strong>PS: 在下载完jest后，还需要前往package.json配置jest。</strong></p><pre><code class="JavaScript">&quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;jest&quot;  &#125;</code></pre><p>添加完上述代码后，在进行测试时系统会<code>自动找到</code>包括.test.js结尾的测试文件并运行。</p><h3 id="Step3-开启自动化测试端口"><a href="#Step3-开启自动化测试端口" class="headerlink" title="Step3: 开启自动化测试端口"></a>Step3: 开启自动化测试端口</h3><p><strong>PS: (该步骤可省略，当第5步出现问题时，可先开启端口再执行第5步命令)</strong></p><ol><li><p>打开微信开发者工具，前往设置 -&gt; 通用设置 -&gt; 安全 -&gt; 开启服务端口</p></li><li><p>前往你的微信开发者工具安装目录，例：D:\微信开发者工具，开启自动化测试端口</p></li></ol><pre><code class="bash">.\cli.bat --auto 你的项目地址 --auto-port 9420</code></pre><p>当出现以下信息时，表示端口启用成功，并会同时开启/重启微信开发者工具。</p><pre><code class="bash">PS D:\微信web开发者工具&gt; .\cli.bat --auto C:\Users\P7XXTM1-G\Desktop\miniprogram-demo\miniprogram --auto-port 9420√ IDE server has started, listening on http://127.0.0.1:33553[warn] DEPRECATED please upgrade to the following v2 command instead ( doc: https://developers.weixin.qq.com/miniprogram/dev/devtools/cli.html ) cli auto --project C:\Users\P7XXTM1-G\Desktop\miniprogram-demo\miniprogram --auto-port 9420√ Open project with automation enabled success C:\Users\P7XXTM1-G\Desktop\miniprogram-demo\miniprogram</code></pre><hr><h3 id="Step4-编写测试脚本"><a href="#Step4-编写测试脚本" class="headerlink" title="Step4: 编写测试脚本"></a>Step4: 编写测试脚本</h3><p>开启完测试端口后，新建一个miniTest文件夹用于放置测试文件，创建index.test.js文件，开始编写测试脚本。</p><p>此处使用官方的<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/auto/demo.html">测试脚本案例👇</a></p><pre><code class="JavaScript">const automator = require(&#39;miniprogram-automator&#39;)describe(&#39;index&#39;, () =&gt; &#123;  let miniProgram  let page  beforeAll(async () =&gt; &#123;    miniProgram = await automator.launch(&#123;      cliPath:&#39;D://微信web开发者工具//cli.bat&#39;,// cli.bat文件一般在微信开发者工具目录下，MacOS下一般无需配置cliPath      projectPath: &#39;./&#39; // 默认当前项目地址即可    &#125;)    page = await miniProgram.reLaunch(&#39;/page/component/index&#39;) // 测试页面    await page.waitFor(500)  &#125;, 30000)  // 测试脚本  it(&#39;desc&#39;, async () =&gt; &#123;    const desc = await page.$(&#39;.index-desc&#39;)    expect(desc.tagName).toBe(&#39;view&#39;)    expect(await desc.text()).toContain(&#39;以下将展示小程序官方组件能力&#39;)  &#125;)  afterAll(async () =&gt; &#123;    await miniProgram.close()  &#125;)&#125;)</code></pre><h3 id="Step5-开始自动化测试"><a href="#Step5-开始自动化测试" class="headerlink" title="Step5: 开始自动化测试"></a>Step5: 开始自动化测试</h3><p>编写完测试脚本后，在终端输入npm run test，即可进行自动化测试，期间将会<code>打开/重启</code>微信开发者工具。</p><pre><code class="bash">PS C:\Users\P7XXTM1-G\Desktop\miniprogram-demo\miniprogram&gt; npm run test&gt; miniprogram@1.0.0 test C:\Users\P7XXTM1-G\Desktop\miniprogram-demo\miniprogram&gt; jest PASS  miniTest/index.test.js (21.827 s)  index    √ desc (12 ms)Test Suites: 1 passed, 1 totalTests:       1 passed, 1 totalSnapshots:   0 totalTime:        22.683 s, estimated 27 sRan all test suites.</code></pre><p>当出现上述信息时，表示自动化测试已通过。</p><hr><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/auto/automator.html">Automator</a>模块提供了<code>启动及连接开发者工具</code>的方法。</p></li><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/auto/miniprogram.html">MiniProgram</a>模块提供了<code>控制小程序</code>的方法。</p></li><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/auto/page.html">Page</a>模块提供了<code>控制小程序页面</code>的方法。</p></li><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/auto/element.html">Element</a>模块提供了<code>控制小程序页面元素</code>的方法。</p></li></ul><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/auto/">微信小程序官方自动化测试开发文档</a></p></li><li><p><a href="https://blog.csdn.net/weixin_43827779/article/details/106164261">小程序自动化测试快速开始</a></p></li><li><p><a href="https://blog.csdn.net/weixin_43827779/article/details/106180757">小程序自动化测试+jest</a></p></li><li><p><a href="https://blog.csdn.net/qq_40816649/article/details/102463350">miniprogram-automator微信小程序自动化工具</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毛中特概论</title>
      <link href="School-Political/"/>
      <url>School-Political/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>本篇整理了我学习<code>毛中特概论</code>时的一些笔记。</p></blockquote><hr><h2 id="一-毛泽东思想及其历史地位"><a href="#一-毛泽东思想及其历史地位" class="headerlink" title="(一) 毛泽东思想及其历史地位"></a>(一) 毛泽东思想及其历史地位</h2><h3 id="1-辨析题-坚持群众路线，就要坚持人民是历史发展的根本力量"><a href="#1-辨析题-坚持群众路线，就要坚持人民是历史发展的根本力量" class="headerlink" title="1.(辨析题) 坚持群众路线，就要坚持人民是历史发展的根本力量"></a><strong>1.(辨析题) 坚持群众路线，就要坚持人民是历史发展的根本力量</strong></h3><p><code>关键点</code>：人民群众是历史的主体，是历史的创造者。</p><p>答案：</p><p>正确。群众路线的本质是<code>人民群众是历史的创造者</code>，坚持群众路线就要坚持<code>人民是历史发展的根本力量</code>。</p><p>(1)<code>尊重</code>人民首创精神；<code>尊重</code>人民意愿、经验、权利；<code>正确行使</code>人民给予的权利，<code>自觉接受</code>人民监督。</p><p>(2)坚持<code>全心全意为人民服务的宗旨</code>。在任何时候都把群众利益放在首位。</p><p>(3)保持<code>党同人民群众之间的血肉联系</code>，把群众观点、群众路线深深植根与全党同志思想。落实到每个党员行动上。</p><h3 id="2-简答题-如何科学认识毛泽思想的历史地位"><a href="#2-简答题-如何科学认识毛泽思想的历史地位" class="headerlink" title="2.(简答题) 如何科学认识毛泽思想的历史地位"></a><strong>2.(简答题) 如何科学认识毛泽思想的历史地位</strong></h3><p><code>关键点</code>：马克思主义中国化第一次历史性的飞跃；为中特奠定理论基础；精神财富</p><p>答案：</p><p>(1)是马克思主义中国化<code>第一次历史性的飞跃</code>，为中国特色社会主体理论体系的形成奠定理论基础。</p><p>(2)是中国革命与建设的<code>科学指南</code>，是被实践证明了的关于中国革命与建设的<code>正确理论原则</code>和<code>经验总结</code>。</p><p>(3)是中国共产党和中国人民宝贵的<code>精神财富</code>。</p><p>(4)要将毛泽东晚年所犯的错误同经过长期历史检验而形成为科学理论的毛泽东思想<code>区别</code>开来。</p><hr><h2 id="二-毛泽东思想主要内容和活的灵魂"><a href="#二-毛泽东思想主要内容和活的灵魂" class="headerlink" title="(二) 毛泽东思想主要内容和活的灵魂"></a>(二) 毛泽东思想主要内容和活的灵魂</h2><h3 id="1-辨析题-新民主主义革命的经济纲领是“一化三改”"><a href="#1-辨析题-新民主主义革命的经济纲领是“一化三改”" class="headerlink" title="1.(辨析题)新民主主义革命的经济纲领是“一化三改”"></a><strong>1.(辨析题)新民主主义革命的经济纲领是“一化三改”</strong></h3><p><code>关键点</code>：同过渡时期总路线的主要内容区别开来</p><p>答案：</p><p>错误。“一化三改”是党在过渡时期总路线主要内容的概括。</p><p>新民主主义革命的经济纲领是(<code>两个保护、一个没收</code>)：</p><p>(1)<code>没收</code>封建地主阶级的土地归农民所有，这是新民主主义革命的<code>主要内容</code>。</p><p>(2)<code>没收</code>官僚资本主义的垄断资本归新民主主义的国家所有，这是新民主主义革命的<code>题中之要</code>。</p><p>(3)<code>保护</code>民族工商业，这是新民主主义革命经济纲领中极具<code>特色</code>的一项<code>内容</code>。</p><h3 id="2-简答题-新民主主义革命三大法宝的关系"><a href="#2-简答题-新民主主义革命三大法宝的关系" class="headerlink" title="2.(简答题)新民主主义革命三大法宝的关系"></a><strong>2.(简答题)新民主主义革命三大法宝的关系</strong></h3><p><code>作答思路</code>：提出时间；三大法宝是什么；三者关系</p><p>答案：</p><p>抗战时期，毛泽东系统论述了统一战线、武装斗争、党的建设这三大法宝之间的关系。</p><p>(1)<code>统一战争、武装斗争</code>是中国革命的两个<code>基本特点</code>，是战胜敌人的两个<code>基本武器</code>。</p><p>(2)<code>统一战线</code>是实行武装斗争的<code>统一战线</code>。</p><p>(3)<code>武装斗争</code>是统一战线的<code>中心支柱</code>。</p><p>(4)<code>党的组织</code>是掌握统一战线和武装斗争这两个武器以实行对敌冲锋陷阵的<code>英勇战士</code>。</p><h3 id="3-简答题-新民主主义革命理论的意义"><a href="#3-简答题-新民主主义革命理论的意义" class="headerlink" title="3.(简答题)新民主主义革命理论的意义"></a><strong>3.(简答题)新民主主义革命理论的意义</strong></h3><p>答案：</p><p>新民主主义革命理论是独创性的理论。</p><p>(1)<code>揭示</code>了近代中国革命的<code>发展规律</code>，<code>开辟</code>了马克思主义中国化的<code>发展道路</code>。</p><p>(2)指导完成新民主主义革命，<code>建立了中华人民共和国</code>，中国人民从此站起来了。</p><p>(3)<code>鼓舞和推动</code>了<code>世界人民</code>反抗帝国主义、殖民主义的斗争，<code>增强了他们</code>反对帝国主义斗争<code>的信心</code>。</p><h3 id="4-简答题-简述新民主主义基本纲领"><a href="#4-简答题-简述新民主主义基本纲领" class="headerlink" title="4.(简答题)简述新民主主义基本纲领"></a><strong>4.(简答题)简述新民主主义基本纲领</strong></h3><p><code>作答思路</code>：基本纲领由什么组成；内容是什么；</p><p>新民主主义的基本纲领有：政治纲领、经济纲领、文化纲领</p><p>(1)<code>政治纲领</code>：推翻帝国主义和封建主义的统治，建立一个由无产阶级领导，以工农联盟为基础，各革命阶级联合专政的新民主主义共和国。</p><p>(2)<code>经济纲领</code>：<code>没收</code>封建地主阶级的土地归农民所有；<code>没收</code>官僚资本阶级的垄断资本归新民主主义的国家所有；<code>保护</code>民族工商业。</p><p>(3)<code>文化纲领</code>：无产阶级领导的人民大众的<code>反帝反封建</code>的文化，即<code>民主的科学的大众的</code>文化。</p><h3 id="5-论述题-论述新民主主义革命时期统一战线的构成和实践经验"><a href="#5-论述题-论述新民主主义革命时期统一战线的构成和实践经验" class="headerlink" title="5.(论述题)论述新民主主义革命时期统一战线的构成和实践经验"></a><strong>5.(论述题)论述新民主主义革命时期统一战线的构成和实践经验</strong></h3><p>答案：</p><p>统一战线的<code>构成</code>：</p><p>(1)工人阶级同农民阶级、广大知识分子及其他劳动者的联盟，主要是<code>工农联盟</code>，这<code>是统一战争的基础</code>。</p><p>(2)工人阶级和非劳动人民的联盟，主要是<code>与民族资产阶级的联盟</code>。</p><p>实践<code>经验</code>：</p><p>(1)要<code>建立巩固的工农联盟</code>。</p><p>(2)<code>正确对待资产阶级</code>，尤其是民族资产阶级。</p><p>(3)采取<code>区别对待的方针</code>。</p><p>(4)坚持<code>独立自主原则</code>，保持党在思想上、政治上、组织上的独立性。</p><hr><h2 id="三-社会主义改造理论-•-四-社会主义建设道路初步探索的理论成果"><a href="#三-社会主义改造理论-•-四-社会主义建设道路初步探索的理论成果" class="headerlink" title="(三)社会主义改造理论 • (四)社会主义建设道路初步探索的理论成果"></a>(三)社会主义改造理论 • (四)社会主义建设道路初步探索的理论成果</h2><h3 id="1-简答题-党在过渡时期总路线"><a href="#1-简答题-党在过渡时期总路线" class="headerlink" title="1.(简答题)党在过渡时期总路线"></a><strong>1.(简答题)党在过渡时期总路线</strong></h3><p><code>作答思路</code>：总路线是什么；内容有什么</p><p>答案：</p><p>党在过渡时期总路线的<code>完整表述</code>是：</p><p>(1)<code>这是</code>从中华人民共和国成立的到社会主义改造基本完成的<code>一个过渡时期</code>。</p><p>(2)党在这个时期的<code>总路线和总任务</code>是：要在一个相当长的时期内，逐步<code>实现</code>国家的<code>社会主义工业化</code>，逐步<code>实现</code>国家对<code>农业、手工业、资本主义工商业的社会主义改造</code>。</p><p>党在过渡时期的<code>主要内容是“一化三改”</code>，其中：</p><p>(1)“一化”指的是<code>社会主义工业化</code>。</p><p>(2)“三改”指的是对<code>农业、手工业、资本主义工商业的社会主义改造</code>。</p><p>这是一条社会主义<code>建设与改造同时并举</code>的路线。</p><h3 id="2-简答题-我国社会主义改造的历史经验"><a href="#2-简答题-我国社会主义改造的历史经验" class="headerlink" title="2.(简答题)我国社会主义改造的历史经验"></a><strong>2.(简答题)我国社会主义改造的历史经验</strong></h3><p>答案：</p><p>(1)坚持社会主义<code>建设与改造同时并举</code>。</p><p>(2)采取<code>积极引导、稳步前进</code>的方针。</p><p>(3)用<code>和平方式</code>进行改造</p><h3 id="3-简答题-中国确立社会主义基本制度的重大意义"><a href="#3-简答题-中国确立社会主义基本制度的重大意义" class="headerlink" title="3.(简答题)中国确立社会主义基本制度的重大意义"></a><strong>3.(简答题)中国确立社会主义基本制度的重大意义</strong></h3><p>答案：</p><p>(1)社会主义基本制度的确立<code>是中国历史上最深刻最伟大的变革</code>。</p><p>(2)极大地<code>促进了社会生产力的发展</code>。</p><p>(3)广大劳动人民成为国家的主人，这<code>是中国几千年来阶级关系最根本的变革</code>。</p><p>(4)<code>增强</code>了社会主义力量，对<code>维护世界和平积极影响</code>。</p><p>(5)<code>丰富和发展</code>了科学社会主义理论。</p><h3 id="4-如何调动一切积极因素为社会主义事业服务"><a href="#4-如何调动一切积极因素为社会主义事业服务" class="headerlink" title="4.如何调动一切积极因素为社会主义事业服务"></a><strong>4.如何调动一切积极因素为社会主义事业服务</strong></h3><p><code>作答思路</code>：何时提出；怎么做</p><p>答案：</p><p>《论十大关系》确定了一个基本方针，即调动一切积极因素为社会主义事业服务。</p><p>(1)必须<code>坚持中国共产党的领导</code>。</p><p>(2)必须<code>发展社会主义民主政治</code>。</p><p>(3)<code>科学认识社会主义发展阶段和社会主义建设的规律</code>。毛泽东指出，社会主义发展阶段可分为两个阶段，第一阶段是不发达的社会主义，第二阶段是比较发达的社会主义。</p><h3 id="5-简答题-社会主义道路初步探索的意义"><a href="#5-简答题-社会主义道路初步探索的意义" class="headerlink" title="5.(简答题)社会主义道路初步探索的意义"></a><strong>5.(简答题)社会主义道路初步探索的意义</strong></h3><p>答案：</p><p>(1)<code>巩固和发展</code>了我国的社会主义制度。</p><p>拓展：增强了广大人民群众走社会主义道路的信心，社会主义制度也在实践中得到发展。</p><p>(2)为开创中国特色社会主义提供了<code>宝贵经验</code>、<code>理论准备</code>、<code>物质基础</code>。</p><p>拓展：未开启新时期新道路奠定了重要的思想基础。改革开放以后我国赖以进行现代化建设的物质技术基础，建设等方面的骨干力量和他们的工作经验，大部分是这一时期建设起来的。</p><p>(3)<code>丰富</code>了科学社会主义的理论和实践。</p><p>拓展：丰富了中国社会主义的理论与实践，也丰富了科学社会主义的理论与实践，为其他国家的社会主义建设提供了经验和借鉴。</p><hr><h2 id="五-邓小平理论"><a href="#五-邓小平理论" class="headerlink" title="(五) 邓小平理论"></a>(五) 邓小平理论</h2><h3 id="1-简答题-邓小平关于社会主义本质概括的意义"><a href="#1-简答题-邓小平关于社会主义本质概括的意义" class="headerlink" title="1.(简答题)邓小平关于社会主义本质概括的意义"></a><strong>1.(简答题)邓小平关于社会主义本质概括的意义</strong></h3><p>(1)既包括了社会主义的生产力问题，又包括了以社会主义关系为基础的社会关系问题，是一个有机的整体。(<code>生产力与生产关系</code>)</p><p>(2)为我们<code>坚持完善和发展公有制</code>指明了方向。</p><p>(3)<code>遵循</code>了科学社会主义的基本原则，<code>反映</code>了人民的利益和时代要求，<code>廓清</code>了不合乎时代进步和社会发展规律的模糊观念，<code>摆脱</code>了长期以来拘泥于具体形式而忽略社会主义本质的错误倾向，<code>深化</code>了对科学社会主义的认识。</p><h3 id="2-辨析题-改革是社会主义制度的自我完善和自我发展"><a href="#2-辨析题-改革是社会主义制度的自我完善和自我发展" class="headerlink" title="2.(辨析题)改革是社会主义制度的自我完善和自我发展"></a><strong>2.(辨析题)改革是社会主义制度的自我完善和自我发展</strong></h3><p><code>作答思路</code>：是什么；实质和目标</p><p>(1)改革作为一次新的革命，<code>不是也不允许</code>我们否定和抛弃我们建立起来的社会主义基本制度，他是社会主义的<code>自我完善和自我发展</code>。</p><p>(2)改革<code>不是</code>一个阶级推翻另一个阶级的原来意义上的革命，<code>也不是</code>经济体制细枝末节的修补，<code>而是</code>对体制的根本性变革。</p><p>(3)改革的实质和目标，是要从根本上<code>改变</code>束缚我国生产力发展的<code>经济体制</code>，<code>建立</code>充满生机活力的<code>社会主义新经济体制</code>，同时相应地<code>改革政治体制和其他方面的体制</code>，<code>实现中国社会主义现代</code>。</p><h3 id="3-简答题-邓小平“和平统一，一国两制”的基本内容"><a href="#3-简答题-邓小平“和平统一，一国两制”的基本内容" class="headerlink" title="3.(简答题)邓小平“和平统一，一国两制”的基本内容"></a><strong>3.(简答题)邓小平“和平统一，一国两制”的基本内容</strong></h3><p><code>作答思路</code>：以解决什么问题提出；内容是什么；地位如何</p><p>答案：</p><p>面对港澳台地区<code>尚未统一</code>的问题，邓小平提出<code>“只有实行‘一个国家，两种制度’”</code></p><p>基本内容：</p><p>(1)坚持<code>一个中国</code>，这是“和平统一，一国两制”的<code>核心</code>；</p><p>(2)<code>两制并存</code>，在祖国统一的前提下，<code>国家</code>的<code>主体</code>部分实行<code>社会主义制度</code>，同时在<code>台湾、香港、澳门</code>保持<code>原有社会制度和生活动方式</code>长期不变；</p><p>(3)<code>高度自治</code>，祖国完成统一后，港澳台作为特别行政区，享有不同于中国其他省、市、自治区的高度自治权；</p><p>(4)尽最大努力<code>争取和平统一</code>，但<code>不承诺放弃使用武力</code>；</p><p>(5)解决台湾问题，实现祖国完全统一，<code>寄希望于台湾人民</code>。</p><p><code>地位</code>：“一国两制”构想是对<code>马克思主义国家学说的创造性发展</code>。</p><h3 id="4-简答题-简述社会主义初级阶段理论"><a href="#4-简答题-简述社会主义初级阶段理论" class="headerlink" title="4.(简答题)简述社会主义初级阶段理论"></a><strong>4.(简答题)简述社会主义初级阶段理论</strong></h3><p><code>作答思路</code>：何时提出；是什么；理论的含义；理论的意义</p><p>答案：</p><p>何时提出：党的<code>十三大系统论述</code>了社会主义初级阶段理论。</p><p>是什么：社会主义初级阶段理论是指我国在<code>生产力水平落后</code>、<code>商品经济不发达</code>的条件下建设社会主义必然经历的<code>特定阶段</code>。</p><p>理论的含义：</p><p>(1)我国<code>已经进入</code>社会主义，必须<code>坚持而不能离开</code>社会主义；</p><p>(2)我国社会主义社会<code>还处于</code>不发达的阶段，必须<code>正视而不能超越</code>初级阶段。</p><p>理论的意义：社会主义初级阶段，揭示了当代中国的历史方位，是建设中国特色社会主义的总依据。</p><hr><h2 id="六-“三个代表”重要思想"><a href="#六-“三个代表”重要思想" class="headerlink" title="(六)“三个代表”重要思想"></a>(六)“三个代表”重要思想</h2><h3 id="1-简答题-中国共产党必须始终代表中国先进生产力的发展要求"><a href="#1-简答题-中国共产党必须始终代表中国先进生产力的发展要求" class="headerlink" title="1.(简答题)中国共产党必须始终代表中国先进生产力的发展要求"></a><strong>1.(简答题)中国共产党必须始终代表中国先进生产力的发展要求</strong></h3><p><code>作答思路</code>：是核心观点之一；怎么做</p><p>答案：</p><p>始终代表中国先进生产力的发展要求是“三个代表”重要思想的<code>核心观点之一</code>。始终代表中国先进生产力的发展要求，大力促进先进生产力的发展，是<code>党保持先进性的根本体现和根本要求</code>。</p><p>(1).广大<code>工人、农民和知识分子</code>始终是推动我国先进生产力发展和社会全面进步的<code>根本力量</code>。</p><p>(2).<code>科学技术是第一生产力</code>，是先进生产力的<code>集中体现和主要标志</code>。<code>科技进步是</code>发展先进生产力的<code>决定因素</code>，<code>科学的本质是创新</code>。</p><h3 id="2-简答题-中国共产党必须始终代表中国最广大人民的根本利益"><a href="#2-简答题-中国共产党必须始终代表中国最广大人民的根本利益" class="headerlink" title="2.(简答题)中国共产党必须始终代表中国最广大人民的根本利益"></a><strong>2.(简答题)中国共产党必须始终代表中国最广大人民的根本利益</strong></h3><p><code>作答思路</code>：是核心观点之一；怎么做</p><p>答案：</p><p>始终代表中国最广大人民的根本利益是“三个代表”重要思想的核心观点之一。</p><p>(1).<code>发展好最广大人民的根本利益</code>是我们全部工作的<code>出发点和落脚点</code>。</p><p>(2).为<code>实现人民群众的根本利益而奋斗</code>是我们<code>全部任务和责任</code>。</p><p>(3).党<code>始终坚持人民利益高于一切</code>。党除了最广大人民的利益，<code>没有自己的特殊利益</code>。</p><p>(4).努力使工人、农民、知识分子和其他群众<code>共同享受到经济社会发展的成果</code>。</p><p>(5).人民群众是历史的创造者，是历史的主体。</p><hr><h2 id="七-科学发展观"><a href="#七-科学发展观" class="headerlink" title="(七)科学发展观"></a>(七)科学发展观</h2><h3 id="1-辨析题-以人为本是科学发展观的第一要义"><a href="#1-辨析题-以人为本是科学发展观的第一要义" class="headerlink" title="1.(辨析题)以人为本是科学发展观的第一要义"></a><strong>1.(辨析题)以人为本是科学发展观的第一要义</strong></h3><p><code>作答思路</code>：是什么；地位；怎么做</p><p>答案：</p><p>错误，<code>发展</code>是科学发展观的<code>第一要义</code>，以人为本是科学发展观的核心立场。</p><p>地位：</p><p>(1)发展<code>是人类文明进步的基础</code>，<code>是马克思主义最基本的范畴之一</code>。</p><p>(2)<code>坚持发展是硬道理的本质要求就是坚持科学发展</code>。</p><p>怎么做：</p><p>(1)<code>坚持</code>科学发展，必须<code>加快转变经济发展方式</code>。</p><p>(2)<code>坚持</code>科学发展，必须<code>善于抓住和把握机遇</code>。</p><h3 id="2-简答题-全面协调可持续是科学发展观的基本要求"><a href="#2-简答题-全面协调可持续是科学发展观的基本要求" class="headerlink" title="2.(简答题)全面协调可持续是科学发展观的基本要求"></a><strong>2.(简答题)全面协调可持续是科学发展观的基本要求</strong></h3><p><code>作答思路</code>：是什么；怎么做</p><p>答案：</p><p>是什么：</p><p>(1).<code>“全面”</code>是指发展要有<code>全面性、整体性</code>。</p><p>(2).<code>“协调”</code>是指发展要有<code>协调性、均衡性</code>。</p><p>(3).<code>“可持续”</code>是指发展要有<code>持久性、连续性</code>。</p><p>怎么做：</p><p>(1).坚持<code>全面发展</code>，要<code>正确认识和把握经济、政治、文化、社会、生态文明建设是相互联系、相互促进的</code>。</p><p>(2).坚持<code>协调发展</code>，就是<code>保证中国特色社会主义各个领域协调推进</code>。</p><p>(3).坚持<code>可持续发展</code>，必须<code>走生产发展、生活富裕、生态良好的文明发展</code>。</p><p>(4).坚持<code>可持续发展</code>，还必须<code>建设生态文明</code>。</p><h3 id="3-简答题-简述科学发展观“构建社会主义和谐社会”的基本内容"><a href="#3-简答题-简述科学发展观“构建社会主义和谐社会”的基本内容" class="headerlink" title="3.(简答题)简述科学发展观“构建社会主义和谐社会”的基本内容"></a><strong>3.(简答题)简述科学发展观“构建社会主义和谐社会”的基本内容</strong></h3><p>答案：</p><p>社会和谐是中国特色社会主义的本质属性，深化了对社会主义本质的认识。</p><p>(1).社会主义和谐社会是经济、政治、文化、社会、生态文明建设协调发展的社会，是人与人、人与社会、人与自然整体和谐的社会。</p><p>(2).民主法制、公平正义、诚信友爱、充满活力、安定有序、人与自然和谐相处，是构建社会主义和谐社会的总要求。</p><p>(3).构建社会主义和谐社会，既要从“大社会”着眼，又要从“小社会”着手，以解决人民群众最关心最直接最现实的利益问题为重点。</p><h3 id="4-简答题-简述科学发展观最鲜明的精神实质"><a href="#4-简答题-简述科学发展观最鲜明的精神实质" class="headerlink" title="4.(简答题)简述科学发展观最鲜明的精神实质"></a><strong>4.(简答题)简述科学发展观最鲜明的精神实质</strong></h3><p>答案：</p><p>科学发展观最鲜明的精神实质是解放思想、实事求是、与时俱进、求真务实。</p><p>(1).这个精神实质充分体现了马克思主义、毛泽东思想、邓小平理论、“三个代表”重要思想和科学发展观的历史逻辑和内在联系。</p><p>(2).科学发胀初步形成了马克思主义关于社会主义发展的系统理论，进一步丰富和深化了马克思主义对发展问题的认识。</p>]]></content>
      
      
      <categories>
          
          <category> 毛概 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
            <tag> 毛中特概论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
