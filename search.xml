<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Welcome To PhoenixNest&#39;s Blog</title>
      <link href="/Welcome/"/>
      <url>/Welcome/</url>
      
        <content type="html"><![CDATA[<h2 id="Who-i-am"><a href="#Who-i-am" class="headerlink" title="Who i am"></a>Who i am</h2><p>Greetings, i am <code>Peter Chen [PhoenixNest]</code></p><ul><li>一个正在备考<code>专插本</code>的<code>应届</code>专科毕业生。</li><li>一个知晓C++、Java、MySQL、SQL Server等拼写的程序猿（发量犹在，Still a ROOKIE）。</li><li>一个知晓MVVM开发架构，使用过<code>Google JetPack</code>快速开发框架，正在<code>学习Kotlin</code>的Android程序猿。</li><li>一个做过<code>高德地图(Android)</code>开发，正在转入Web前端的新人。</li><li>一个热爱<code>星际争霸2</code>，喜欢暴雪游戏，梦想进入<code>暴雪公司(Blizzard)</code>的SCer。</li><li>一个喜欢游泳，曾做过蛙泳与自由泳教练的泳客。</li><li>一个接触计算机编程开发<code>2年</code>，喜欢学习新技术的<code>前端攻城狮</code>。</li><li>一个做过高达模型评测，开过电台的小Up主。</li><li>一个喜欢拍照，喜欢记录生活，不会讲粤语的<code>广东潮汕人</code>。</li></ul><hr><h2 id="The-Original"><a href="#The-Original" class="headerlink" title="The Original"></a>The Original</h2><p>在接触计算机编程的2年，踩了不少坑，从一开始最经典的因为大小写导致程序出现Bug，再到现如今能独立开发Android移动端应用，<br>可以说很大方面来自于自己对技术的热爱与追求。有人说编程是枯燥的，但其实也充满了乐趣，你能亲眼看着你的项目如同孩子般，经历<br>不同的成长阶段，从一开始的<code>&quot;Hello World&quot;</code>，再到后来的能够完成用户诸多需求，成为程序界里的<code>&quot;搬砖工人&quot;</code>(🤣🤣🤣)。</p><p>用博客中书写自己在日常工作中的一些对于技术的见解与看法，记录自己生活的点滴感动。</p><p><code>以学生的角度看待世界，有书，哪里都是图书馆。</code></p><hr><h2 id="Donate-☕️"><a href="#Donate-☕️" class="headerlink" title="Donate ☕️"></a>Donate ☕️</h2><p>If you like my blog post, you can Donate to me in the following ways.</p><p>Please indicate the source when reprinting.</p><p>如果你喜欢我的博文，可以通过下面的方式支持我，你的支持是我最大的动力 😘</p><p>转载时请注明出处 ©️PhoenixNest</p><table><thead><tr><th align="center">Donate 😇</th><th align="center">Qr code</th></tr></thead><tbody><tr><td align="center">Wechat</td><td align="center"><img src="/img/wechat.png" alt="Wechat"></td></tr><tr><td align="center">Ali Pay</td><td align="center"><img src="/img/alipay.png" alt="Ali Pay"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 置顶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毛中特概论 • 模拟题整理</title>
      <link href="/Political-Notes/"/>
      <url>/Political-Notes/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>本篇整理了一些我在近期复习专插本考试与参加专插本政治公开课时所遇到的一些模拟练习题。</p><p>本文将<code>不定期更新</code> ~ ~ ~</p><hr><h2 id="一-毛泽东思想及其历史地位"><a href="#一-毛泽东思想及其历史地位" class="headerlink" title="(一) 毛泽东思想及其历史地位"></a>(一) 毛泽东思想及其历史地位</h2><h3 id="1-辨析题-坚持群众路线，就要坚持人民是历史发展的根本力量"><a href="#1-辨析题-坚持群众路线，就要坚持人民是历史发展的根本力量" class="headerlink" title="1.(辨析题) 坚持群众路线，就要坚持人民是历史发展的根本力量"></a><strong>1.(辨析题) 坚持群众路线，就要坚持人民是历史发展的根本力量</strong></h3><p><code>关键点</code>：人民群众是历史的主体，是历史的创造者。</p><p>答案：</p><p>正确。群众路线的本质是<code>人民群众是历史的创造者</code>，坚持群众路线就要坚持<code>人民是历史发展的根本力量</code>。</p><p>(1)<code>尊重</code>人民首创精神；<code>尊重</code>人民意愿、经验、权利；<code>正确行使</code>人民给予的权利，<code>自觉接受</code>人民监督。</p><p>(2)坚持<code>全心全意为人民服务的宗旨</code>。在任何时候都把群众利益放在首位。</p><p>(3)保持<code>党同人民群众之间的血肉联系</code>，把群众观点、群众路线深深植根与全党同志思想。落实到每个党员行动上。</p><h3 id="2-简答题-如何科学认识毛泽思想的历史地位"><a href="#2-简答题-如何科学认识毛泽思想的历史地位" class="headerlink" title="2.(简答题) 如何科学认识毛泽思想的历史地位"></a><strong>2.(简答题) 如何科学认识毛泽思想的历史地位</strong></h3><p><code>关键点</code>：马克思主义中国化第一次历史性的飞跃；为中特奠定理论基础；精神财富</p><p>答案：</p><p>(1)是马克思主义中国化<code>第一次历史性的飞跃</code>，为中国特色社会主体理论体系的形成奠定理论基础。</p><p>(2)是中国革命与建设的<code>科学指南</code>，是被实践证明了的关于中国革命与建设的<code>正确理论原则</code>和<code>经验总结</code>。</p><p>(3)是中国共产党和中国人民宝贵的<code>精神财富</code>。</p><p>(4)要将毛泽东晚年所犯的错误同经过长期历史检验而形成为科学理论的毛泽东思想<code>区别</code>开来。</p><hr><h2 id="二-毛泽东思想主要内容和活的灵魂"><a href="#二-毛泽东思想主要内容和活的灵魂" class="headerlink" title="(二) 毛泽东思想主要内容和活的灵魂"></a>(二) 毛泽东思想主要内容和活的灵魂</h2><h3 id="1-辨析题-新民主主义革命的经济纲领是“一化三改”"><a href="#1-辨析题-新民主主义革命的经济纲领是“一化三改”" class="headerlink" title="1.(辨析题)新民主主义革命的经济纲领是“一化三改”"></a><strong>1.(辨析题)新民主主义革命的经济纲领是“一化三改”</strong></h3><p><code>关键点</code>：同过渡时期总路线的主要内容区别开来</p><p>答案：</p><p>错误。“一化三改”是党在过渡时期总路线主要内容的概括。</p><p>新民主主义革命的经济纲领是(<code>两个保护、一个没收</code>)：</p><p>(1)<code>没收</code>封建地主阶级的土地归农民所有，这是新民主主义革命的<code>主要内容</code>。</p><p>(2)<code>没收</code>官僚资本主义的垄断资本归新民主主义的国家所有，这是新民主主义革命的<code>题中之要</code>。</p><p>(3)<code>保护</code>民族工商业，这是新民主主义革命经济纲领中极具<code>特色</code>的一项<code>内容</code>。</p><h3 id="2-简答题-新民主主义革命三大法宝的关系"><a href="#2-简答题-新民主主义革命三大法宝的关系" class="headerlink" title="2.(简答题)新民主主义革命三大法宝的关系"></a><strong>2.(简答题)新民主主义革命三大法宝的关系</strong></h3><p><code>作答思路</code>：提出时间；三大法宝是什么；三者关系</p><p>答案：</p><p>抗战时期，毛泽东系统论述了统一战线、武装斗争、党的建设这三大法宝之间的关系。</p><p>(1)<code>统一战争、武装斗争</code>是中国革命的两个<code>基本特点</code>，是战胜敌人的两个<code>基本武器</code>。</p><p>(2)<code>统一战线</code>是实行武装斗争的<code>统一战线</code>。</p><p>(3)<code>武装斗争</code>是统一战线的<code>中心支柱</code>。</p><p>(4)<code>党的组织</code>是掌握统一战线和武装斗争这两个武器以实行对敌冲锋陷阵的<code>英勇战士</code>。</p><h3 id="3-简答题-新民主主义革命理论的意义"><a href="#3-简答题-新民主主义革命理论的意义" class="headerlink" title="3.(简答题)新民主主义革命理论的意义"></a><strong>3.(简答题)新民主主义革命理论的意义</strong></h3><p>答案：</p><p>新民主主义革命理论是独创性的理论。</p><p>(1)<code>揭示</code>了近代中国革命的<code>发展规律</code>，<code>开辟</code>了马克思主义中国化的<code>发展道路</code>。</p><p>(2)指导完成新民主主义革命，<code>建立了中华人民共和国</code>，中国人民从此站起来了。</p><p>(3)<code>鼓舞和推动</code>了<code>世界人民</code>反抗帝国主义、殖民主义的斗争，<code>增强了他们</code>反对帝国主义斗争<code>的信心</code>。</p><h3 id="4-简答题-简述新民主主义基本纲领"><a href="#4-简答题-简述新民主主义基本纲领" class="headerlink" title="4.(简答题)简述新民主主义基本纲领"></a><strong>4.(简答题)简述新民主主义基本纲领</strong></h3><p><code>作答思路</code>：基本纲领由什么组成；内容是什么；</p><p>新民主主义的基本纲领有：政治纲领、经济纲领、文化纲领</p><p>(1)<code>政治纲领</code>：推翻帝国主义和封建主义的统治，建立一个由无产阶级领导，以工农联盟为基础，各革命阶级联合专政的新民主主义共和国。</p><p>(2)<code>经济纲领</code>：<code>没收</code>封建地主阶级的土地归农民所有；<code>没收</code>官僚资本阶级的垄断资本归新民主主义的国家所有；<code>保护</code>民族工商业。</p><p>(3)<code>文化纲领</code>：无产阶级领导的人民大众的<code>反帝反封建</code>的文化，即<code>民主的科学的大众的</code>文化。</p><h3 id="5-论述题-论述新民主主义革命时期统一战线的构成和实践经验"><a href="#5-论述题-论述新民主主义革命时期统一战线的构成和实践经验" class="headerlink" title="5.(论述题)论述新民主主义革命时期统一战线的构成和实践经验"></a><strong>5.(论述题)论述新民主主义革命时期统一战线的构成和实践经验</strong></h3><p>答案：</p><p>统一战线的<code>构成</code>：</p><p>(1)工人阶级同农民阶级、广大知识分子及其他劳动者的联盟，主要是<code>工农联盟</code>，这<code>是统一战争的基础</code>。</p><p>(2)工人阶级和非劳动人民的联盟，主要是<code>与民族资产阶级的联盟</code>。</p><p>实践<code>经验</code>：</p><p>(1)要<code>建立巩固的工农联盟</code>。</p><p>(2)<code>正确对待资产阶级</code>，尤其是民族资产阶级。</p><p>(3)采取<code>区别对待的方针</code>。</p><p>(4)坚持<code>独立自主原则</code>，保持党在思想上、政治上、组织上的独立性。</p><hr><h2 id="三-社会主义改造理论-•-四-社会主义建设道路初步探索的理论成果"><a href="#三-社会主义改造理论-•-四-社会主义建设道路初步探索的理论成果" class="headerlink" title="(三)社会主义改造理论 • (四)社会主义建设道路初步探索的理论成果"></a>(三)社会主义改造理论 • (四)社会主义建设道路初步探索的理论成果</h2><h3 id="1-简答题-党在过渡时期总路线"><a href="#1-简答题-党在过渡时期总路线" class="headerlink" title="1.(简答题)党在过渡时期总路线"></a><strong>1.(简答题)党在过渡时期总路线</strong></h3><p><code>作答思路</code>：总路线是什么；内容有什么</p><p>答案：</p><p>党在过渡时期总路线的<code>完整表述</code>是：</p><p>(1)<code>这是</code>从中华人民共和国成立的到社会主义改造基本完成的<code>一个过渡时期</code>。</p><p>(2)党在这个时期的<code>总路线和总任务</code>是：要在一个相当长的时期内，逐步<code>实现</code>国家的<code>社会主义工业化</code>，逐步<code>实现</code>国家对<code>农业、手工业、资本主义工商业的社会主义改造</code>。</p><p>党在过渡时期的<code>主要内容是“一化三改”</code>，其中：</p><p>(1)“一化”指的是<code>社会主义工业化</code>。</p><p>(2)“三改”指的是对<code>农业、手工业、资本主义工商业的社会主义改造</code>。</p><p>这是一条社会主义<code>建设与改造同时并举</code>的路线。</p><h3 id="2-简答题-我国社会主义改造的历史经验"><a href="#2-简答题-我国社会主义改造的历史经验" class="headerlink" title="2.(简答题)我国社会主义改造的历史经验"></a><strong>2.(简答题)我国社会主义改造的历史经验</strong></h3><p>答案：</p><p>(1)坚持社会主义<code>建设与改造同时并举</code>。</p><p>(2)采取<code>积极引导、稳步前进</code>的方针。</p><p>(3)用<code>和平方式</code>进行改造</p><h3 id="3-简答题-中国确立社会主义基本制度的重大意义"><a href="#3-简答题-中国确立社会主义基本制度的重大意义" class="headerlink" title="3.(简答题)中国确立社会主义基本制度的重大意义"></a><strong>3.(简答题)中国确立社会主义基本制度的重大意义</strong></h3><p>答案：</p><p>(1)社会主义基本制度的确立<code>是中国历史上最深刻最伟大的变革</code>。</p><p>(2)极大地<code>促进了社会生产力的发展</code>。</p><p>(3)广大劳动人民成为国家的主人，这<code>是中国几千年来阶级关系最根本的变革</code>。</p><p>(4)<code>增强</code>了社会主义力量，对<code>维护世界和平积极影响</code>。</p><p>(5)<code>丰富和发展</code>了科学社会主义理论。</p><h3 id="4-如何调动一切积极因素为社会主义事业服务"><a href="#4-如何调动一切积极因素为社会主义事业服务" class="headerlink" title="4.如何调动一切积极因素为社会主义事业服务"></a><strong>4.如何调动一切积极因素为社会主义事业服务</strong></h3><p><code>作答思路</code>：何时提出；怎么做</p><p>答案：</p><p>《论十大关系》确定了一个基本方针，即调动一切积极因素为社会主义事业服务。</p><p>(1)必须<code>坚持中国共产党的领导</code>。</p><p>(2)必须<code>发展社会主义民主政治</code>。</p><p>(3)<code>科学认识社会主义发展阶段和社会主义建设的规律</code>。毛泽东指出，社会主义发展阶段可分为两个阶段，第一阶段是不发达的社会主义，第二阶段是比较发达的社会主义。</p><h3 id="5-简答题-社会主义道路初步探索的意义"><a href="#5-简答题-社会主义道路初步探索的意义" class="headerlink" title="5.(简答题)社会主义道路初步探索的意义"></a><strong>5.(简答题)社会主义道路初步探索的意义</strong></h3><p>答案：</p><p>(1)巩固和发展了我国的社会主义制度。</p><p>拓展：增强了广大人民群众走社会主义道路的信心，社会主义制度也在实践中得到发展。</p><p>(2)为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础。</p><p>拓展：未开启新时期新道路奠定了重要的思想基础。改革开放以后我国赖以进行现代化建设的物质技术基础，建设等方面的骨干力量和他们的工作经验，大部分是这一时期建设起来的。</p><p>(3)丰富了科学社会主义的理论和实践。</p><p>拓展：丰富了中国社会主义的理论与实践，也丰富了科学社会主义的理论与实践，为其他国家的社会主义建设提供了经验和借鉴。</p><hr><h2 id="Donate-☕️"><a href="#Donate-☕️" class="headerlink" title="Donate ☕️"></a>Donate ☕️</h2><p>If you like my blog post, you can Donate to me in the following ways.</p><p>Please indicate the source when reprinting.</p><p>如果你喜欢我的博文，可以通过下面的方式支持我，你的支持是我最大的动力 😘</p><p>转载时请注明出处 ©️PhoenixNest</p><table><thead><tr><th align="center">Donate 😇</th><th align="center">Qr code</th></tr></thead><tbody><tr><td align="center">Wechat</td><td align="center"><img src="/img/wechat.png" alt="Wechat"></td></tr><tr><td align="center">Ali Pay</td><td align="center"><img src="/img/alipay.png" alt="Ali Pay"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 专插本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning Notes </tag>
            
            <tag> Exam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构学习笔记(3) • 线性表(2)</title>
      <link href="/DataStructure-List-2/"/>
      <url>/DataStructure-List-2/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Introduction"><a href="#The-Introduction" class="headerlink" title="The Introduction"></a>The Introduction</h2><p>本篇将介绍我在进行数据结构学习时，所学习的第二个章节：线性表其中的第二部分：线性表的链式表示与实现，相关源码已上传<a href="https://github.com/PhoenixNest/StudyCPlusPlus" target="_blank" rel="noopener">Github</a>托管。</p><p>=3= 偷懒ing…</p><hr><h2 id="Donate-☕️"><a href="#Donate-☕️" class="headerlink" title="Donate ☕️"></a>Donate ☕️</h2><p>If you like my blog post, you can Donate to me in the following ways.</p><p>Please indicate the source when reprinting.</p><p>如果你喜欢我的博文，可以通过下面的方式支持我，你的支持是我最大的动力 😘</p><p>转载时请注明出处 ©️PhoenixNest</p><table><thead><tr><th align="center">Donate 😇</th><th align="center">Qr code</th></tr></thead><tbody><tr><td align="center">Wechat</td><td align="center"><img src="/img/wechat.png" alt="Wechat"></td></tr><tr><td align="center">Ali Pay</td><td align="center"><img src="/img/alipay.png" alt="Ali Pay"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning Notes </tag>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构学习笔记(2) • 线性表(1)</title>
      <link href="/DataStructure-List-1/"/>
      <url>/DataStructure-List-1/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Introduction"><a href="#The-Introduction" class="headerlink" title="The Introduction"></a>The Introduction</h2><p>本篇将介绍我在进行数据结构学习时，所学习的第二个章节：线性表其中的第一部分：线性表的顺序表示与实现，相关源码已上传<a href="https://github.com/PhoenixNest/StudyCPlusPlus" target="_blank" rel="noopener">Github</a>托管。</p><p>This article will introduce the second chapter I learned during data structure learning: the first part of the linear table: the sequence table, the relevant source code has been uploaded <a href="https://github.com/PhoenixNest/StudyCPlusPlus" target="_blank" rel="noopener">Github</a> hosting.</p><hr><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>线性表(List)，作为<code>最简单</code>、<code>最基本</code>，也是<code>最常用</code>的一种<code>线性结构</code>。线性表是<code>n个</code>数据<code>元素的有限序列</code>。元素可以是<code>各种各样</code>的，但<code>必须有相同性质</code>，属于<code>同一种</code>数据对象。</p><p>The linear table (List), as the simplest, basic, is also a linear structure of most commonly used. A linear table is a finite sequence of n data elements. Elements can be various, but must have the same nature and belong to the same data object.</p><p>例，XX学校设有n个学院，可用<code>线性表表示</code>如下：</p><p>{ “数学学院” , “外国语学院” , “声乐学院” , “计算机学院” , … }</p><p>表中的元素<code>都是</code>文本类型的<code>字符型值</code>，<code>不允许</code>出现<code>非文本类型</code>的数据。</p><p>For example, XX school has n colleges, which can be expressed as a linear table as follows:</p><p>{“Mathematics College”, “Foreign Language College”, “Vocal Music College”, “Computer College”, …}</p><p>The elements in the table are all text-type character values, and non-text-type data is not allowed.</p><p>当需要使用线性表<code>存储较为复杂的数据</code>时，一个<code>元素</code>也<code>可有多个数据项构成</code>，这种元素在线性表中<code>通常被称为&quot;记录 (record)&quot;</code></p><p>例，XX学校计算机学院的<code>学生成绩表</code>可表示为：</p><p>When you need to use a linear table to store more complex data, an element can also be composed of multiple data items. Such elements in the linear table are usually called “record”</p><p>For example, the transcript of the students of the School of Computer Science of XX School can be expressed as:</p><table><thead><tr><th align="center">ID</th><th align="center">Name</th><th align="center">Data Structure</th><th align="center">Software Engineering</th><th align="center">Discrete Mathematics</th><th align="center">Computer Network</th><th align="center">…</th></tr></thead><tbody><tr><td align="center">001</td><td align="center">Mike</td><td align="center">95</td><td align="center">90</td><td align="center">85</td><td align="center">80</td><td align="center">…</td></tr><tr><td align="center">002</td><td align="center">Jack</td><td align="center">90</td><td align="center">85</td><td align="center">80</td><td align="center">75</td><td align="center">…</td></tr><tr><td align="center">003</td><td align="center">Alice</td><td align="center">85</td><td align="center">80</td><td align="center">75</td><td align="center">70</td><td align="center">…</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr></tbody></table><p>该线性表中的<code>每一个元素</code>都是<code>一个学生</code>的成绩，也可看成<code>一个记录</code>，由<code>n个</code>科目成绩的<code>数据项构成</code>。从表中可以看出，每个<code>元素</code>都<code>有相同的数据项</code>，而各个<code>数据项</code>都<code>有自己的数据类型</code>。</p><p>Every element in the linear table is the result of a student, and it can also be regarded as a record, with the results of n subjects such as student number, name, data structure, software engineering, discrete mathematics, computer network Data Item Composition. As can be seen from the table, each element has the same data item, and each data item has its own data type.</p><hr><h2 id="1-线性表的抽象数据类型-ADT-Of-List"><a href="#1-线性表的抽象数据类型-ADT-Of-List" class="headerlink" title="1. 线性表的抽象数据类型 ADT Of List"></a>1. 线性表的抽象数据类型 ADT Of List</h2><h3 id="1-1-线性表的抽象数据类型-ADT-of-List"><a href="#1-1-线性表的抽象数据类型-ADT-of-List" class="headerlink" title="1.1 线性表的抽象数据类型 (ADT of List)"></a><strong>1.1 线性表的<code>抽象数据类型</code> (ADT of List)</strong></h3><pre><code class="C++">template &lt;class T&gt;class List{public:    virtual void clear() = 0;                          //* 清空顺序表    virtual bool empty() const = 0;                    //* 判空，空为true，非空false    virtual int size() const = 0;                      //* 表长    virtual void insert(int position, const T &amp;value); //* 在position位置插入值为value的元素    virtual void remove(int position) = 0;             //* 删除第position的位置的元素    virtual int search(const T &amp;value);                //* 查找传入值value在顺序表中的位置    virtual T visit(int position) const = 0;           //* 查找position位置的元素的值    virtual void traverse() const = 0;                 //* 遍历当前顺序表    virtual void inverse() = 0;                        //* 逆置当前顺序表    virtual ~List(){};};</code></pre><h3 id="1-2-自定义的异常处理类-Customized-Exception-handling-class"><a href="#1-2-自定义的异常处理类-Customized-Exception-handling-class" class="headerlink" title="1.2 自定义的异常处理类 (Customized Exception handling class)"></a><strong>1.2 自定义的<code>异常处理类</code> (Customized Exception handling class)</strong></h3><pre><code class="C++">class outOfRange : public exception{public:    //* 检查范围有效性    const char *checkRange() const throw()    {        return &quot;OUT of RANGE&quot;;    }};class errorSize : public exception{public:    //* 检查长度有效性    const char *checkSize() const throw()    {        return &quot;ERROR size&quot;;    }};</code></pre><hr><h2 id="2-线性表的顺序表示和实现-Sequential-representation-and-implementation-of-List"><a href="#2-线性表的顺序表示和实现-Sequential-representation-and-implementation-of-List" class="headerlink" title="2. 线性表的顺序表示和实现 Sequential representation and implementation of List"></a>2. 线性表的顺序表示和实现 Sequential representation and implementation of List</h2><h3 id="2-1-线性表的顺序表示-Order-representation-of-List"><a href="#2-1-线性表的顺序表示-Order-representation-of-List" class="headerlink" title="2.1 线性表的顺序表示 (Order representation of List)"></a><strong>2.1 线性表的顺序表示 (Order representation of List)</strong></h3><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Data%20Structure/List/List_1.png"><p>线性表在计算机内部有多种表示方法，最简单最<code>常用</code>的<code>方法</code>即用<code>顺序表示</code>。即在内存中用<code>地址连续</code>的一块<code>有限</code>的<code>表空间</code>，<code>存储</code>线性表的<code>各种元素</code>，这种形式存储的线性表称为<code>顺序表</code>。</p><p>顺序表用<code>物理</code>上的<code>相邻</code>(即内存中的<code>地址</code>是<code>连续</code>的，如：同一批产品的生产序号)<code>实现</code>元素之间的<code>逻辑相邻</code>关系。</p><p>假定顺序表中的<code>每个元素占k个存储单元</code>(如：一个元素占8个存储单元)，若知道<code>第一个元素</code>的地址(如：1000，即基地址)为<code>Loc(a0)</code>，则<code>位序为i的元素的地址</code>为：</p><p><code>Loc(ai) = Loc(a0) + i * k (0 &lt;= i &lt;= n-1)</code></p><p>此时<code>查找位序为i的元素</code>的<code>时间复杂度为O(1)</code>，可得顺序表具有<code>按元素位序</code>，进行<code>随机存取</code>的特点。</p><pre><code class="C++">template &lt;class T&gt;class seqList : public List&lt;T&gt;{private:    T *data;       //* 动态数组    int length;    //* 当前顺序表表长    int maxSize;   //* 顺序表最大长度    void resize(); //* 表满时扩大表空间public:    seqList(int initSize = 10);   //* 构造函数    seqList(seqList &amp;list);       //* 拷贝构造    ~seqList() { delete[] data; } //* 析构函数    void clear() { length = 0; }               //* 置空    bool empty() const { return length == 0; } //* 判空    int size() const { return length; }        //* 返回表长    void traverse() const;                     //* 遍历当前表    void inverse();                            //* 逆置当前表    void insert(int position, const T &amp;value); //* 在position位置插入值为value的元素    void remove(int position);                 //* 删除位于position的元素，length - 1    int search(const T &amp;value) const;          //* 查找值为value的元素在表中的值    T visit(int position) const;               //* 访问position位置元素的值    bool Union(seqList&lt;T&gt; &amp;list);};</code></pre><hr><h3 id="2-2-线性表的运算-List-operation"><a href="#2-2-线性表的运算-List-operation" class="headerlink" title="2.2 线性表的运算 List operation"></a>2.2 线性表的运算 List operation</h3><ul><li><strong>构造函数 (Constructor)</strong></li></ul><pre><code class="C++">template &lt;class T&gt;seqList&lt;T&gt;::seqList(int initSize){    if (initSize &lt;= 0)        throw errorSize();    maxSize = initSize;    data = new T[maxSize];    length = 0;}</code></pre><ul><li><strong>拷贝构造函数(动态分配存储空间) (Copy constructor (dynamic allocation of storage space))</strong></li></ul><pre><code class="C++">template &lt;class T&gt;seqList&lt;T&gt;::seqList(seqList &amp;seqList){    maxSize = seqList.maxSize;    length = seqList.length;    data = new T[maxSize];    for (int i = 0; i &lt; length; ++i)        data[i] = seqList.data[i];}</code></pre><ul><li><strong><code>遍历</code>顺序表 (Traversal seqList)</strong></li></ul><p>依次输出顺序表的所有元素。</p><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><pre><code class="C++">template &lt;class T&gt;void seqList&lt;T&gt;::traverse() const{    if (empty())    {        cout &lt;&lt; &quot;Empty List&quot; &lt;&lt; endl;    }    else    {        cout &lt;&lt; &quot;current Element: &quot; &lt;&lt; endl;        for (int i = 0; i &lt; maxSize; i++)            cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    }}</code></pre><ul><li><strong><code>查找</code>运算 (Find operation)</strong></li></ul><p>在顺序表中查找值为value的元素的下标。</p><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><p>平均<code>期望值</code>：<code>(n+1)/2</code>，其中n为顺序表的元素个数。</p><pre><code class="C++">template &lt;class T&gt;int seqList&lt;T&gt;::search(const T &amp;value) const{    for (int i = 0; i &lt; length; i++)        if (value == data[i])            return i;    return -1;}</code></pre><ul><li><strong><code>插入</code>运算 (Insert operation)</strong></li></ul><p>在顺序表下标为position的位置插入值为value的元素。</p><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><p>平均移动元素次数<code>(期望值)</code>：<code>n/2</code>，其中n为顺序表的元素个数。</p><pre><code class="C++">template &lt;class T&gt;void seqList&lt;T&gt;::insert(int position, const T &amp;value){    if (position &lt; 0 || position &gt; length)        //* 判断是否越界        throw outOfRange();    if (length == maxSize)        //* 当表满时，扩大表容量        resize();    for (int j = length; j &gt; position; j--)        //* 向后移动在插入位置position之后的所有元素        //* 注意此处移动的第一个元素下标为表尾元素下标        data[j] = data[j - 1];    //* 在空出位置插入值为value的元素    data[position] = value;    //* 表长 +1    ++length;}</code></pre><ul><li><strong><code>删除</code>运算 (Delete operation)</strong></li></ul><p>删除在顺序表下标为position的元素。</p><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><p>平均移动元素次数<code>(期望值)</code>：<code>(n-1)/2</code>，其中n为顺序表的元素个数。</p><pre><code class="C++">template &lt;class T&gt;void seqList&lt;T&gt;::remove(int position){    if (position &lt; 0 || position &gt; length - 1)        //* 判断是否越界        throw outOfRange();    for (int j = position; j &lt; length - 1; j++)        //* 前移在删除位置position之后的所有元素        //* 注意此处移动的第一个元素下标为待删除元素的下标        data[j] = data[j + 1];    //* 表长 -1    --length;};</code></pre><ul><li><strong><code>逆置</code>顺序表 (Reverse seqList)</strong></li></ul><p>调整线性表的顺序，可用于倒序输出顺序表元素。</p><p>如：原顺序表为5，4，3，2，1，逆置后顺序表为1，2，3，4，5</p><p><code>时间</code>复杂度：<code>O(n)</code></p><p><code>空间</code>复杂度：<code>O(1)</code></p><p>平均移动元素次数<code>(期望值)</code>：<code>n/2</code>，其中n为顺序表的元素个数。</p><pre><code class="C++">template &lt;class T&gt;void seqList&lt;T&gt;::inverse(){    T temp;    for (int i = 0; i &lt; length / 2; i++) //* 控制交换次数    {        temp = data[i];        data[i] = data[length - i - 1];        data[length - i - 1] = temp;    }}</code></pre><ul><li><strong><code>扩大</code>表空间 (Expand seqList size)</strong></li></ul><p>算法思想：</p><p>由于数组空间在内存中<code>必须</code>是<code>连续</code>的，因此，<code>扩大</code>数组<code>空间</code>的操作需要：<code>(1)</code>重新申请一个更大规模的新数组，<code>(2)</code>将原有数组的内容复制到新数组中，<code>(3)</code>释放原有数组空间，<code>(4)</code>将新数组作为线性表的存储区。</p><p><code>时间</code>复杂度：<code>O(n)</code></p><pre><code class="C++">template &lt;class T&gt;void seqList&lt;T&gt;::resize(){    T *p = data;           //* 指针p指向原顺序表空间    maxSize *= 2;          //* 扩大2倍表空间    data = new T[maxSize]; //* 将旧的数据指向新的表空间    for (int i = 0; i &lt; length; ++i) //* 复制元素至扩大后的新表        data[i] = p[i];    delete[] p;}</code></pre><hr><h3 id="2-3-顺序表的特点-Characteristics-of-seqList"><a href="#2-3-顺序表的特点-Characteristics-of-seqList" class="headerlink" title="2.3 顺序表的特点 (Characteristics of seqList)"></a><strong>2.3 顺序表的<code>特点</code> (Characteristics of seqList)</strong></h3><p>顺序表示的线性表(即<code>顺序表</code>)，有以下特点：</p><ul><li>存储密度大</li></ul><p>可在计算机<code>存储容量范围内存储大量元素</code>。</p><ul><li>随机存储</li></ul><p>由于<code>逻辑顺序</code>与<code>物理顺序</code>的<code>一致性</code>，顺序表能按元素符号<code>(下标)</code>直接存取，具有<code>随机存储</code>的优点。</p><ul><li>插入删除操作开销大</li></ul><p>由于要<code>保持</code>逻辑顺序和物理顺序的<code>一致性</code>，顺序表在进行插入、删除操作时，需要<code>移动大量的元素</code>(在<code>插入</code>元素<code>时</code>需<code>移动</code>整个顺序表近乎 <code>n/2 个元素</code>，在<code>删除</code>元素<code>时</code>需移动整个线性表近乎 <code>(n-1)/2 个元素</code>)</p><ul><li>易造成空间浪费与溢出</li></ul><p>顺序表需要<code>提前分配</code>存储空间，但因预留空间的困难性，分配过程中极<code>易造成</code>存储<code>空间</code>的<code>浪费</code>，而当<code>分配空间过小</code>时，则有出现<code>溢出</code>的风险。</p><ul><li>扩容难</li></ul><p><code>改变</code>顺序表的<code>大小时</code>(如扩大表空间为原来的2倍)，需<code>要创建</code>一个<code>新</code>的<code>顺序表</code>，把<code>原表</code>中的数据<code>复制到新表</code>中，然后<code>释放旧表</code>空间。</p><ul><li>静态存储与操作</li></ul><p>顺序表适合<code>静态</code>(不经常进行插入删除操作)、经常<code>定位访问</code>的线性表。</p><p>The <code>seqList</code> has the following characteristics:</p><ul><li>Large storage density</li></ul><p>A large number of elements can be stored in the computer`s storage capacity.</p><ul><li>Random storage</li></ul><p>Due to the  consistency  between logical order and  physical order , the sequence table can be directly accessed according to the element symbol (subscript) , which has the advantage of random storage.</p><ul><li>Insert and delete operations are expensive</li></ul><p>Due to maintaining consistency  between the logical order and the physical order, the sequence table needs to move a large number of elements  when inserting and deleting operations (when inserting elements, the entire sequence table needs to be moved n / 2 elements,when deleting elements you need to move the entire linear table by almost ((n-1) / 2 elements)</p><ul><li>Easy to waste space and overflow</li></ul><p>The sequence table needs to allocate  storage space in advance, but due to the difficulty of reserving space, it is very easy to cause wasting of storage space during the allocation process, and when allocated space is too small , it appears Risk of overflow.</p><ul><li>Difficult to expand</li></ul><p>When changing the size of sequence table(such as expanding the table space by 2 times the original), you need to create a new sequence table and copy the data in the original table to the new table, Then free the old table` space.</p><ul><li>Static storage and operation</li></ul><p>The sequence table is suitable for a linear table that is static (insert and delete operations are not often performed) and frequently located access.</p><hr><h2 id="Donate-☕️"><a href="#Donate-☕️" class="headerlink" title="Donate ☕️"></a>Donate ☕️</h2><p>If you like my blog post, you can Donate to me in the following ways.</p><p>Please indicate the source when reprinting.</p><p>如果你喜欢我的博文，可以通过下面的方式支持我，你的支持是我最大的动力 😘</p><p>转载时请注明出处 ©️PhoenixNest</p><table><thead><tr><th align="center">Donate 😇</th><th align="center">Qr code</th></tr></thead><tbody><tr><td align="center">Wechat</td><td align="center"><img src="/img/wechat.png" alt="Wechat"></td></tr><tr><td align="center">Ali Pay</td><td align="center"><img src="/img/alipay.png" alt="Ali Pay"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning Notes </tag>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构学习笔记(1) • 基本概念和术语</title>
      <link href="/DataStructure-Basic/"/>
      <url>/DataStructure-Basic/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Introduction"><a href="#The-Introduction" class="headerlink" title="The Introduction"></a>The Introduction</h2><p>对实际问题进行<code>缜密解析</code>，并辅以<code>优雅的代码</code>进行编写。</p><p>Perform a “meticulous analysis” of the actual problem and supplement it with an “elegant code”.</p><hr><h2 id="Program-Data-Structure-Algorithm"><a href="#Program-Data-Structure-Algorithm" class="headerlink" title="Program = Data Structure + Algorithm"></a>Program = Data Structure + Algorithm</h2><p>“程序 = 数据结构 + 算法”，这句出自Nicklaus Wirth教授的经典名言，使其一举夺得计算机界的诺贝尔奖 - 图灵奖，该公式对于计算机科学的影响几乎等同于Albert Einstein最为著名的质能等价理论：”E = mc²”，通过这短短的一个公式，便展露出程序的本质。</p><p>“Program = data structure + algorithm” is a classic quote from Professor Nicklaus Wirth, which won the Nobel Prize-Turing Prize in the computer industry in one fell swoop. This formula has almost the same impact on computer science as Albert Einstein’s most famous. Mass-energy equivalence theory: “E = mc²”, through this short formula, the essence of the program is revealed.</p><hr><h2 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h2><p>“数据结构(Data Structure)”是计算机程序设计的<code>重要理论基础</code>，是计算机专业最为<code>核心</code>的一门专业课程，同是也是一门<code>考研课程</code>。本篇将介绍我在进行数据结构学习时，所学习的第一个章节：数据结构的基本概念和术语。</p><p>“Data Structure” is an important theoretical basis for computer programming. It is a professional course with the most core of computer majors, and it is also a postgraduate course. This article will introduce the first chapter I experienced when I was studying data structure: the basic concepts and terminology of data structure.</p><hr><h2 id="1-基本概念-Basic-Concept"><a href="#1-基本概念-Basic-Concept" class="headerlink" title="1. 基本概念 Basic Concept"></a>1. 基本概念 Basic Concept</h2><h3 id="1-1-数据-Data"><a href="#1-1-数据-Data" class="headerlink" title="1.1 数据 (Data)"></a><strong>1.1 数据 (Data)</strong></h3><p>数据是<code>信息的载体</code>，是<code>描述客观事物</code>的数字、字符，以及<code>所有能输入计算机中</code>的、<code>被计算机程序识别和处理的符号</code>的集合。包括<code>数值型数据</code>：整数、实数等，与<code>非数值型数据</code>：文字、图像、图形、声音等。</p><p>Data is a carrier of information, a collection of numbers and characters that describe objective things, and all symbols that can be entered into a computer and recognized and processed by computer programs. Including <code>numeric data</code>: integers, real numbers, etc., and <code>non-numeric data</code>: text, images, graphics, sounds, etc.</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Data%20Structure/Basic/Basic_1.png"><h3 id="1-2-数据元素-Data-Element"><a href="#1-2-数据元素-Data-Element" class="headerlink" title="1.2 数据元素 (Data Element)"></a><strong>1.2 数据元素 (Data Element)</strong></h3><p>数据元素是<code>数据中的一个&quot;个体&quot;</code>，是数据的<code>基本单位</code>。在有些情况下，数据元素也被称为<code>元素</code>、<code>结点</code>、<code>顶点</code>、<code>记录</code>等。数据元素<code>用于完整地描述一个对象</code>。如：一个学生记录、一张图片、图的一个顶点等。</p><p>The data element is an “individual” in the data, and it is the basic unit of the data. In some cases, data elements are also called <code>elements</code>, <code>nodes</code>, <code>vertices</code>, <code>records</code>, etc. The data element <code>used to completely describe an object</code>. Such as: a student record, a picture, a vertex of the picture, etc.</p><h3 id="1-3-数据项-Data-Item"><a href="#1-3-数据项-Data-Item" class="headerlink" title="1.3 数据项 (Data Item)"></a><strong>1.3 数据项 (Data Item)</strong></h3><p>数据项是<code>组成数据元素</code>的有特定意义的<code>不可分割的最小单位</code>。如构成一个数据元素的<code>字段</code>、<code>域</code>、<code>属性</code>等都可称之为数据项。数据元素<code>是数据项的集合</code>。</p><p>简而言之，如上述举例中若要<code>组成一个学生记录</code>，那么<code>一个学生</code>可能包含有<code>学号</code>、<code>姓名</code>、<code>性别</code>、<code>班级</code>等属性，这些学号、姓名就是<code>构成一个学生记录的数据项</code>。</p><p>Data items are <code>indivisible smallest units</code> that make up a data element. For example, <code>field</code>, <code>domain</code>, <code>attribute</code> that constitute a data element can be called data items. The data element <code>is a collection of data items</code>.</p><p>In short, if in the above example you want to <code>compose a student record</code>, then <code>a student</code> may contain attributes such as <code>student number</code>, <code>name</code>, <code>sex</code>, <code>class</code> etc. It is <code>a data item that constitutes a student record</code>.</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Data%20Structure/Basic/Basic_2.png"><h3 id="1-4-数据对象-Data-Object"><a href="#1-4-数据对象-Data-Object" class="headerlink" title="1.4 数据对象 (Data Object)"></a><strong>1.4 数据对象 (Data Object)</strong></h3><p>数据对象是具有<code>相同性质</code>的数据元素的<code>集合</code>，是<code>数据的一个子集</code>。</p><p>如：计算机专业的全体学生(其中<code>全体学生</code>为一个<code>集合</code>，<code>计算机专业</code>为每个学生个体的<code>相同性质</code>)。</p><p>A data object is a <code>collection</code> of data elements with <code>same nature</code>, which is a subset of <code>data</code>.</p><p>For example: all students of computer major (where <code>all students</code> is a <code>set</code>, and <code>computer major</code> is <code>same nature</code> of each individual student).</p><hr><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Data%20Structure/Basic/Basic_3.png"><h3 id="1-5-数据的逻辑结构-Logical-structure-of-data"><a href="#1-5-数据的逻辑结构-Logical-structure-of-data" class="headerlink" title="1.5 数据的逻辑结构 (Logical structure of data)"></a><strong>1.5 数据的逻辑结构 (Logical structure of data)</strong></h3><p>数据的<code>逻辑结构</code>讨论的是<code>元素之间的逻辑关系</code>，<code>与存储结构无关</code>，是<code>独立于计算机</code>的。常见的逻辑结构有：</p><p>The <code>logical structure</code> of the data discusses the <code>logical relationship between the elements</code>, <code>is not related to the storage structure</code>, and is <code>independent of the computer</code>. Common logical structures are:</p><ul><li><code>集合结构</code> Collection structure</li><li><code>线性结构</code> Linear structure – (1 : 1)</li><li><code>树结构(层次结构)</code> Tree structure (hierarchy) – (1 : n)</li><li><code>图结构</code> Graph structure – (n : m)</li></ul><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Data%20Structure/Basic/Basic_4.png"><h3 id="1-6-数据的存储结构-物理结构-Data-storage-structure-physical-structure"><a href="#1-6-数据的存储结构-物理结构-Data-storage-structure-physical-structure" class="headerlink" title="1.6 数据的存储结构(物理结构) (Data storage structure (physical structure))"></a><strong>1.6 数据的存储结构(物理结构) (Data storage structure (physical structure))</strong></h3><p>数据的存储结构(物理结构)研究的是数据及其逻辑关系<code>如何在计算机中存储与实现</code>。常见的存储结构有：</p><p>The storage structure (physical structure) of data is to study how data and its logical relationship <code>how to store and realize it in a computer</code>. Common storage structures are:</p><ul><li>顺序存储结构 (Sequential storage structure)</li></ul><p>借助元素在存储器中的<code>相对位置</code>表示数据元素之间的关系，通常用<code>数组</code>来实现。</p><p>Relying on the relative position of elements in the memory to represent the relationship between data elements, it is usually implemented with an array.</p><table><thead><tr><th align="center">数组下标(Array subscript)</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td align="center">数组元素(Array element)</td><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center">D</td></tr></tbody></table><ul><li>链式存储结构 (Chain storage structure)</li></ul><p>借助<code>表示数据元素存储地址的指针</code>显式地指出数据元素之间的逻辑关系。</p><p>Explicitly indicate the logical relationship between data elements with the help of <code>pointers representing the storage addresses of data elements</code>.</p><img src="https://cdn.jsdelivr.net/gh/PhoenixNest/ImageBed@master/Data%20Structure/Basic/Basic_5.png"><ul><li>散列(哈希)存储方式 (Hash (hash) storage method)</li></ul><p>是<code>专用于集合</code>的数据存储方式。<code>用一个哈希函数</code>将数据元素<code>按关键字</code>和<code>一个唯一的存储位置</code>关联起来。</p><p>It is a data storage method dedicated to collections. <code>Use a hash function to associate data elements</code> by keyword <code>with</code> a unique storage location`.</p><ul><li>索引存储方式 (Index storage)</li></ul><p>数据元素被<code>排成一个序列</code>：d1,d2,d3,…,dn，每个结点di在序列里都有<code>相应的位序i</code>(1 &lt;= i &lt;= n&gt;)，<code>位序</code>可以作为<code>结点的索引</code>存储在索引表中。检索时<code>利用结点的顺序号i来确定结点</code>的存储地址。(类似图书的<code>目录</code>。)</p><p>The data elements are <code>arranged into a sequence</code>: d1, d2, d3, …, dn, each node di has a corresponding bit sequence i <code>in the sequence (1 &lt;= i &lt;= n&gt;),</code> Sequence <code>can be stored in the index table as the</code> node index. When searching, <code>use the sequence number i of the node to determine the storage address of the node</code>. (Similar to the book’s catalogue.)</p><hr><h2 id="2-算法与算法分析-Algorithms-and-algorithm-analysis"><a href="#2-算法与算法分析-Algorithms-and-algorithm-analysis" class="headerlink" title="2. 算法与算法分析 Algorithms and algorithm analysis"></a>2. 算法与算法分析 Algorithms and algorithm analysis</h2><h3 id="2-1-算法-Algorithm"><a href="#2-1-算法-Algorithm" class="headerlink" title="2.1 算法 (Algorithm)"></a><strong>2.1 算法 (Algorithm)</strong></h3><p>算法是<code>指令的有限序列</code>，是对特定问题<code>求解步骤的描述</code>。算法具有下列五种<code>特性</code>：</p><p>An algorithm is a <code>finite sequence of instructions</code>, which is a description of a specific problem` solving step. The algorithm has the following five characteristics:</p><ul><li>(1) 有穷性</li></ul><p>步骤<code>有限</code>，执行时间<code>有限</code>。</p><p>The step <code>Limited</code>, the execution time <code>Limited</code>.</p><ul><li>(2) 确定性</li></ul><p>有<code>确切</code>的含义，<code>无二义性</code>，算法只有<code>唯一</code>的一条执行路径。</p><p>It has the meaning of <code>exact</code>, <code>ambiguity</code>, and the algorithm has only one execution path of <code>unique</code>.</p><ul><li>(3) 可行性</li></ul><p>可以通过<code>已经实现</code>的基本运算<code>执行有限次</code>来实现。</p><p>This can be achieved by <code>implemented basic operations</code> a limited number of times.</p><ul><li>(4) 输入</li></ul><p>算法具有<code>0个</code>或<code>多个</code>输入。</p><p>The algorithm has <code>0</code> or <code>multiple</code> inputs.</p><ul><li>(5) 输出</li></ul><p>算法具有<code>1个</code>或<code>多个</code>输出。(一个算法不能没有输出。)</p><p>The algorithm has <code>1</code> or <code>multiple</code> outputs. (An algorithm cannot have no output.)</p><pre><code class="C++">int sum(int num){    int result = 0;    for (int i = 1; i &lt;= num; i++)        result += i;    return result;}</code></pre><p><code>算法与程序</code>十分类似，但也有<code>区别</code>：</p><p><code>Algorithms</code> are very similar to programs, but there are also <code>diffs</code>:</p><ul><li>在<code>执行时间上</code>(In <code>execution time</code>)：</li></ul><p><code>算法</code>所描述的步骤是<code>一定有限</code>的，但<code>程序</code>可以<code>无限执行</code>下去。如：一个操作系统是在一个无限循环中执行的，而不是一个算法。</p><p>The steps described in <code>Algorithm</code> are <code>certainly limited</code>, but <code>Program</code> can be executed indefinitely. For example, an operating system is executed in an infinite loop, not an algorithm.</p><ul><li>在<code>语言描述上</code>(On <code>language description</code>)：</li></ul><p><code>程序</code>必须采用<code>规定的程序设计语言</code>来实现，而<code>算法没</code>有这种<code>限制</code>。</p><p><code>Program</code> must be implemented using <code>specified programming language</code>, and <code>algorithm does not have such</code> restrictions`.</p><h3 id="2-2-算法的设计要求-Algorithm-design-requirements"><a href="#2-2-算法的设计要求-Algorithm-design-requirements" class="headerlink" title="2.2 算法的设计要求 (Algorithm design requirements)"></a><strong>2.2 算法的<code>设计要求</code> (Algorithm design requirements)</strong></h3><ul><li>正确性(Correctness)</li></ul><p>算法应该能<code>正确</code>地<code>实现预定功能</code>；</p><p>The algorithm should be able to “correctly” achieve the intended function;</p><ul><li>易读性(Readability)</li></ul><p>算法应<code>易于阅读</code>和<code>理解</code>，以<code>便与调试</code>、<code>修改</code>和<code>扩充</code>；</p><p>The algorithm should be <code>easy to read</code> and <code>understand</code> in order to <code>comfort with debugging</code>, <code>modify</code> and <code>expand</code>;</p><ul><li>健壮性(Robustness)</li></ul><p>当<code>环境发生变化</code>(如非法输入)时，能<code>正确作出反应</code>或<code>进行处理</code>，<code>不产生</code>不正确的运算结果；</p><p>When <code>environment changes</code> (such as illegal input), it can <code>correctly respond</code> or <code>process</code>, and <code>do not produce</code> incorrect calculation results;</p><ul><li>高效性(Efficiency)</li></ul><p>算法应<code>有效地使用存储空间</code>并且<code>有较高的时间效率</code>。</p><p>The algorithm should <code>use storage space efficiently</code> and <code>have a high time efficiency</code>.</p><h3 id="2-3-算法效率的衡量方法-Method-of-measuring-algorithm-efficiency"><a href="#2-3-算法效率的衡量方法-Method-of-measuring-algorithm-efficiency" class="headerlink" title="2.3 算法效率的衡量方法 (Method of measuring algorithm efficiency)"></a><strong>2.3 算法效率的衡量方法 (Method of measuring algorithm efficiency)</strong></h3><ul><li>事前分析法 (Ex ante analysis)</li></ul><p>在<code>忽略计算机硬件、软件的因素后</code>，一个特定算法”工作量”的大小，只<code>依赖于问题的规模</code>。</p><p>After ignoring the factors of computer hardware and software, the size of the “workload” of a particular algorithm depends only on the scale of the problem.</p><ul><li>事后统计法(后期估算) (Post-mortem statistics (late estimation))</li></ul><p>通过<code>编写实际操作代码</code>，并将其<code>在计算机上进行运行</code>，通过<code>计算机的时钟</code>进行算法执行时间的统计。但由于时间统计<code>依赖于硬件与软件环境</code>，容易掩盖算法本身的优劣。</p><p>Calculate the execution time of the algorithm by writing the actual operation code and running it on the computer. However, because time statistics depend on the hardware and software environment, it is easy to obscure the pros and cons of the algorithm itself.</p><h3 id="2-4-时间复杂度-Time-Complexity"><a href="#2-4-时间复杂度-Time-Complexity" class="headerlink" title="2.4 时间复杂度 (Time Complexity)"></a><strong>2.4 时间复杂度 (Time Complexity)</strong></h3><p>O(N)是指该<code>算法的时间耗费</code>，是其所求解问题规模N的函数。当问题规模N趋于无穷大时，不考虑具体的运行时间函数，<code>只考虑运行时间函数的数量级(阶)</code>，这称为算法的渐进时间复杂度(Asymptotic Time Complexity)。</p><p>即：<code>忽略</code>低阶部分，只<code>保留</code>高阶部分，并<code>忽略</code>系数。</p><p>O (N) refers to the <code>time consumption of the algorithm</code> and is a function of the scale N of the problem it solves. When the problem size N tends to infinity, the specific runtime function is not considered, and only the magnitude (order) of the runtime function is considered. This is called the Asymptotic Time Complexity of the algorithm.</p><p>That is: <code>Ignore</code> low-order parts, only <code>remain</code> high-order parts, and <code>ignore</code> coefficients.</p><ul><li><strong>常量阶 (Constant order)</strong></li></ul><pre><code class="C++">{   ++x; s = 0; // 选取++x为基本操作，语句频度1，则时间复杂度O(n) = 1，即常量阶。}</code></pre><pre><code class="C++">for (j = 1; j &lt;= 10000; ++j)    {        ++x; // 选取++x为基本操作，语句频度为10000(即：1 * 10000)，但需要忽略系数，则时间复杂度为O(n) = 1，即常量阶。        s += x;    }</code></pre><ul><li><strong>对数阶 (Logarithmic order)</strong></li></ul><pre><code class="C++">s = 0;for (int j = 1; j &lt;= n; j *= 2)    ++x;// 选取++x为基本操作，语句频度为log2n(以2为底的对数阶)，则时间复杂度为O(log2n)，即对数阶。</code></pre><ul><li><strong>线性阶 (Linear order)</strong></li></ul><pre><code class="C++">for (int i = 1; i &lt;= 2 * n; ++i)    {        ++x;// 选取++x为基本操作，则语句频度为2 * n，但需要忽略系数，则时间复杂度为O(n)，即线性阶。        s += x;    }</code></pre><ul><li><strong>平方阶 (Square order)</strong></li></ul><pre><code class="C++">for (j = 1; j &lt;= n; ++j)    {// n + 1        for (k = 1; k &lt;= n / 4; ++k)        {            // n * (n/4 + 1)            ++x;// 选取++x为基本操作，则语句频度为n * n/4，忽略系数1/4，则时间复杂度为O(n^2)，即平方阶。            s += x;        }    }</code></pre><ul><li><strong>线性对数阶 (Linear logarithmic order)</strong></li></ul><pre><code class="C++">for (int j = 1; j &lt;= n; j *= 2)    {// 执行log2n次        for (int k = 1; k &lt;= n; ++k)        {            ++x;// 选取++x为基本操作，则时间复杂度为O(nlog2n)，即线性对数阶。            s += x;        }    }</code></pre><ul><li><strong>立方阶 (Cubic order)</strong></li></ul><pre><code class="C++">for (int i = 1; i &lt;= n; i++)    {// 执行n次        for (int j = 1; j &lt;= n; j++)        {// 执行n^2次            c[i][j] = 0;            for (int k = 1; k &lt;= n; k++)            {// 执行n^3次，语句频度为n * n^2 * n^ 3，但只取最高阶，即时间复杂度为O(n^3)，即立方阶。                c[i][j] = c[i][j] + a[i][k] * b[k][j];            }        }    }</code></pre><h3 id="2-5-空间复杂度-Space-Complexity"><a href="#2-5-空间复杂度-Space-Complexity" class="headerlink" title="2.5 空间复杂度 (Space Complexity)"></a><strong>2.5 空间复杂度 (Space Complexity)</strong></h3><p>如果<code>所需额外空间</code>相对于<code>输入数据量</code>来说只是一个<code>常数</code>，则称此算法为<code>&quot;原地工作&quot;</code>，此时的空间复杂度为O(1)。</p><p>If <code>required extra space</code> is only a <code>constant</code> relative to <code>input data volume</code>, then this algorithm is called <code>&quot;work in place&quot;</code> and the space complexity at this time is O(1).</p><p>例：问题<code>规模</code>为n，</p><p>(1)若使用<code>大小为n</code>的辅助一唯数组，则空间复杂度为：O(n)</p><p>(2)若使用<code>大小为n * n</code>的辅助一唯数组，则空间复杂度为：O(n^2)</p><p>(3)若使用了<code>100个</code>辅助变量，则空间复杂度为：O(1),即”原地工作”</p><p>Example: The problem <code>scale</code> is n,</p><p>(1) If an auxiliary one-only array of size <code>n</code> is used, the space complexity is: O (n)</p><p>(2) If an auxiliary one-only array whose size is <code>n * n</code> is used, the space complexity is: O (n ^ 2)</p><p>(3) If <code>100</code> auxiliary variables are used, the space complexity is: O (1), which means” work in place “</p><hr><h2 id="3-抽象数据类型-Abstract-Data-Type"><a href="#3-抽象数据类型-Abstract-Data-Type" class="headerlink" title="3. 抽象数据类型 (Abstract Data Type)"></a>3. 抽象数据类型 (<code>A</code>bstract <code>D</code>ata <code>T</code>ype)</h2><p>抽象数据类型和高级语言中的数据类型实质上<code>是一个概念</code>，抽象数据类型包含一般数据类型的概念，但<code>含义比一般数据类型更广、更抽象</code>。</p><p>Abstract data types and data types in high-level languages are essentially <code>a concept</code>. Abstract data types contain the concept of general data types, but the meaning is broader and more abstract than general data types.</p><p>抽象类型的<code>伪代码</code>定义格式如：</p><pre><code class="ADT">ADT 抽象数据类型名 {    数据对象 D: &lt;数据对象的定义&gt;    数据对象 R: &lt;数据对象的定义&gt;    数据对象 P: &lt;数据对象的定义&gt;} ADT 抽象数据类型名</code></pre><p>The abstract type of <code>pseudo code</code> is defined as follows:</p><pre><code class="ADT">ADT name {     Data Object D: &lt;Definition of Data Object&gt;     Data Object R: &lt;Definition of Data Object&gt;     Data Object P: &lt;Definition of Data Object&gt;} ADT name</code></pre><hr><h2 id="Donate-☕️"><a href="#Donate-☕️" class="headerlink" title="Donate ☕️"></a>Donate ☕️</h2><p>If you like my blog post, you can Donate to me in the following ways.</p><p>Please indicate the source when reprinting.</p><p>如果你喜欢我的博文，可以通过下面的方式支持我，你的支持是我最大的动力 😘</p><p>转载时请注明出处 ©️PhoenixNest</p><table><thead><tr><th align="center">Donate 😇</th><th align="center">Qr code</th></tr></thead><tbody><tr><td align="center">Wechat</td><td align="center"><img src="/img/wechat.png" alt="Wechat"></td></tr><tr><td align="center">Ali Pay</td><td align="center"><img src="/img/alipay.png" alt="Ali Pay"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning Notes </tag>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
